--  (c) Copyright 2012 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
------------------------------------------------------------
-------------------------------------------------------------------------------
-- Filename:          axi_mcdma_pkg.vhd
-- Description: This package contains various constants and functions for
--              AXI DMA operations.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.clog2;

package axi_mcdma_pkg is

-------------------------------------------------------------------------------
-- Function declarations
-------------------------------------------------------------------------------
-- Find minimum required btt width
function required_btt_width (dwidth     : integer;
                            burst_size  : integer;
                            btt_width   : integer)
            return  integer;

-- Return correct hertz paramter value
function hertz_prmtr_select(included        : integer;
                            lite_frequency  : integer;
                            sg_frequency    : integer)
    return integer;

-- Return SnF enable or disable
function enable_snf (sf_enabled         : integer;
                     axi_data_width     : integer;
                     axis_tdata_width   : integer)
    return integer;


function get_scheduler (mm2s_channels   : integer;
                     mm2s_scheduler   : integer)
    return integer;

-------------------------------------------------------------------------------
-- Constant Declarations
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- AXI Responce Values
-------------------------------------------------------------------------------
constant OKAY_RESP                  : std_logic_vector(1 downto 0)  := "00";
constant EXOKAY_RESP                : std_logic_vector(1 downto 0)  := "01";
constant SLVERR_RESP                : std_logic_vector(1 downto 0)  := "10";
constant DECERR_RESP                : std_logic_vector(1 downto 0)  := "11";

constant MTBF_STAGES                : integer := 4;
constant C_FIFO_MTBF                : integer := 4;
-------------------------------------------------------------------------------
-- Misc Constants
-------------------------------------------------------------------------------
-- total reg for the IP is 288+288
constant NUM_REG_TOTAL              : integer := 640; -- 320 per channel
-- 0 to 319 are for MM2S
-- 320 to 640 are for S2MM
-- 300 to 319 are common to both MM2S and S2MM

-- per channel or block i will have 16 registers
constant NUM_REG_PER_CHANNEL        : integer := 16;
constant CMD_BASE_WIDTH             : integer := 40+3;
constant BUFFER_LENGTH_WIDTH        : integer := 26;

-- Constants Used in Desc Updates
constant DESC_STS_TYPE              : std_logic := '1';
constant DESC_DATA_TYPE             : std_logic := '0';
constant DESC_LAST                  : std_logic := '1';
constant DESC_NOT_LAST              : std_logic := '0';

-- Interrupt Coalescing
constant ZERO_THRESHOLD             : std_logic_vector(7 downto 0) := (others => '0');
constant ONE_THRESHOLD              : std_logic_vector(7 downto 0) := "00000001";
constant ZERO_DELAY                 : std_logic_vector(7 downto 0) := (others => '0');

-------------------------------------------------------------------------------
-- AXI Lite AXI DMA Register Offsets
-------------------------------------------------------------------------------
-- channel wise index

constant MM2S_COMMON_LOW_INDEX       : integer := 0;
constant MM2S_COMMON_UP_INDEX       : integer := MM2S_COMMON_LOW_INDEX+15;

constant MM2S_CH1_LOW_INDEX          : integer := MM2S_COMMON_LOW_INDEX+16;
constant MM2S_CH1_UP_INDEX         : integer := MM2S_CH1_LOW_INDEX+15;

constant MM2S_OBSER_LOW_INDEX      : integer := 272;
constant MM2S_OBSER_UP_INDEX      : integer := 272+15;


-- if first 8 are marked for common then
constant REG_INCR : integer := 15;

constant MCDMA_CMN_LOW_INDEX : integer := 300;
constant MCDMA_CMN_UP_INDEX : integer := 319;

constant S2MM_COMMON_LOW_INDEX       : integer := 320;
constant S2MM_COMMON_UP_INDEX       : integer := S2MM_COMMON_LOW_INDEX+15;


constant S2MM_CH1_LOW_INDEX          : integer := S2MM_COMMON_LOW_INDEX+16;
constant S2MM_CH1_UP_INDEX         : integer := S2MM_CH1_LOW_INDEX+15;

constant S2MM_CH2_LOW_INDEX          : integer := S2MM_CH1_LOW_INDEX+16;
constant S2MM_CH2_UP_INDEX         : integer := S2MM_CH2_LOW_INDEX+15;

constant S2MM_CH3_LOW_INDEX          : integer := S2MM_CH2_LOW_INDEX+16;
constant S2MM_CH3_UP_INDEX         : integer := S2MM_CH3_LOW_INDEX+15;

constant S2MM_CH4_LOW_INDEX          : integer := S2MM_CH3_LOW_INDEX+16;
constant S2MM_CH4_UP_INDEX         : integer := S2MM_CH4_LOW_INDEX+15;

constant S2MM_CH5_LOW_INDEX          : integer := S2MM_CH4_LOW_INDEX+16;
constant S2MM_CH5_UP_INDEX         : integer := S2MM_CH5_LOW_INDEX+15;

constant S2MM_CH6_LOW_INDEX          : integer := S2MM_CH5_LOW_INDEX+16;
constant S2MM_CH6_UP_INDEX         : integer := S2MM_CH6_LOW_INDEX+15;

constant S2MM_CH7_LOW_INDEX          : integer := S2MM_CH6_LOW_INDEX+16;
constant S2MM_CH7_UP_INDEX         : integer := S2MM_CH7_LOW_INDEX+15;

constant S2MM_CH8_LOW_INDEX          : integer := S2MM_CH7_LOW_INDEX+16;
constant S2MM_CH8_UP_INDEX         : integer := S2MM_CH8_LOW_INDEX+15;

constant S2MM_OBSER_LOW_INDEX      : integer := 592;
constant S2MM_OBSER_UP_INDEX      : integer := 592+15;

constant MM2S_CMN_CTRL_OFFSET           : std_logic_vector(5 downto 0) := "000000";    -- 0x00
constant MM2S_CMN_STS_OFFSET            : std_logic_vector(5 downto 0) := "000100";    -- 0x04
constant MM2S_CMN_EN_DIS_OFFSET         : std_logic_vector(5 downto 0) := "001000";    -- 0x08
constant MM2S_CMN_SER_OFFSET            : std_logic_vector(5 downto 0) := "001100";    -- 0x0C
constant MM2S_CMN_ERROR_OFFSET          : std_logic_vector(5 downto 0) := "010000";    -- 0x10
constant MM2S_CMN_CH_SCHD_TYPE          : std_logic_vector(5 downto 0) := "010100";    -- 0x14
constant MM2S_CMN_WRR_REG1_OFFSET       : std_logic_vector(5 downto 0) := "011000";    -- 0x18
constant MM2S_CMN_WRR_REG2_OFFSET       : std_logic_vector(5 downto 0) := "011100";    -- 0x1C
constant MM2S_CMN_SER_STS_OFFSET        : std_logic_vector(5 downto 0) := "100000";    -- 0x20
constant MM2S_CMN_CACHE_OFFSET          : std_logic_vector(5 downto 0) := "100100";    -- 0x24
constant MM2S_CMN_INTR_OFFSET           : std_logic_vector(5 downto 0) := "101000";    -- 0x28

constant MM2S_CH_DMACR_OFFSET          : std_logic_vector(4 downto 0) := "00000";    -- 0x40
constant MM2S_CH_DMASR_OFFSET          : std_logic_vector(4 downto 0) := "00100";    -- 0x44
constant MM2S_CH_CURDESC_LSB_OFFSET    : std_logic_vector(4 downto 0) := "01000";    -- 0x48
constant MM2S_CH_CURDESC_MSB_OFFSET    : std_logic_vector(4 downto 0) := "01100";    -- 0x4C
constant MM2S_CH_TAILDESC_LSB_OFFSET   : std_logic_vector(4 downto 0) := "10000";    -- 0x50
constant MM2S_CH_TAILDESC_MSB_OFFSET   : std_logic_vector(4 downto 0) := "10100";    -- 0x54
constant MM2S_CH_PKTDRP_OFFSET         : std_logic_vector(4 downto 0) := "11000";    -- 0x54
constant MM2S_CH_PKTPROC_OFFSET        : std_logic_vector(4 downto 0) := "11100";    -- 0x54

constant S2MM_CMN_CTRL_OFFSET           : std_logic_vector(5 downto 0) := "000000";    -- 0x500
constant S2MM_CMN_STS_OFFSET            : std_logic_vector(5 downto 0) := "000100";    -- 0x504
constant S2MM_CMN_EN_DIS_OFFSET         : std_logic_vector(5 downto 0) := "001000";    -- 0x508
constant S2MM_CMN_SER_OFFSET            : std_logic_vector(5 downto 0) := "001100";    -- 0x50C
constant S2MM_CMN_ERROR_OFFSET          : std_logic_vector(5 downto 0) := "010000";    -- 0x510
constant S2MM_CMN_PKTDRP_STS_OFFSET     : std_logic_vector(5 downto 0) := "010100";    -- 0x514
constant S2MM_CMN_SER_STS_OFFSET        : std_logic_vector(5 downto 0) := "011000";    -- 0x518
constant S2MM_CMN_CACHE_OFFSET          : std_logic_vector(5 downto 0) := "011100";    -- 0x51C
constant S2MM_CMN_INTR_OFFSET           : std_logic_vector(5 downto 0) := "100000";    -- 0x520

constant S2MM_CH_DMACR_OFFSET          : std_logic_vector(4 downto 0) := "00000";    -- 0x540
constant S2MM_CH_DMASR_OFFSET          : std_logic_vector(4 downto 0) := "00100";    -- 0x544
constant S2MM_CH_CURDESC_LSB_OFFSET    : std_logic_vector(4 downto 0) := "01000";    -- 0x548
constant S2MM_CH_CURDESC_MSB_OFFSET    : std_logic_vector(4 downto 0) := "01100";    -- 0x54C
constant S2MM_CH_TAILDESC_LSB_OFFSET   : std_logic_vector(4 downto 0) := "10000";    -- 0x550
constant S2MM_CH_TAILDESC_MSB_OFFSET   : std_logic_vector(4 downto 0) := "10100";    -- 0x554
constant S2MM_CH_PKTDRP_OFFSET         : std_logic_vector(4 downto 0) := "11000";    -- 0x558
constant S2MM_CH_PKTPROC_OFFSET        : std_logic_vector(4 downto 0) := "11100";    -- 0x




constant RESERVED_20_OFFSET         : std_logic_vector(9 downto 0) := "0000100000";    -- 0x20
constant RESERVED_24_OFFSET         : std_logic_vector(9 downto 0) := "0000100100";    -- 0x24
constant MM2S_LENGTH_OFFSET         : std_logic_vector(9 downto 0) := "0000101000";    -- 0x28
-- Following was reserved, now is used for SG xCache and xUser
constant SGCTL_OFFSET               : std_logic_vector(9 downto 0) := "0000101100";    -- 0x2C





-------------------------------------------------------------------------------
-- Register Bit Constants
-------------------------------------------------------------------------------
-- MCDMACR
constant MCDMACR_RS_BIT               : integer := 0;
constant MCDMACR_RESERVED1_BIT        : integer := 1;
constant MCDMACR_RESET_BIT            : integer := 2;
constant MCDMACR_RESERVED3_BIT        : integer := 3;
constant MCDMACR_PKT_IRQEN_BIT        : integer := 4;
constant MCDMACR_IOC_IRQEN_BIT        : integer := 5;
constant MCDMACR_DLY_IRQEN_BIT        : integer := 6;
constant MCDMACR_ERR_IRQEN_BIT        : integer := 7;
constant MCDMACR_PKTTHRESH_LSB_BIT    : integer := 8;
constant MCDMACR_PKTTHRESH_MSB_BIT    : integer := 15;
constant MCDMACR_IRQTHRESH_LSB_BIT    : integer := 16;
constant MCDMACR_IRQTHRESH_MSB_BIT    : integer := 23;
constant MCDMACR_IRQDELAY_LSB_BIT     : integer := 24;
constant MCDMACR_IRQDELAY_MSB_BIT     : integer := 31;


-- MCDMASR
constant MCDMASR_HALTED_BIT               : integer := 0;
constant MCDMASR_IDLE_BIT                 : integer := 1;
constant MCDMASR_RESERVED2_BIT        : integer := 2;
constant MCDMASR_RESERVED3_BIT        : integer := 3;
constant MCDMASR_PKTIRQ_BIT        : integer := 4;
constant MCDMASR_IOCIRQ_BIT        : integer := 5;
constant MCDMASR_DLYIRQ_BIT        : integer := 6;
constant MCDMASR_ERRIRQ_BIT        : integer := 7;
constant MCDMASR_PKTTHRESH_LSB_BIT    : integer := 8;
constant MCDMASR_PKTTHRESH_MSB_BIT    : integer := 15;
constant MCDMASR_IRQTHRESH_LSB_BIT    : integer := 16;
constant MCDMASR_IRQTHRESH_MSB_BIT    : integer := 23;
constant MCDMASR_IRQDELAY_LSB_BIT     : integer := 24;
constant MCDMASR_IRQDELAY_MSB_BIT     : integer := 31;

-- MCDMA CHEN
constant MCDMACH_EN_LSB : integer := 0;
constant MCDMACH_EN_MSB : integer := 15;
constant MCDMACH_EN_RSDV_LSB : integer := 16;
constant MCDMACH_EN_RSDV_MSB : integer := 31;

-- MCDMAERROR
constant MCDMAER_DMA_INT_ER               : integer := 0;
constant MCDMAER_DMA_SLV_ER               : integer := 1;
constant MCDMAER_DMA_DEC_ER               : integer := 2;
constant MCDMAER_RESERVED3_BIT            : integer := 3;
constant MCDMAER_SG_INT_ER               : integer := 4;
constant MCDMAER_SG_SLV_ER               : integer := 5;
constant MCDMAER_SG_DEC_ER               : integer := 6;

-- channel MCDMACR
constant CHDMACR_START_STOP_BIT       : integer := 0;
constant CHDMACR_RESERVED1_BIT        : integer := 1;
constant CHDMACR_RESERVED2_BIT        : integer := 2;
constant CHDMACR_ERR_OTHER_IRQEN_BIT  : integer := 3;
constant CHDMACR_PKT_IRQEN_BIT        : integer := 4;
constant CHDMACR_IOC_IRQEN_BIT        : integer := 5;
constant CHDMACR_DLY_IRQEN_BIT        : integer := 6;
constant CHDMACR_ERR_IRQEN_BIT        : integer := 7;
constant CHDMACR_PKTTHRESH_LSB_BIT    : integer := 8;
constant CHDMACR_PKTTHRESH_MSB_BIT    : integer := 15;
constant CHDMACR_IRQTHRESH_LSB_BIT    : integer := 16;
constant CHDMACR_IRQTHRESH_MSB_BIT    : integer := 23;
constant CHDMACR_IRQDELAY_LSB_BIT     : integer := 24;
constant CHDMACR_IRQDELAY_MSB_BIT     : integer := 31;


-- channel MCDMASR
constant CHDMASR_IDLE                 : integer := 0;
constant CHDMASR_RESERVED1_BIT        : integer := 1;
constant CHDMASR_RESERVED2_BIT        : integer := 2;
constant CHDMASR_ERRIRQ_OTHER_BIT        : integer := 3;
constant CHDMASR_PKTIRQ_BIT        : integer := 4;
constant CHDMASR_IOCIRQ_BIT        : integer := 5;
constant CHDMASR_DLYIRQ_BIT        : integer := 6;
constant CHDMASR_ERRIRQ_BIT        : integer := 7;
constant CHDMASR_PKTTHRESH_LSB_BIT    : integer := 8;
constant CHDMASR_PKTTHRESH_MSB_BIT    : integer := 15;
constant CHDMASR_IRQTHRESH_LSB_BIT    : integer := 16;
constant CHDMASR_IRQTHRESH_MSB_BIT    : integer := 23;
constant CHDMASR_IRQDELAY_LSB_BIT     : integer := 24;
constant CHDMASR_IRQDELAY_MSB_BIT     : integer := 31;


-- CURDESC
constant CURDESC_LOWER_MSB_BIT      : integer := 31;
constant CURDESC_LOWER_LSB_BIT      : integer := 6;
constant CURDESC_RESERVED_BIT5      : integer := 5;
constant CURDESC_RESERVED_BIT4      : integer := 4;
constant CURDESC_RESERVED_BIT3      : integer := 3;
constant CURDESC_RESERVED_BIT2      : integer := 2;
constant CURDESC_RESERVED_BIT1      : integer := 1;
constant CURDESC_RESERVED_BIT0      : integer := 0;

-- TAILDESC
constant TAILDESC_LOWER_MSB_BIT     : integer := 31;
constant TAILDESC_LOWER_LSB_BIT     : integer := 6;
constant TAILDESC_RESERVED_BIT5     : integer := 5;
constant TAILDESC_RESERVED_BIT4     : integer := 4;
constant TAILDESC_RESERVED_BIT3     : integer := 3;
constant TAILDESC_RESERVED_BIT2     : integer := 2;
constant TAILDESC_RESERVED_BIT1     : integer := 1;
constant TAILDESC_RESERVED_BIT0     : integer := 0;

-- DataMover Command / Status Constants
constant DATAMOVER_CMDDONE_BIT      : integer := 7;
constant DATAMOVER_SLVERR_BIT       : integer := 6;
constant DATAMOVER_DECERR_BIT       : integer := 5;
constant DATAMOVER_INTERR_BIT       : integer := 4;
constant DATAMOVER_TAGMSB_BIT       : integer := 3;
constant DATAMOVER_TAGLSB_BIT       : integer := 0;

-- Descriptor Control Bits
constant DESC_BLENGTH_LSB_BIT       : integer := 0;
constant DESC_BLENGTH_MSB_BIT       : integer := 25;
constant DESC_RSVD23_BIT            : integer := 23;
constant DESC_RSVD24_BIT            : integer := 24;
constant DESC_RSVD25_BIT            : integer := 25;
constant DESC_EOF_BIT               : integer := 26;
constant DESC_SOF_BIT               : integer := 27;
constant DESC_RSVD28_BIT            : integer := 28;
constant DESC_RSVD29_BIT            : integer := 29;
constant DESC_RSVD30_BIT            : integer := 30;
constant DESC_IOC_BIT               : integer := 31;

-- Descriptor Status Bits
constant DESC_STS_CMPLTD_BIT        : integer := 31;
constant DESC_STS_DECERR_BIT        : integer := 30;
constant DESC_STS_SLVERR_BIT        : integer := 29;
constant DESC_STS_INTERR_BIT        : integer := 28;
constant DESC_STS_RXSOF_BIT         : integer := 27;
constant DESC_STS_RXEOF_BIT         : integer := 26;
constant DESC_STS_RSVD25_BIT        : integer := 25;
constant DESC_STS_RSVD24_BIT        : integer := 24;
constant DESC_STS_RSVD23_BIT        : integer := 23;
constant DESC_STS_XFRDBYTS_MSB_BIT  : integer := 22;
constant DESC_STS_XFRDBYTS_LSB_BIT  : integer := 0;


-- DataMover Command / Status Constants
constant DATAMOVER_STS_CMDDONE_BIT  : integer := 7;
constant DATAMOVER_STS_SLVERR_BIT   : integer := 6;
constant DATAMOVER_STS_DECERR_BIT   : integer := 5;
constant DATAMOVER_STS_INTERR_BIT   : integer := 4;
constant DATAMOVER_STS_TAGMSB_BIT   : integer := 3;
constant DATAMOVER_STS_TAGLSB_BIT   : integer := 0;

constant DATAMOVER_STS_TAGEOF_BIT   : integer := 1;
constant DATAMOVER_STS_TLAST_BIT    : integer := 31+3;

constant DATAMOVER_CMD_BTTLSB_BIT   : integer := 0;
constant DATAMOVER_CMD_BTTMSB_BIT   : integer := 22;
constant DATAMOVER_CMD_TYPE_BIT     : integer := 23;
constant DATAMOVER_CMD_DSALSB_BIT   : integer := 24;
constant DATAMOVER_CMD_DSAMSB_BIT   : integer := 29;
constant DATAMOVER_CMD_EOF_BIT      : integer := 30;
constant DATAMOVER_CMD_DRR_BIT      : integer := 31;
constant DATAMOVER_CMD_ADDRLSB_BIT  : integer := 32;

-- Note: Bit offset require adding ADDR WIDTH to get to actual bit index
constant DATAMOVER_CMD_ADDRMSB_BOFST: integer := 31;
constant DATAMOVER_CMD_TAGLSB_BOFST : integer := 32;
constant DATAMOVER_CMD_TAGMSB_BOFST : integer := 35;
constant DATAMOVER_CMD_RSVLSB_BOFST : integer := 36;
constant DATAMOVER_CMD_RSVMSB_BOFST : integer := 39;

--constant C_MAX_CHANNELS             : integer := 16;



end axi_mcdma_pkg;

-------------------------------------------------------------------------------
-- PACKAGE BODY
-------------------------------------------------------------------------------
package body axi_mcdma_pkg is



-------------------------------------------------------------------------------
-- Function to determine minimum bits required for BTT_SIZE field
-------------------------------------------------------------------------------
function required_btt_width ( dwidth    : integer;
                              burst_size: integer;
                              btt_width : integer)
    return integer  is
variable min_width : integer;

begin
    min_width := clog2((dwidth/8)*burst_size)+1;
    if(min_width > btt_width)then
        return min_width;
    else
        return btt_width;
    end if;
end function required_btt_width;

-------------------------------------------------------------------------------
-- function to return Frequency Hertz parameter based on inclusion of sg engine
-------------------------------------------------------------------------------
function hertz_prmtr_select(included        : integer;
                            lite_frequency  : integer;
                            sg_frequency    : integer)
    return integer is
    begin
        -- 1 = Scatter Gather Included
        -- 0 = Scatter Gather Excluded
        if(included = 1)then
            return sg_frequency;
        else
            return lite_frequency;
        end if;
    end;


-------------------------------------------------------------------------------
-- function to enable store and forward based on data width mismatch
-- or directly enabled
-------------------------------------------------------------------------------
function enable_snf (sf_enabled         : integer;
                     axi_data_width     : integer;
                     axis_tdata_width   : integer)
    return integer is
    begin
        -- If store and forward enable or data widths do not
        -- match then return 1 to enable snf
        if( (sf_enabled = 1) or (axi_data_width /= axis_tdata_width))then
            return 1;
        else
-- coverage off
            return 0;
-- coverage on
        end if;
    end;


function get_scheduler (mm2s_channels   : integer;
                     mm2s_scheduler   : integer)
    return integer is
    begin
        -- If store and forward enable or data widths do not
        -- match then return 1 to enable snf
        if((mm2s_channels = 1))then
            return 1;
        else
            return mm2s_scheduler;
        end if;
    end;

end package body axi_mcdma_pkg;


--  (c) Copyright 2012 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
------------------------------------------------------------
-------------------------------------------------------------------------------
-- Filename:          axi_mcdma_reset.vhd
-- Description: This entity encompasses the reset logic (soft and hard) for
--              distribution to the axi_vdma core.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library lib_cdc_v1_0_2;
library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;


-------------------------------------------------------------------------------
entity  axi_mcdma_reset is
    generic(
        C_INCLUDE_SG                : integer range 0 to 1          := 1;
            -- Include or Exclude the Scatter Gather Engine
            -- 0 = Exclude SG Engine - Enables Simple DMA Mode
            -- 1 = Include SG Engine - Enables Scatter Gather Mode

        C_SG_INCLUDE_STSCNTRL_STRM  : integer range 0 to 1          := 1;
            -- Include or Exclude AXI Status and AXI Control Streams
            -- 0 = Exclude Status and Control Streams
            -- 1 = Include Status and Control Streams

        C_PRMRY_IS_ACLK_ASYNC           : integer range 0 to 1 := 0;
            -- Primary MM2S/S2MM sync/async mode
            -- 0 = synchronous mode     - all clocks are synchronous
            -- 1 = asynchronous mode    - Primary data path channels (MM2S and S2MM)
            --                            run asynchronous to AXI Lite, DMA Control,
            --                            and SG.
        C_AXI_PRMRY_ACLK_FREQ_HZ        : integer := 100000000;
            -- Primary clock frequency in hertz

        C_AXI_SCNDRY_ACLK_FREQ_HZ       : integer := 100000000
            -- Secondary clock frequency in hertz
    );
    port (
        -- Clock Sources
        m_axi_sg_aclk               : in  std_logic                         ;              --
        axi_prmry_aclk              : in  std_logic                         ;              --
                                                                                           --
        -- Hard Reset                                                                      --
        axi_resetn                  : in  std_logic                         ;              --
                                                                                           --
        -- Soft Reset                                                                      --
        soft_reset                  : in  std_logic                         ;              --
        soft_reset_clr              : out std_logic  := '0'                 ;              --
        soft_reset_done             : in  std_logic                         ;              --
                                                                                           --
                                                                                           --
        all_idle                    : in  std_logic                         ;              --
        stop                        : in  std_logic                         ;              --
        halt                        : out std_logic := '0'                  ;              --
        halt_cmplt                  : in  std_logic                         ;              --
                                                                                           --
        -- Secondary Reset                                                                 --
        scndry_resetn               : out std_logic := '1'                  ;              --
        -- AXI Upsizer and Line Buffer                                                     --
        prmry_resetn                : out std_logic := '0'                  ;              --
        -- AXI DataMover Primary Reset (Raw)                                               --
        dm_prmry_resetn             : out std_logic := '1'                  ;              --
        -- AXI DataMover Secondary Reset (Raw)                                             --
        dm_scndry_resetn            : out std_logic := '1'                  ;              --
        -- AXI Primary Stream Reset Outputs                                                --
        prmry_reset_out_n           : out std_logic := '1'                  ;              --
        -- AXI Alternat Stream Reset Outputs                                               --
        altrnt_reset_out_n          : out std_logic := '1'                                 --
    );

-- Register duplication attribute assignments to control fanout
-- on handshake output signals

Attribute KEEP : string; -- declaration
Attribute EQUIVALENT_REGISTER_REMOVAL : string; -- declaration

Attribute KEEP of scndry_resetn                            : signal is "TRUE";
Attribute KEEP of prmry_resetn                             : signal is "TRUE";
Attribute KEEP of dm_scndry_resetn                         : signal is "TRUE";
Attribute KEEP of dm_prmry_resetn                          : signal is "TRUE";
Attribute KEEP of prmry_reset_out_n                        : signal is "TRUE";
Attribute KEEP of altrnt_reset_out_n                       : signal is "TRUE";

Attribute EQUIVALENT_REGISTER_REMOVAL of scndry_resetn     : signal is "no";
Attribute EQUIVALENT_REGISTER_REMOVAL of prmry_resetn      : signal is "no";
Attribute EQUIVALENT_REGISTER_REMOVAL of dm_scndry_resetn  : signal is "no";
Attribute EQUIVALENT_REGISTER_REMOVAL of dm_prmry_resetn   : signal is "no";
Attribute EQUIVALENT_REGISTER_REMOVAL of prmry_reset_out_n : signal is "no";
Attribute EQUIVALENT_REGISTER_REMOVAL of altrnt_reset_out_n: signal is "no";

end axi_mcdma_reset;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_reset is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  ATTRIBUTE async_reg                      : STRING;

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
-- Soft Reset Support
signal s_soft_reset_i               : std_logic := '0';
signal s_soft_reset_i_d1            : std_logic := '0';
signal s_soft_reset_i_re            : std_logic := '0';
signal assert_sftrst_d1             : std_logic := '0';
signal min_assert_sftrst            : std_logic := '0';
signal min_assert_sftrst_d1_cdc_tig         : std_logic := '0';
  --ATTRIBUTE async_reg OF min_assert_sftrst_d1_cdc_tig  : SIGNAL IS "true";
  --ATTRIBUTE async_reg OF min_assert_sftrst  : SIGNAL IS "true";

signal p_min_assert_sftrst          : std_logic := '0';
signal sft_rst_dly1                 : std_logic := '0';
signal sft_rst_dly2                 : std_logic := '0';
signal sft_rst_dly3                 : std_logic := '0';
signal sft_rst_dly4                 : std_logic := '0';
signal sft_rst_dly5                 : std_logic := '0';
signal sft_rst_dly6                 : std_logic := '0';
signal sft_rst_dly7                 : std_logic := '0';
signal sft_rst_dly8                 : std_logic := '0';
signal sft_rst_dly9                 : std_logic := '0';
signal sft_rst_dly10                : std_logic := '0';
signal sft_rst_dly11                : std_logic := '0';
signal sft_rst_dly12                : std_logic := '0';
signal sft_rst_dly13                : std_logic := '0';
signal sft_rst_dly14                : std_logic := '0';
signal sft_rst_dly15                : std_logic := '0';
signal sft_rst_dly16                : std_logic := '0';
signal soft_reset_d1                : std_logic := '0';
signal soft_reset_re                : std_logic := '0';

-- Soft Reset to Primary clock domain signals
signal p_soft_reset                 : std_logic := '0';
signal p_soft_reset_d1_cdc_tig              : std_logic := '0';
signal p_soft_reset_d2              : std_logic := '0';

  --ATTRIBUTE async_reg OF p_soft_reset_d1_cdc_tig  : SIGNAL IS "true";
  --ATTRIBUTE async_reg OF p_soft_reset_d2  : SIGNAL IS "true";
signal p_soft_reset_d3              : std_logic := '0';
signal p_soft_reset_re              : std_logic := '0';

-- Qualified soft reset in primary clock domain for
-- generating mimimum reset pulse for soft reset
signal p_soft_reset_i               : std_logic := '0';
signal p_soft_reset_i_d1            : std_logic := '0';
signal p_soft_reset_i_re            : std_logic := '0';


-- Graceful halt control
signal halt_cmplt_d1_cdc_tig                : std_logic := '0';
signal s_halt_cmplt                 : std_logic := '0';

  --ATTRIBUTE async_reg OF halt_cmplt_d1_cdc_tig  : SIGNAL IS "true";
  --ATTRIBUTE async_reg OF s_halt_cmplt  : SIGNAL IS "true";
signal p_halt_d1_cdc_tig                    : std_logic := '0';
signal p_halt                       : std_logic := '0';

  --ATTRIBUTE async_reg OF p_halt_d1_cdc_tig  : SIGNAL IS "true";
  --ATTRIBUTE async_reg OF p_halt  : SIGNAL IS "true";
signal s_halt                       : std_logic := '0';

-- composite reset (hard and soft)
signal resetn_i                     : std_logic := '1';
signal scndry_resetn_i              : std_logic := '1';
signal axi_resetn_d1_cdc_tig                : std_logic := '1';
signal axi_resetn_d2                : std_logic := '1';

  --ATTRIBUTE async_reg OF axi_resetn_d1_cdc_tig  : SIGNAL IS "true";
  --ATTRIBUTE async_reg OF axi_resetn_d2 : SIGNAL IS "true";

signal halt_i                       : std_logic := '0';

signal p_all_idle                   : std_logic := '1';
signal p_all_idle_d1_cdc_tig                : std_logic := '1';

signal halt_cmplt_reg : std_logic;

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

-------------------------------------------------------------------------------
-- Internal Hard Reset
-- Generate reset on hardware reset or soft reset
-------------------------------------------------------------------------------
resetn_i    <= '0' when s_soft_reset_i = '1'
                     or min_assert_sftrst = '1'
                     or axi_resetn = '0'
          else '1';

-------------------------------------------------------------------------------
-- Minimum Reset Logic for Soft Reset
-------------------------------------------------------------------------------
-- Register to generate rising edge on soft reset and falling edge
-- on reset assertion.
REG_SFTRST_FOR_RE : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            s_soft_reset_i_d1 <= s_soft_reset_i;
            assert_sftrst_d1  <= min_assert_sftrst;

            -- Register soft reset from DMACR to create
            -- rising edge pulse
            soft_reset_d1     <= soft_reset;

        end if;
    end process REG_SFTRST_FOR_RE;

-- rising edge pulse on internal soft reset
s_soft_reset_i_re <=  s_soft_reset_i and not s_soft_reset_i_d1;

-- CR605883
-- rising edge pulse on DMACR soft reset
REG_SOFT_RE : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            soft_reset_re   <= soft_reset and not soft_reset_d1;
        end if;
    end process REG_SOFT_RE;

-- falling edge detection on min soft rst to clear soft reset
-- bit in register module
soft_reset_clr <= (not min_assert_sftrst and assert_sftrst_d1)
                    or (not axi_resetn);


-------------------------------------------------------------------------------
-- Generate Reset for synchronous configuration
-------------------------------------------------------------------------------
GNE_SYNC_RESET : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
begin

    -- On start of soft reset shift pulse through to assert
    -- 7 clock later.  Used to set minimum 8clk assertion of
    -- reset.  Shift starts when all is idle and internal reset
    -- is asserted.
    MIN_PULSE_GEN : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(s_soft_reset_i_re = '1')then
                    sft_rst_dly1    <= '1';
                    sft_rst_dly2    <= '0';
                    sft_rst_dly3    <= '0';
                    sft_rst_dly4    <= '0';
                    sft_rst_dly5    <= '0';
                    sft_rst_dly6    <= '0';
                    sft_rst_dly7    <= '0';
                elsif(all_idle = '1')then
                    sft_rst_dly1    <= '0';
                    sft_rst_dly2    <= sft_rst_dly1;
                    sft_rst_dly3    <= sft_rst_dly2;
                    sft_rst_dly4    <= sft_rst_dly3;
                    sft_rst_dly5    <= sft_rst_dly4;
                    sft_rst_dly6    <= sft_rst_dly5;
                    sft_rst_dly7    <= sft_rst_dly6;
                end if;
            end if;
        end process MIN_PULSE_GEN;

    -- Drive minimum reset assertion for 8 clocks.
    MIN_RESET_ASSERTION : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then

                if(s_soft_reset_i_re = '1')then
                    min_assert_sftrst <= '1';
                elsif(sft_rst_dly7 = '1')then
                    min_assert_sftrst <= '0';
                end if;
            end if;
        end process MIN_RESET_ASSERTION;

    -------------------------------------------------------------------------------
    -- Soft Reset Support
    -------------------------------------------------------------------------------
    -- Generate reset on hardware reset or soft reset if system is idle
    -- On soft reset or error
    -- mm2s dma controller will idle immediatly
    -- sg fetch engine will complete current task and idle (desc's will flush)
    -- sg update engine will update all completed descriptors then idle
    REG_SOFT_RESET : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(soft_reset = '1'
                and all_idle = '1' and halt_cmplt = '1')then
                    s_soft_reset_i <= '1';

                elsif(soft_reset_done = '1')then
                    s_soft_reset_i <= '0';

                end if;
            end if;
        end process REG_SOFT_RESET;

    -- Halt datamover on soft_reset or on error.  Halt will stay
    -- asserted until s_soft_reset_i assertion which occurs when
    -- halt is complete or hard reset
    REG_DM_HALT : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(resetn_i = '0')then
                    halt_i <= '0';
                elsif(soft_reset_re = '1' or stop = '1')then
                    halt_i <= '1';
                end if;
            end if;
        end process REG_DM_HALT;

    halt <= halt_i;

    -- AXI Stream reset output
    REG_STRM_RESET_OUT : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                prmry_reset_out_n   <= resetn_i and not s_soft_reset_i;
            end if;
        end process REG_STRM_RESET_OUT;

    -- If in Scatter Gather mode and status control stream included
    GEN_ALT_RESET_OUT : if C_INCLUDE_SG = 1 and C_SG_INCLUDE_STSCNTRL_STRM = 1 generate
    begin
        -- AXI Stream reset output
        REG_ALT_RESET_OUT : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    altrnt_reset_out_n  <= resetn_i and not s_soft_reset_i;
                end if;
            end process REG_ALT_RESET_OUT;
    end generate GEN_ALT_RESET_OUT;

    -- If in Simple mode or status control stream excluded
    GEN_NO_ALT_RESET_OUT : if C_INCLUDE_SG = 0 or C_SG_INCLUDE_STSCNTRL_STRM = 0 generate
    begin
        altrnt_reset_out_n <= '1';
    end generate GEN_NO_ALT_RESET_OUT;

    -- Registered primary and secondary resets out
    REG_RESET_OUT : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                prmry_resetn <= resetn_i;
                scndry_resetn <= resetn_i;
            end if;
        end process REG_RESET_OUT;

    -- AXI DataMover Primary Reset (Raw)
    dm_prmry_resetn  <= resetn_i;

    -- AXI DataMover Secondary Reset (Raw)
    dm_scndry_resetn <= resetn_i;

end generate GNE_SYNC_RESET;


-------------------------------------------------------------------------------
-- Generate Reset for asynchronous configuration
-------------------------------------------------------------------------------
GEN_ASYNC_RESET : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
begin

    -- Primary clock is slower or equal to secondary therefore...
    -- For Halt - can simply pass secondary clock version of soft reset
    -- rising edge into p_halt assertion
    -- For Min Rst Assertion - can simply use secondary logic version of min pulse genator
    GEN_PRMRY_GRTR_EQL_SCNDRY : if C_AXI_PRMRY_ACLK_FREQ_HZ >= C_AXI_SCNDRY_ACLK_FREQ_HZ generate
    begin

        -- CR605883 - Register to provide pure register output for synchronizer
        REG_HALT_CONDITIONS : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    s_halt <= soft_reset_re or stop;
                end if;
            end process REG_HALT_CONDITIONS;

        -- Halt data mover on soft reset assertion, error (i.e. stop=1) or
        -- not running
HALT_PROCESS : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => s_halt,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => axi_prmry_aclk,
        scndry_resetn              => '0',
        scndry_out                 => p_halt,
        scndry_vect_out            => open
    );



--        HALT_PROCESS : process(axi_prmry_aclk)
--            begin
--                if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
--                    --p_halt_d1_cdc_tig <= soft_reset_re or stop;       -- CR605883
--                    p_halt_d1_cdc_tig <= s_halt;                        -- CR605883
--                    p_halt    <= p_halt_d1_cdc_tig;
--                end if;
--            end process HALT_PROCESS;

        -- On start of soft reset shift pulse through to assert
        -- 7 clock later.  Used to set minimum 8clk assertion of
        -- reset.  Shift starts when all is idle and internal reset
        -- is asserted.
        -- Adding 5 more flops to make up for 5 stages of Sync flops
        MIN_PULSE_GEN : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(s_soft_reset_i_re = '1')then
                        sft_rst_dly1    <= '1';
                        sft_rst_dly2    <= '0';
                        sft_rst_dly3    <= '0';
                        sft_rst_dly4    <= '0';
                        sft_rst_dly5    <= '0';
                        sft_rst_dly6    <= '0';
                        sft_rst_dly7    <= '0';
                        sft_rst_dly8    <= '0';
                        sft_rst_dly9    <= '0';
                        sft_rst_dly10   <= '0';
                        sft_rst_dly11   <= '0';
                        sft_rst_dly12   <= '0';
                        sft_rst_dly13   <= '0';
                        sft_rst_dly14   <= '0';
                        sft_rst_dly15   <= '0';
                        sft_rst_dly16   <= '0';
                    elsif(all_idle = '1')then
                        sft_rst_dly1    <= '0';
                        sft_rst_dly2    <= sft_rst_dly1;
                        sft_rst_dly3    <= sft_rst_dly2;
                        sft_rst_dly4    <= sft_rst_dly3;
                        sft_rst_dly5    <= sft_rst_dly4;
                        sft_rst_dly6    <= sft_rst_dly5;
                        sft_rst_dly7    <= sft_rst_dly6;
                        sft_rst_dly8    <= sft_rst_dly7;
                        sft_rst_dly9    <= sft_rst_dly8;
                        sft_rst_dly10   <= sft_rst_dly9;
                        sft_rst_dly11   <= sft_rst_dly10;
                        sft_rst_dly12   <= sft_rst_dly11;
                        sft_rst_dly13   <= sft_rst_dly12;
                        sft_rst_dly14   <= sft_rst_dly13;
                        sft_rst_dly15   <= sft_rst_dly14;
                        sft_rst_dly16   <= sft_rst_dly15;
                    end if;
                end if;
            end process MIN_PULSE_GEN;

        -- Drive minimum reset assertion for 8 clocks.
        MIN_RESET_ASSERTION : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then

                    if(s_soft_reset_i_re = '1')then
                        min_assert_sftrst <= '1';
                    elsif(sft_rst_dly16 = '1')then
                        min_assert_sftrst <= '0';
                    end if;
                end if;
            end process MIN_RESET_ASSERTION;

    end generate GEN_PRMRY_GRTR_EQL_SCNDRY;

    -- Primary clock is running slower than secondary therefore need to use a primary clock
    -- based rising edge version of soft_reset for primary halt assertion
    GEN_PRMRY_LESS_SCNDRY :  if C_AXI_PRMRY_ACLK_FREQ_HZ < C_AXI_SCNDRY_ACLK_FREQ_HZ generate
       signal soft_halt_int : std_logic := '0';
    begin

        -- Halt data mover on soft reset assertion, error (i.e. stop=1) or
        -- not running
         soft_halt_int <= p_soft_reset_re or stop;

HALT_PROCESS : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => soft_halt_int,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => axi_prmry_aclk,
        scndry_resetn              => '0',
        scndry_out                 => p_halt,
        scndry_vect_out            => open
    );

--        HALT_PROCESS : process(axi_prmry_aclk)
--            begin
--                if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
--                    p_halt_d1_cdc_tig <= p_soft_reset_re or stop;
--                    p_halt    <= p_halt_d1_cdc_tig;
--                end if;
--            end process HALT_PROCESS;


REG_IDLE2PRMRY : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => all_idle,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => axi_prmry_aclk,
        scndry_resetn              => '0',
        scndry_out                 => p_all_idle,
        scndry_vect_out            => open
    );

--        REG_IDLE2PRMRY : process(axi_prmry_aclk)
--            begin
--                if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
--                    p_all_idle_d1_cdc_tig   <= all_idle;
--                    p_all_idle      <= p_all_idle_d1_cdc_tig;
--                end if;
--            end process REG_IDLE2PRMRY;


        -- On start of soft reset shift pulse through to assert
        -- 7 clock later.  Used to set minimum 8clk assertion of
        -- reset.  Shift starts when all is idle and internal reset
        -- is asserted.
        MIN_PULSE_GEN : process(axi_prmry_aclk)
            begin
                if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
                    -- CR574188 - fixes issue with soft reset terminating too early
                    -- for primary slower than secondary clock
                    --if(p_soft_reset_re = '1')then
                    if(p_soft_reset_i_re = '1')then
                        sft_rst_dly1    <= '1';
                        sft_rst_dly2    <= '0';
                        sft_rst_dly3    <= '0';
                        sft_rst_dly4    <= '0';
                        sft_rst_dly5    <= '0';
                        sft_rst_dly6    <= '0';
                        sft_rst_dly7    <= '0';
                        sft_rst_dly8    <= '0';
                        sft_rst_dly9    <= '0';
                        sft_rst_dly10   <= '0';
                        sft_rst_dly11   <= '0';
                        sft_rst_dly12   <= '0';
                        sft_rst_dly13   <= '0';
                        sft_rst_dly14   <= '0';
                        sft_rst_dly15   <= '0';
                        sft_rst_dly16   <= '0';
                    elsif(p_all_idle = '1')then
                        sft_rst_dly1    <= '0';
                        sft_rst_dly2    <= sft_rst_dly1;
                        sft_rst_dly3    <= sft_rst_dly2;
                        sft_rst_dly4    <= sft_rst_dly3;
                        sft_rst_dly5    <= sft_rst_dly4;
                        sft_rst_dly6    <= sft_rst_dly5;
                        sft_rst_dly7    <= sft_rst_dly6;
                        sft_rst_dly8    <= sft_rst_dly7;
                        sft_rst_dly9    <= sft_rst_dly8;
                        sft_rst_dly10   <= sft_rst_dly9;
                        sft_rst_dly11   <= sft_rst_dly10;
                        sft_rst_dly12   <= sft_rst_dly11;
                        sft_rst_dly13   <= sft_rst_dly12;
                        sft_rst_dly14   <= sft_rst_dly13;
                        sft_rst_dly15   <= sft_rst_dly14;
                        sft_rst_dly16   <= sft_rst_dly15;
                    end if;
                end if;
            end process MIN_PULSE_GEN;

        -- Drive minimum reset assertion for 8 primary clocks.
        MIN_RESET_ASSERTION : process(axi_prmry_aclk)
            begin
                if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then

                    -- CR574188 - fixes issue with soft reset terminating too early
                    -- for primary slower than secondary clock
                    --if(p_soft_reset_re = '1')then
                    if(p_soft_reset_i_re = '1')then
                        p_min_assert_sftrst <= '1';
                    elsif(sft_rst_dly16 = '1')then
                        p_min_assert_sftrst <= '0';
                    end if;
                end if;
            end process MIN_RESET_ASSERTION;

        -- register minimum reset pulse back to secondary domain

REG_MINRST2SCNDRY : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => p_min_assert_sftrst,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => min_assert_sftrst,
        scndry_vect_out            => open
    );

--        REG_MINRST2SCNDRY : process(m_axi_sg_aclk)
--        begin
--            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--                min_assert_sftrst_d1_cdc_tig <= p_min_assert_sftrst;
--                min_assert_sftrst    <= min_assert_sftrst_d1_cdc_tig;
--            end if;
--        end process REG_MINRST2SCNDRY;

        -- CR574188 - fixes issue with soft reset terminating too early
        -- for primary slower than secondary clock
        -- Generate reset on hardware reset or soft reset if system is idle
        REG_P_SOFT_RESET : process(axi_prmry_aclk)
            begin
                if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
                    if(p_soft_reset = '1'
                    and p_all_idle = '1'
                    and halt_cmplt = '1')then
                        p_soft_reset_i <= '1';
                    else
                        p_soft_reset_i <= '0';
                    end if;
                end if;
            end process REG_P_SOFT_RESET;

        -- CR574188 - fixes issue with soft reset terminating too early
        -- for primary slower than secondary clock
        -- Register qualified soft reset flag for generating rising edge
        -- pulse for starting minimum reset pulse
        REG_SOFT2PRMRY : process(axi_prmry_aclk)
            begin
                if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
                    p_soft_reset_i_d1 <=  p_soft_reset_i;
                end if;
            end process REG_SOFT2PRMRY;

        -- CR574188 - fixes issue with soft reset terminating too early
        -- for primary slower than secondary clock
        -- Generate rising edge pulse on qualified soft reset for min pulse
        -- logic.
        p_soft_reset_i_re <= p_soft_reset_i and not p_soft_reset_i_d1;

    end generate GEN_PRMRY_LESS_SCNDRY;

    -- Double register halt complete flag from primary to secondary
    -- clock domain.
    -- Note: halt complete stays asserted until halt clears therefore
    -- only need to double register from fast to slow clock domain.

process(axi_prmry_aclk)
begin
     if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
         halt_cmplt_reg <=  halt_cmplt;
     end if;
end process;

REG_HALT_CMPLT_IN : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => halt_cmplt_reg,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => s_halt_cmplt,
        scndry_vect_out            => open
    );

--    REG_HALT_CMPLT_IN : process(m_axi_sg_aclk)
--        begin
--            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--
--                halt_cmplt_d1_cdc_tig   <= halt_cmplt;
--                s_halt_cmplt    <= halt_cmplt_d1_cdc_tig;
--            end if;
--        end process REG_HALT_CMPLT_IN;

    -------------------------------------------------------------------------------
    -- Soft Reset Support
    -------------------------------------------------------------------------------
    -- Generate reset on hardware reset or soft reset if system is idle
    REG_SOFT_RESET : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(soft_reset = '1'
                and all_idle = '1'
                and s_halt_cmplt = '1')then
                    s_soft_reset_i <= '1';
                elsif(soft_reset_done = '1')then
                    s_soft_reset_i <= '0';
                end if;
            end if;
        end process REG_SOFT_RESET;

    -- Register soft reset flag into primary domain to correcly
    -- halt data mover

REG_SOFT2PRMRY : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => soft_reset,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => axi_prmry_aclk,
        scndry_resetn              => '0',
        scndry_out                 => p_soft_reset_d2,
        scndry_vect_out            => open
    );


    REG_SOFT2PRMRY1 : process(axi_prmry_aclk)
        begin
            if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
--                p_soft_reset_d1_cdc_tig <=  soft_reset;
--                p_soft_reset_d2 <=  p_soft_reset_d1_cdc_tig;
                p_soft_reset_d3 <=  p_soft_reset_d2;

            end if;
        end process REG_SOFT2PRMRY1;


    -- Generate rising edge pulse for use with p_halt creation
    p_soft_reset_re <= p_soft_reset_d2 and not p_soft_reset_d3;

    -- used to mask halt reset below
    p_soft_reset    <= p_soft_reset_d2;

    -- Halt datamover on soft_reset or on error.  Halt will stay
    -- asserted until s_soft_reset_i assertion which occurs when
    -- halt is complete or hard reset
    REG_DM_HALT : process(axi_prmry_aclk)
        begin
            if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
                if(axi_resetn_d2 = '0')then
                    halt_i <= '0';
                elsif(p_halt = '1')then
                    halt_i <= '1';
                end if;
            end if;
        end process REG_DM_HALT;

    halt <= halt_i;

    -- CR605883 (CDC) Create pure register out for synchronizer
    REG_CMB_RESET : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                scndry_resetn_i <= resetn_i;
            end if;
        end process REG_CMB_RESET;

    -- Sync to mm2s primary and register resets out

REG_RESET_OUT : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => scndry_resetn_i,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => axi_prmry_aclk,
        scndry_resetn              => '0',
        scndry_out                 => axi_resetn_d2,
        scndry_vect_out            => open
    );

--    REG_RESET_OUT : process(axi_prmry_aclk)
--        begin
--            if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
--                --axi_resetn_d1_cdc_tig  <= resetn_i;   -- CR605883
--                axi_resetn_d1_cdc_tig  <= scndry_resetn_i;
--                axi_resetn_d2  <= axi_resetn_d1_cdc_tig;
--            end if;
--        end process REG_RESET_OUT;

    -- Register resets out to AXI DMA Logic
    REG_SRESET_OUT : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                scndry_resetn <= resetn_i;
            end if;
        end process REG_SRESET_OUT;


    -- AXI Stream reset output
    prmry_reset_out_n   <= axi_resetn_d2;

    -- If in Scatter Gather mode and status control stream included
    GEN_ALT_RESET_OUT : if C_INCLUDE_SG = 1 and C_SG_INCLUDE_STSCNTRL_STRM = 1 generate
    begin
        -- AXI Stream alternate reset output
        altrnt_reset_out_n  <= axi_resetn_d2;
    end generate GEN_ALT_RESET_OUT;

    -- If in Simple Mode or status control stream excluded.
    GEN_NO_ALT_RESET_OUT : if C_INCLUDE_SG = 0 or C_SG_INCLUDE_STSCNTRL_STRM = 0 generate
    begin
        altrnt_reset_out_n  <= '1';
    end generate GEN_NO_ALT_RESET_OUT;

    -- Register primary reset
    prmry_resetn        <= axi_resetn_d2;

    -- AXI DataMover Primary Reset
    dm_prmry_resetn     <= axi_resetn_d2;

    -- AXI DataMover Secondary Reset
    dm_scndry_resetn    <= resetn_i;

end generate GEN_ASYNC_RESET;


end implementation;



--  (c) Copyright 2012 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
------------------------------------------------------------
-------------------------------------------------------------------------------
-- Filename:          axi_mcdma_rst_module.vhd
-- Description: This entity is the top level reset module entity for the
--              AXI VDMA core.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

library lib_cdc_v1_0_2;


-------------------------------------------------------------------------------
entity  axi_mcdma_rst_module is
    generic(
        C_INCLUDE_MM2S                  : integer range 0 to 1      := 1;
            -- Include or exclude MM2S primary data path
            -- 0 = Exclude MM2S primary data path
            -- 1 = Include MM2S primary data path
        C_INCLUDE_S2MM                  : integer range 0 to 1      := 1;
            -- Include or exclude S2MM primary data path
            -- 0 = Exclude S2MM primary data path
            -- 1 = Include S2MM primary data path

        C_INCLUDE_SG                : integer range 0 to 1          := 1;
            -- Include or Exclude the Scatter Gather Engine
            -- 0 = Exclude SG Engine - Enables Simple DMA Mode
            -- 1 = Include SG Engine - Enables Scatter Gather Mode

        C_SG_INCLUDE_STSCNTRL_STRM  : integer range 0 to 1          := 1;
            -- Include or Exclude AXI Status and AXI Control Streams
            -- 0 = Exclude Status and Control Streams
            -- 1 = Include Status and Control Streams

        C_PRMRY_IS_ACLK_ASYNC       : integer range 0 to 1          := 0;
            -- Primary MM2S/S2MM sync/async mode
            -- 0 = synchronous mode     - all clocks are synchronous
            -- 1 = asynchronous mode    - Primary data path channels (MM2S and S2MM)
            --                            run asynchronous to AXI Lite, DMA Control,
            --                            and SG.

        C_M_AXI_MM2S_ACLK_FREQ_HZ        : integer := 100000000;
            -- Primary clock frequency in hertz

        C_M_AXI_S2MM_ACLK_FREQ_HZ        : integer := 100000000;
            -- Primary clock frequency in hertz

        C_M_AXI_SG_ACLK_FREQ_HZ          : integer := 100000000
            -- Scatter Gather clock frequency in hertz




    );
    port (
        -----------------------------------------------------------------------
        -- Clock Sources
        -----------------------------------------------------------------------
        s_axi_lite_aclk             : in  std_logic                         ;
        m_axi_sg_aclk               : in  std_logic                         ;           --
        m_axi_mm2s_aclk             : in  std_logic                         ;           --
        m_axi_s2mm_aclk             : in  std_logic                         ;           --
                                                                                        --
        -----------------------------------------------------------------------         --
        -- Hard Reset                                                                   --
        -----------------------------------------------------------------------         --
        axi_resetn                  : in  std_logic                         ;           --

        -----------------------------------------------------------------------         --
        -- Soft Reset                                                                   --
        -----------------------------------------------------------------------         --
        soft_reset                  : in  std_logic                         ;           --
        soft_reset_clr              : out std_logic := '0'                  ;           --
                                                                                        --
        -----------------------------------------------------------------------         --
        -- MM2S Soft Reset Support                                                      --
        -----------------------------------------------------------------------         --
        mm2s_all_idle               : in  std_logic                         ;           --
        mm2s_stop                   : in  std_logic                         ;           --
        mm2s_halt                   : out std_logic := '0'                  ;           --
        mm2s_halt_cmplt             : in  std_logic                         ;           --
                                                                                        --
        -----------------------------------------------------------------------         --
        -- S2MM Soft Reset Support                                                      --
        -----------------------------------------------------------------------         --
        s2mm_all_idle               : in  std_logic                         ;           --
        s2mm_stop                   : in  std_logic                         ;           --
        s2mm_halt                   : out std_logic := '0'                  ;           --
        s2mm_halt_cmplt             : in  std_logic                         ;           --
                                                                                        --
        -----------------------------------------------------------------------         --
        -- MM2S Distributed Reset Out                                                   --
        -----------------------------------------------------------------------         --
        -- AXI DataMover Primary Reset (Raw)                                            --
        dm_mm2s_prmry_resetn        : out std_logic := '1'                  ;           --
        -- AXI DataMover Secondary Reset (Raw)                                          --
        dm_mm2s_scndry_resetn       : out std_logic := '1'                  ;
        -- AXI Stream Primary Reset Outputs                                             --
        mm2s_prmry_reset_out_n      : out std_logic := '1'                  ;           --
        -- AXI Stream Control Reset Outputs                                             --
        mm2s_cntrl_reset_out_n      : out std_logic := '1'                  ;           --
        -- AXI Secondary reset
        mm2s_scndry_resetn          : out std_logic := '1'                  ;           --
        -- AXI Upsizer and Line Buffer                                                  --
        mm2s_prmry_resetn           : out std_logic := '1'                  ;           --
                                                                                        --
                                                                                        --
        -----------------------------------------------------------------------         --
        -- S2MM Distributed Reset Out                                                   --
        -----------------------------------------------------------------------         --
        -- AXI DataMover Primary Reset (Raw)                                            --
        dm_s2mm_prmry_resetn        : out std_logic := '1'                  ;           --
        -- AXI DataMover Secondary Reset (Raw)                                          --
        dm_s2mm_scndry_resetn       : out std_logic := '1'                  ;
        -- AXI Stream Primary Reset Outputs                                             --
        s2mm_prmry_reset_out_n      : out std_logic := '1'                  ;           --
        -- AXI Stream Control Reset Outputs                                             --
        s2mm_sts_reset_out_n        : out std_logic := '1'                  ;           --
        -- AXI Secondary reset
        s2mm_scndry_resetn          : out std_logic := '1'                  ;           --
        -- AXI Upsizer and Line Buffer                                                  --
        s2mm_prmry_resetn           : out std_logic := '1'                  ;           --

        -----------------------------------------------------------------------         --
        -- Scatter Gather Distributed Reset Out
        -----------------------------------------------------------------------         --
        -- AXI Scatter Gather Reset Out
        m_axi_sg_aresetn            : out std_logic := '1'                  ;           --
        -- AXI Scatter Gather Datamover Reset Out
        dm_m_axi_sg_aresetn         : out std_logic := '1'                  ;           --


        -----------------------------------------------------------------------         --
        -- Hard Reset Out                                                               --
        -----------------------------------------------------------------------         --
        m_axi_sg_hrdresetn          : out std_logic := '1'                  ;           --
        s_axi_lite_resetn           : out std_logic := '1'                              --
    );


Attribute KEEP : string; -- declaration
Attribute EQUIVALENT_REGISTER_REMOVAL : string; -- declaration

Attribute KEEP of s_axi_lite_resetn                                 : signal is "TRUE";
Attribute KEEP of m_axi_sg_hrdresetn                                : signal is "TRUE";

Attribute EQUIVALENT_REGISTER_REMOVAL of s_axi_lite_resetn          : signal is "no";
Attribute EQUIVALENT_REGISTER_REMOVAL of m_axi_sg_hrdresetn         : signal is "no";

end axi_mcdma_rst_module;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_rst_module is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";






-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
  ATTRIBUTE async_reg                      : STRING;


signal hrd_resetn_i_cdc_tig                     : std_logic := '1';
signal hrd_resetn_i_d1_cdc_tig                  : std_logic := '1';
  --ATTRIBUTE async_reg OF hrd_resetn_i_cdc_tig  : SIGNAL IS "true";
  --ATTRIBUTE async_reg OF hrd_resetn_i_d1_cdc_tig : SIGNAL IS "true";

-- Soft reset support
signal mm2s_soft_reset_clr              : std_logic := '0';
signal s2mm_soft_reset_clr              : std_logic := '0';
signal soft_reset_clr_i                 : std_logic := '0';
signal mm2s_soft_reset_done             : std_logic := '0';
signal s2mm_soft_reset_done             : std_logic := '0';

signal mm2s_scndry_resetn_i             : std_logic := '0';
signal s2mm_scndry_resetn_i             : std_logic := '0';

signal dm_mm2s_scndry_resetn_i          : std_logic := '0';
signal dm_s2mm_scndry_resetn_i          : std_logic := '0';

signal sg_hard_reset                    : std_logic := '0';

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin
-- Register hard reset in

REG_HRD_RST : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => axi_resetn,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => sg_hard_reset, 
        scndry_vect_out            => open
    );

m_axi_sg_hrdresetn <= sg_hard_reset;

--REG_HRD_RST : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            hrd_resetn_i_cdc_tig        <= axi_resetn;
--            m_axi_sg_hrdresetn  <= hrd_resetn_i_cdc_tig;
--        end if;
--    end process REG_HRD_RST;

-- Regsiter hard reset out for axi lite interface

REG_HRD_RST_OUT : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => axi_resetn,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => s_axi_lite_aclk,
        scndry_resetn              => '0',
        scndry_out                 => s_axi_lite_resetn,
        scndry_vect_out            => open
    );


--REG_HRD_RST_OUT : process(s_axi_lite_aclk)
--    begin
--        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
--            hrd_resetn_i_d1_cdc_tig     <= hrd_resetn_i_cdc_tig;
--            s_axi_lite_resetn   <= hrd_resetn_i_d1_cdc_tig;
--        end if;
--    end process REG_HRD_RST_OUT;

dm_mm2s_scndry_resetn <= dm_mm2s_scndry_resetn_i;
dm_s2mm_scndry_resetn <= dm_s2mm_scndry_resetn_i;


-- mm2s channel included therefore map secondary resets to
-- from mm2s reset module to scatter gather interface (default)
MAP_SG_FOR_BOTH : if C_INCLUDE_MM2S = 1  and C_INCLUDE_S2MM = 1 generate
begin

    -- both must be low before sg reset is asserted.
    m_axi_sg_aresetn       <= mm2s_scndry_resetn_i or s2mm_scndry_resetn_i;
    dm_m_axi_sg_aresetn    <= dm_mm2s_scndry_resetn_i or dm_s2mm_scndry_resetn_i;

end generate MAP_SG_FOR_BOTH;

-- Only s2mm channel included therefore map secondary resets to
-- from s2mm reset module to scatter gather interface
MAP_SG_FOR_S2MM : if C_INCLUDE_MM2S = 0 and C_INCLUDE_S2MM = 1 generate
begin

    m_axi_sg_aresetn       <= s2mm_scndry_resetn_i;
    dm_m_axi_sg_aresetn    <= dm_s2mm_scndry_resetn_i;

end generate MAP_SG_FOR_S2MM;

-- Only mm2s channel included therefore map secondary resets to
-- from mm2s reset module to scatter gather interface
MAP_SG_FOR_MM2S : if C_INCLUDE_MM2S = 1 and C_INCLUDE_S2MM = 0 generate
begin

    m_axi_sg_aresetn       <= mm2s_scndry_resetn_i;
    dm_m_axi_sg_aresetn    <= dm_mm2s_scndry_resetn_i;

end generate MAP_SG_FOR_MM2S;

-- Invalid configuration for axi dma - simply here for completeness
MAP_NO_SG : if C_INCLUDE_MM2S = 0 and C_INCLUDE_S2MM = 0 generate
begin

    m_axi_sg_aresetn       <= '1';
    dm_m_axi_sg_aresetn    <= '1';

end generate MAP_NO_SG;


s2mm_scndry_resetn <= s2mm_scndry_resetn_i;
mm2s_scndry_resetn <= mm2s_scndry_resetn_i;



-- Generate MM2S reset signals
GEN_RESET_FOR_MM2S : if C_INCLUDE_MM2S = 1 generate
begin
    RESET_I : entity  axi_mcdma_v1_1_8.axi_mcdma_reset
        generic map(
            C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC        ,
            C_AXI_PRMRY_ACLK_FREQ_HZ    => C_M_AXI_MM2S_ACLK_FREQ_HZ    ,
            C_AXI_SCNDRY_ACLK_FREQ_HZ   => C_M_AXI_SG_ACLK_FREQ_HZ      ,
            C_SG_INCLUDE_STSCNTRL_STRM  => C_SG_INCLUDE_STSCNTRL_STRM   ,
            C_INCLUDE_SG                => C_INCLUDE_SG
        )
        port map(
            -- Clock Sources
            m_axi_sg_aclk               => m_axi_sg_aclk                ,
            axi_prmry_aclk              => m_axi_mm2s_aclk              ,

            -- Hard Reset
            axi_resetn                  => sg_hard_reset                 ,

            -- Soft Reset
            soft_reset                  => soft_reset                   ,
            soft_reset_clr              => mm2s_soft_reset_clr          ,
            soft_reset_done             => soft_reset_clr_i             ,

            all_idle                    => mm2s_all_idle                ,
            stop                        => mm2s_stop                    ,
            halt                        => mm2s_halt                    ,
            halt_cmplt                  => mm2s_halt_cmplt              ,


            -- Secondary Reset
            scndry_resetn               => mm2s_scndry_resetn_i         ,
            -- AXI Upsizer and Line Buffer
            prmry_resetn                => mm2s_prmry_resetn            ,
            -- AXI DataMover Primary Reset (Raw)
            dm_prmry_resetn             => dm_mm2s_prmry_resetn         ,
            -- AXI DataMover Secondary Reset (Raw)
            dm_scndry_resetn            => dm_mm2s_scndry_resetn_i      ,
            -- AXI Stream Primary Reset Outputs
            prmry_reset_out_n           => mm2s_prmry_reset_out_n       ,
            -- AXI Stream Alternate Reset Outputs
            altrnt_reset_out_n          => mm2s_cntrl_reset_out_n
        );


    -- Sample an hold mm2s soft reset done to use in
    -- combined reset done to DMACR
    MM2S_SOFT_RST_DONE : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(sg_hard_reset = '0' or soft_reset_clr_i = '1')then
                    mm2s_soft_reset_done <= '0';
                elsif(mm2s_soft_reset_clr = '1')then
                    mm2s_soft_reset_done <= '1';
                end if;
            end if;
        end process MM2S_SOFT_RST_DONE;

end generate GEN_RESET_FOR_MM2S;


-- No MM2S therefore tie off mm2s reset signals
GEN_NO_RESET_FOR_MM2S : if C_INCLUDE_MM2S = 0 generate
begin
    mm2s_prmry_reset_out_n  <= '1';
    mm2s_cntrl_reset_out_n  <= '1';
    dm_mm2s_scndry_resetn_i <= '1';
    dm_mm2s_prmry_resetn    <= '1';
    mm2s_prmry_resetn       <= '1';
    mm2s_scndry_resetn_i    <= '1';
    mm2s_halt               <= '0';
    mm2s_soft_reset_clr     <= '0';
    mm2s_soft_reset_done    <= '1';

end generate GEN_NO_RESET_FOR_MM2S;


-- Generate S2MM reset signals
GEN_RESET_FOR_S2MM : if C_INCLUDE_S2MM = 1 generate
begin
    RESET_I : entity  axi_mcdma_v1_1_8.axi_mcdma_reset
        generic map(
            C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC        ,
            C_AXI_PRMRY_ACLK_FREQ_HZ    => C_M_AXI_S2MM_ACLK_FREQ_HZ    ,
            C_AXI_SCNDRY_ACLK_FREQ_HZ   => C_M_AXI_SG_ACLK_FREQ_HZ      ,
            C_SG_INCLUDE_STSCNTRL_STRM  => C_SG_INCLUDE_STSCNTRL_STRM   ,
            C_INCLUDE_SG                => C_INCLUDE_SG
        )
        port map(
            -- Clock Sources
            m_axi_sg_aclk               => m_axi_sg_aclk                ,
            axi_prmry_aclk              => m_axi_s2mm_aclk              ,

            -- Hard Reset
            axi_resetn                  => sg_hard_reset                 ,

            -- Soft Reset
            soft_reset                  => soft_reset                   ,
            soft_reset_clr              => s2mm_soft_reset_clr          ,
            soft_reset_done             => soft_reset_clr_i             ,

            all_idle                    => s2mm_all_idle                ,
            stop                        => s2mm_stop                    ,
            halt                        => s2mm_halt                    ,
            halt_cmplt                  => s2mm_halt_cmplt              ,


            -- Secondary Reset
            scndry_resetn               => s2mm_scndry_resetn_i         ,
            -- AXI Upsizer and Line Buffer
            prmry_resetn                => s2mm_prmry_resetn            ,
            -- AXI DataMover Primary Reset (Raw)
            dm_prmry_resetn             => dm_s2mm_prmry_resetn         ,
            -- AXI DataMover Secondary Reset (Raw)
            dm_scndry_resetn            => dm_s2mm_scndry_resetn_i      ,
            -- AXI Stream Primary Reset Outputs
            prmry_reset_out_n           => s2mm_prmry_reset_out_n       ,
            -- AXI Stream Alternate Reset Outputs
            altrnt_reset_out_n          => s2mm_sts_reset_out_n
        );

    -- Sample an hold s2mm soft reset done to use in
    -- combined reset done to DMACR
    S2MM_SOFT_RST_DONE : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(sg_hard_reset = '0' or soft_reset_clr_i = '1')then
                    s2mm_soft_reset_done <= '0';
                elsif(s2mm_soft_reset_clr = '1')then
                    s2mm_soft_reset_done <= '1';
                end if;
            end if;
        end process S2MM_SOFT_RST_DONE;

end generate GEN_RESET_FOR_S2MM;

-- No SsMM therefore tie off mm2s reset signals
GEN_NO_RESET_FOR_S2MM : if C_INCLUDE_S2MM = 0 generate
begin
    s2mm_prmry_reset_out_n  <= '1';
    dm_s2mm_scndry_resetn_i <= '1';
    dm_s2mm_prmry_resetn    <= '1';
    s2mm_prmry_resetn       <= '1';
    s2mm_scndry_resetn_i    <= '1';
    s2mm_halt               <= '0';
    s2mm_soft_reset_clr     <= '0';
    s2mm_soft_reset_done    <= '1';

end generate GEN_NO_RESET_FOR_S2MM;




-- When both mm2s and s2mm are done then drive soft reset clear and
-- also clear s_h registers above
soft_reset_clr_i    <= s2mm_soft_reset_done and mm2s_soft_reset_done;

soft_reset_clr      <= soft_reset_clr_i;


end implementation;



-------------------------------------------------------------------------------
-- axi_mcdma_lite_if
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_mcdma_lite_if.vhd
-- Description: This entity is AXI Lite Interface Module for the AXI DMA
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

library lib_pkg_v1_0_2;
library lib_cdc_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.clog2;

-------------------------------------------------------------------------------
entity  axi_mcdma_lite_if is
    generic(
        C_NUM_CE                    : integer                := 8           ;
        C_AXI_LITE_IS_ASYNC         : integer range 0 to 1   := 0           ;
        C_S_AXI_LITE_ADDR_WIDTH     : integer range 2 to 32 := 32          ;
        C_S_AXI_LITE_DATA_WIDTH     : integer range 32 to 32 := 32
    );
    port (
        -- Async clock input
        ip2axi_aclk                 : in  std_logic                         ;          --
        ip2axi_aresetn              : in  std_logic                         ;          --

        -----------------------------------------------------------------------
        -- AXI Lite Control Interface
        -----------------------------------------------------------------------
        s_axi_lite_aclk             : in  std_logic                         ;          --
        s_axi_lite_aresetn          : in  std_logic                         ;          --
                                                                                       --
        -- AXI Lite Write Address Channel                                              --
        s_axi_lite_awvalid          : in  std_logic                         ;          --
        s_axi_lite_awready          : out std_logic                         ;          --
        s_axi_lite_awaddr           : in  std_logic_vector                             --
                                        (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0);          --
                                                                                       --
        -- AXI Lite Write Data Channel                                                 --
        s_axi_lite_wvalid           : in  std_logic                         ;          --
        s_axi_lite_wready           : out std_logic                         ;          --
        s_axi_lite_wdata            : in  std_logic_vector                             --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);          --
                                                                                       --
        -- AXI Lite Write Response Channel                                             --
        s_axi_lite_bresp            : out std_logic_vector(1 downto 0)      ;          --
        s_axi_lite_bvalid           : out std_logic                         ;          --
        s_axi_lite_bready           : in  std_logic                         ;          --
                                                                                       --
        -- AXI Lite Read Address Channel                                               --
        s_axi_lite_arvalid          : in  std_logic                         ;          --
        s_axi_lite_arready          : out std_logic                         ;          --
        s_axi_lite_araddr           : in  std_logic_vector                             --
                                        (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0);          --
        s_axi_lite_rvalid           : out std_logic                         ;          --
        s_axi_lite_rready           : in  std_logic                         ;          --
        s_axi_lite_rdata            : out std_logic_vector                             --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);          --
        s_axi_lite_rresp            : out std_logic_vector(1 downto 0)      ;          --
                                                                                       --
        -- User IP Interface                                                           --
        axi2ip_wrce                 : out std_logic_vector                             --
                                        (C_NUM_CE-1 downto 0)               ;          --
        axi2ip_wrdata               : out std_logic_vector                             --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);          --
                                                                                       --
        axi2ip_rdce                 : out std_logic_vector                             --
                                        (C_NUM_CE-1 downto 0)               ;          --

        axi2ip_rdaddr               : out std_logic_vector                             --
                                        (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0);          --
        ip2axi_rddata               : in std_logic_vector                              --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)           --
    );
end axi_mcdma_lite_if;


-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_lite_if is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";


-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
-- Register I/F Address offset
constant ADDR_OFFSET    : integer := clog2(C_S_AXI_LITE_DATA_WIDTH/8);
-- Register I/F CE number
constant CE_ADDR_SIZE   : integer := clog2(C_NUM_CE);

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
-- AXI Lite slave interface signals
signal awvalid              : std_logic := '0';
signal awaddr               : std_logic_vector
                                (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0) := (others => '0');
signal wvalid               : std_logic := '0';
signal wdata                : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');


signal arvalid              : std_logic := '0';
signal araddr               : std_logic_vector
                                (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0) := (others => '0');
signal awvalid_d1           : std_logic := '0';
signal awvalid_re           : std_logic := '0';
signal awready_i            : std_logic := '0';
signal wvalid_d1            : std_logic := '0';
signal wvalid_re            : std_logic := '0';
signal wready_i             : std_logic := '0';
signal bvalid_i             : std_logic := '0';

signal wr_addr_cap          : std_logic := '0';
signal wr_data_cap          : std_logic := '0';

-- AXI to IP interface signals
signal axi2ip_wraddr_i      : std_logic_vector
                                (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0) := (others => '0');
signal axi2ip_wrdata_i      : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal axi2ip_wren          : std_logic := '0';
signal wrce                 : std_logic_vector(C_NUM_CE-1 downto 0);

signal rdce                 : std_logic_vector(C_NUM_CE-1 downto 0) := (others => '0');
signal arvalid_d1           : std_logic := '0';
signal arvalid_re           : std_logic := '0';
signal arvalid_re_d1        : std_logic := '0';
signal arvalid_i            : std_logic := '0';
signal arready_i            : std_logic := '0';
signal rvalid               : std_logic := '0';
signal rvalid1               : std_logic := '0';
signal axi2ip_rdaddr_i      : std_logic_vector
                                (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0) := (others => '0');

signal s_axi_lite_rvalid_i  : std_logic := '0';
signal read_in_progress     : std_logic := '0'; -- CR607165
signal rst_rvalid_re        : std_logic := '0'; -- CR576999
signal rst_wvalid_re        : std_logic := '0'; -- CR576999
signal rdy : std_logic := '0';
signal rdy1 : std_logic := '0';
signal wr_in_progress : std_logic := '0';

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

--*****************************************************************************
--** AXI LITE READ
--*****************************************************************************

s_axi_lite_wready   <= wready_i;
s_axi_lite_awready  <= awready_i;
s_axi_lite_arready  <= arready_i;

s_axi_lite_bvalid   <= bvalid_i;

-------------------------------------------------------------------------------
-- Register AXI Inputs
-------------------------------------------------------------------------------
REG_INPUTS : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then
                awvalid <=  '0'                 ;
                awaddr  <=  (others => '0')     ;
                wvalid  <=  '0'                 ;
                wdata   <=  (others => '0')     ;
                arvalid <=  '0'                 ;
                araddr  <=  (others => '0')     ;
            else
                awvalid <= s_axi_lite_awvalid   ;
                awaddr  <= s_axi_lite_awaddr    ;
                wvalid  <= s_axi_lite_wvalid    ;
                wdata   <= s_axi_lite_wdata     ;
                arvalid <= s_axi_lite_arvalid   ;
                araddr  <= s_axi_lite_araddr    ;
            end if;
        end if;
    end process REG_INPUTS;



-- s_axi_lite_aclk is synchronous to ip clock
GEN_SYNC_WRITE : if C_AXI_LITE_IS_ASYNC = 0 generate
begin


-------------------------------------------------------------------------------
-- Assert Write Adddress Ready Handshake
-- Capture rising edge of valid and register out as ready.  This creates
-- a 3 clock cycle address phase but also registers all inputs and outputs.
-- Note : Single clock cycle address phase can be accomplished using
-- combinatorial logic.
-------------------------------------------------------------------------------
REG_AWVALID : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0' or rst_wvalid_re = '1')then
                awvalid_d1  <= '0';
--                awvalid_re  <= '0';                             -- CR605883
            else
                awvalid_d1  <= awvalid;
--                awvalid_re  <= awvalid and not awvalid_d1;      -- CR605883
            end if;
        end if;
    end process REG_AWVALID;

                awvalid_re  <= awvalid and not awvalid_d1 and (not (wr_in_progress));      -- CR605883
-------------------------------------------------------------------------------
-- Capture assertion of awvalid to indicate that we have captured
-- a valid address
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- Assert Write Data Ready Handshake
-- Capture rising edge of valid and register out as ready.  This creates
-- a 3 clock cycle address phase but also registers all inputs and outputs.
-- Note : Single clock cycle address phase can be accomplished using
-- combinatorial logic.
-------------------------------------------------------------------------------
REG_WVALID : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0' or rst_wvalid_re = '1')then
                wvalid_d1   <= '0';
--                wvalid_re   <= '0';
            else
                wvalid_d1   <= wvalid;
--                wvalid_re   <= wvalid and not wvalid_d1; -- CR605883
            end if;
        end if;
    end process REG_WVALID;

                wvalid_re   <= wvalid and not wvalid_d1; -- CR605883


WRITE_IN_PROGRESS : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0' or rst_wvalid_re = '1')then
                wr_in_progress <= '0';
            elsif(awvalid_re = '1')then
                wr_in_progress <= '1';
            end if;
        end if;
    end process WRITE_IN_PROGRESS;


-- CR605883 (CDC) provide pure register output to synchronizers
--wvalid_re  <= wvalid and not wvalid_d1 and not rst_wvalid_re;

                

-------------------------------------------------------------------------------
-- Capture assertion of wvalid to indicate that we have captured
-- valid data
-------------------------------------------------------------------------------


WRDATA_CAP_FLAG : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0' or rdy = '1')then
                wr_data_cap <= '0';
            elsif(wvalid_re = '1')then
                wr_data_cap <= '1';
            end if;
        end if;
    end process WRDATA_CAP_FLAG;

REG_WREADY : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0' or rdy = '1') then
                rdy <= '0';
            elsif (wr_data_cap = '1' and wr_addr_cap = '1') then
                rdy <= '1';
            end if;
                wready_i <= rdy;
                awready_i <= rdy;
                rdy1 <= rdy; 
        end if;
    end process REG_WREADY;


WRADDR_CAP_FLAG : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0' or rdy = '1')then
                wr_addr_cap <= '0';
            elsif(awvalid_re = '1')then
                wr_addr_cap <= '1';
            end if;
        end if;
    end process WRADDR_CAP_FLAG;
    -------------------------------------------------------------------------------
    -- Capture Write Address
    -------------------------------------------------------------------------------
    REG_WRITE_ADDRESS : process(s_axi_lite_aclk)
        begin
            if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
                if(s_axi_lite_aresetn = '0')then
                 --   axi2ip_wraddr_i   <= (others => '0');

                -- Register address on valid
                elsif(awvalid_re = '1')then
                 --   axi2ip_wraddr_i   <= awaddr;

                end if;
            end if;
        end process REG_WRITE_ADDRESS;

    -------------------------------------------------------------------------------
    -- Capture Write Data
    -------------------------------------------------------------------------------
    REG_WRITE_DATA : process(s_axi_lite_aclk)
        begin
            if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
                if(s_axi_lite_aresetn = '0')then
                    axi2ip_wrdata_i     <= (others => '0');

                -- Register address and assert ready
                elsif(wvalid_re = '1')then
                    axi2ip_wrdata_i     <= wdata;

                end if;
            end if;
        end process REG_WRITE_DATA;

    -------------------------------------------------------------------------------
    -- Must have both a valid address and valid data before updating
    -- a register.  Note in AXI write address can come before or
    -- after AXI write data.
--    axi2ip_wren <= '1' when wr_data_cap = '1' and wr_addr_cap = '1'
--                else '0';
      axi2ip_wren <= rdy; -- or rdy1;
    -------------------------------------------------------------------------------
    -- Decode and assert proper chip enable per captured axi lite write address
    -------------------------------------------------------------------------------
    WRCE_GEN: for j in 0 to C_NUM_CE - 1 generate

    constant BAR    : std_logic_vector(CE_ADDR_SIZE-1 downto 0) :=
                    std_logic_vector(to_unsigned(j,CE_ADDR_SIZE));
    begin

        wrce(j) <= axi2ip_wren when s_axi_lite_awaddr
                                    ((CE_ADDR_SIZE + ADDR_OFFSET) - 1
                                                        downto ADDR_OFFSET)

                                    = BAR(CE_ADDR_SIZE-1 downto 0)
              else '0';

    end generate WRCE_GEN;

    -------------------------------------------------------------------------------
    -- register write ce's and data out to axi dma register module
    -------------------------------------------------------------------------------
    REG_WR_OUT : process(s_axi_lite_aclk)
        begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then
                axi2ip_wrce     <= (others => '0');
        --        axi2ip_wrdata   <= (others => '0');
            else
                axi2ip_wrce     <= wrce;
        --        axi2ip_wrdata   <= axi2ip_wrdata_i;
            end if;
        end if;
    end process REG_WR_OUT;
  
             axi2ip_wrdata <= s_axi_lite_wdata; 

    -------------------------------------------------------------------------------
    -- Write Response
    -------------------------------------------------------------------------------
    s_axi_lite_bresp    <= OKAY_RESP;

    WRESP_PROCESS : process(s_axi_lite_aclk)
        begin
            if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
                if(s_axi_lite_aresetn = '0')then
                    bvalid_i        <= '0';
                    rst_wvalid_re   <= '0';     -- CR576999
                -- If response issued and target indicates ready then
                -- clear response
                elsif(bvalid_i = '1' and s_axi_lite_bready = '1')then
                    bvalid_i        <= '0';
                    rst_wvalid_re   <= '0';     -- CR576999
                -- Issue a resonse on write
                elsif(rdy1 = '1')then
                    bvalid_i        <= '1';
                    rst_wvalid_re   <= '1';     -- CR576999
                end if;
            end if;
        end process WRESP_PROCESS;


end generate GEN_SYNC_WRITE;


-- s_axi_lite_aclk is asynchronous to ip clock
GEN_ASYNC_WRITE : if C_AXI_LITE_IS_ASYNC = 1 generate
-- Data support

 -----------------------------------------------------------------------------
  -- ATTRIBUTE Declarations
  -----------------------------------------------------------------------------
  -- Prevent x-propagation on clock-domain crossing register
  ATTRIBUTE async_reg                      : STRING;
 Attribute KEEP : string; -- declaration
 Attribute EQUIVALENT_REGISTER_REMOVAL : string; -- declaration


signal ip_wvalid_d1_cdc_to     : std_logic := '0';
signal ip_wvalid_d2     : std_logic := '0';
signal ip_wvalid_re     : std_logic := '0';
signal wr_wvalid_re_cdc_from     : std_logic := '0';
signal wr_data_cdc_from          : std_logic_vector                                              -- CR605883
                            (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');    -- CR605883
signal wdata_d1_cdc_to         : std_logic_vector
                            (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal wdata_d2         : std_logic_vector
                            (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');

signal axi2ip_wrdata_cdc_tig         : std_logic_vector
                            (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal ip_data_cap      : std_logic := '0';

-- Address support
signal ip_awvalid_d1_cdc_to    : std_logic := '0';
signal ip_awvalid_d2    : std_logic := '0';
signal ip_awvalid_re    : std_logic := '0';
signal wr_awvalid_re_cdc_from    : std_logic := '0';
signal wr_addr_cdc_from          : std_logic_vector                                              -- CR605883
                            (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0) := (others => '0');    -- CR605883
signal awaddr_d1_cdc_tig        : std_logic_vector
                            (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0) := (others => '0');
signal awaddr_d2        : std_logic_vector
                            (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0) := (others => '0');
signal ip_addr_cap      : std_logic := '0';

-- Bvalid support
signal lite_data_cap_d1 : std_logic := '0';
signal lite_data_cap_d2 : std_logic := '0';
signal lite_addr_cap_d1 : std_logic := '0';
signal lite_addr_cap_d2 : std_logic := '0';
signal lite_axi2ip_wren : std_logic := '0';

signal awvalid_cdc_from : std_logic := '0';
signal awvalid_cdc_to : std_logic := '0';
signal awvalid_to : std_logic := '0';
signal awvalid_to2 : std_logic := '0';
  --ATTRIBUTE async_reg OF awvalid_cdc_to  : SIGNAL IS "true";
  --ATTRIBUTE async_reg OF awvalid_to  : SIGNAL IS "true";


signal wvalid_cdc_from : std_logic := '0';
signal wvalid_cdc_to : std_logic := '0';
signal wvalid_to : std_logic := '0';
signal wvalid_to2 : std_logic := '0';
  --ATTRIBUTE async_reg OF wvalid_cdc_to  : SIGNAL IS "true";
  --ATTRIBUTE async_reg OF wvalid_to  : SIGNAL IS "true";

signal rdy_cdc_to : std_logic := '0';
signal rdy_cdc_from : std_logic := '0';
signal rdy_to : std_logic := '0';
signal rdy_to2 : std_logic := '0';
signal rdy_to2_cdc_from : std_logic := '0';
signal rdy_out : std_logic := '0';
  --ATTRIBUTE async_reg OF rdy_cdc_to  : SIGNAL IS "true";
  --ATTRIBUTE async_reg OF rdy_to  : SIGNAL IS "true";

  Attribute KEEP of rdy_to2_cdc_from       : signal is "TRUE";
  Attribute EQUIVALENT_REGISTER_REMOVAL of rdy_to2_cdc_from : signal is "no";

signal rdy_back_cdc_to : std_logic := '0';
signal rdy_back_to : std_logic :='0';
  --ATTRIBUTE async_reg OF rdy_back_cdc_to  : SIGNAL IS "true";
  --ATTRIBUTE async_reg OF rdy_back_to  : SIGNAL IS "true";

signal rdy_back : std_logic := '0';

signal rdy_shut : std_logic := '0';

begin

REG_AWVALID : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0' or rst_wvalid_re = '1')then
                awvalid_d1  <= '0';
            else
                awvalid_d1  <= awvalid;
            end if;
        end if;
    end process REG_AWVALID;

           
WRITE_IN_PROGRESS : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0' or rst_wvalid_re = '1')then
                wr_in_progress <= '0';
            elsif(awvalid_re = '1')then
                wr_in_progress <= '1';
            end if;
        end if;
    end process WRITE_IN_PROGRESS;


     awvalid_re  <= awvalid and not awvalid_d1 and (not (wr_in_progress));      -- CR605883
-------------------------------------------------------------------------------
-- Capture assertion of awvalid to indicate that we have captured
-- a valid address
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- Assert Write Data Ready Handshake
-- Capture rising edge of valid and register out as ready.  This creates
-- a 3 clock cycle address phase but also registers all inputs and outputs.
-- Note : Single clock cycle address phase can be accomplished using
-- combinatorial logic.
-------------------------------------------------------------------------------
REG_WVALID : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0' or rst_wvalid_re = '1')then
                wvalid_d1   <= '0';
            else
                wvalid_d1   <= wvalid;
            end if;
        end if;
    end process REG_WVALID;

                wvalid_re   <= wvalid and not wvalid_d1; -- CR605883

    --*************************************************************************
    --** Write Address Support
    --*************************************************************************

    AWVLD_CDC_FROM : process(s_axi_lite_aclk)
        begin
            if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
                if(s_axi_lite_aresetn = '0' or rst_wvalid_re = '1')then
                    awvalid_cdc_from <= '0';
                elsif(awvalid_re = '1')then
                    awvalid_cdc_from <= '1';
                end if;
            end if;
        end process AWVLD_CDC_FROM;

AWVLD_CDC_TO : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axi_lite_aclk,
        prmry_resetn               => '0', 
        prmry_in                   => awvalid_cdc_from, 
        prmry_vect_in              => (others => '0'),
                                    
        scndry_aclk                => ip2axi_aclk, 
        scndry_resetn              => '0',
        scndry_out                 => awvalid_to,
        scndry_vect_out            => open
    );


--    AWVLD_CDC_TO : process(ip2axi_aclk)
--        begin
--            if(ip2axi_aclk'EVENT and ip2axi_aclk = '1')then
--                    awvalid_cdc_to <= awvalid_cdc_from;
--                    awvalid_to <= awvalid_cdc_to;
--            end if;
--        end process AWVLD_CDC_TO;

    AWVLD_CDC_TO2 : process(ip2axi_aclk)
        begin
            if(ip2axi_aclk'EVENT and ip2axi_aclk = '1')then
                if(ip2axi_aresetn = '0')then
                    awvalid_to2 <= '0';
                else
                    awvalid_to2 <= awvalid_to;
                end if;
            end if;
        end process AWVLD_CDC_TO2;


               ip_awvalid_re <= awvalid_to and (not awvalid_to2);


    WVLD_CDC_FROM : process(s_axi_lite_aclk)
        begin
            if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
                if(s_axi_lite_aresetn = '0' or rst_wvalid_re = '1')then
                    wvalid_cdc_from <= '0';
                elsif(wvalid_re = '1')then
                    wvalid_cdc_from <= '1';
                end if;
            end if;
        end process WVLD_CDC_FROM;


WVLD_CDC_TO : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axi_lite_aclk,
        prmry_resetn               => '0', 
        prmry_in                   => wvalid_cdc_from, 
        prmry_vect_in              => (others => '0'),
                                    
        scndry_aclk                => ip2axi_aclk, 
        scndry_resetn              => '0',
        scndry_out                 => wvalid_to,
        scndry_vect_out            => open
    );

--    WVLD_CDC_TO : process(ip2axi_aclk)
--        begin
--            if(ip2axi_aclk'EVENT and ip2axi_aclk = '1')then
--                    wvalid_cdc_to <= wvalid_cdc_from;
--                    wvalid_to <= wvalid_cdc_to;
--            end if;
--        end process WVLD_CDC_TO;


    WVLD_CDC_TO2 : process(ip2axi_aclk)
        begin
            if(ip2axi_aclk'EVENT and ip2axi_aclk = '1')then
                if(ip2axi_aresetn = '0')then
                    wvalid_to2 <= '0';
                else
                    wvalid_to2 <= wvalid_to;
                end if;
            end if;
        end process WVLD_CDC_TO2;

               ip_wvalid_re <= wvalid_to and (not wvalid_to2);


REG_WADDR_TO_IPCLK : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 0,
        C_VECTOR_WIDTH             => C_S_AXI_LITE_ADDR_WIDTH,
        C_MTBF_STAGES              => 1
    )
    port map (
        prmry_aclk                 => s_axi_lite_aclk,
        prmry_resetn               => '0', 
        prmry_in                   => '0', 
        prmry_vect_in              => s_axi_lite_awaddr,
                                    
        scndry_aclk                => ip2axi_aclk, 
        scndry_resetn              => '0',
        scndry_out                 => open, 
        scndry_vect_out            => awaddr_d1_cdc_tig
    );


REG_WADDR_TO_IPCLK1 : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 0,
        C_VECTOR_WIDTH             => C_S_AXI_LITE_DATA_WIDTH,
        C_MTBF_STAGES              => 1
    )
    port map (
        prmry_aclk                 => s_axi_lite_aclk,
        prmry_resetn               => '0', 
        prmry_in                   => '0', 
        prmry_vect_in              => s_axi_lite_wdata,
                                    
        scndry_aclk                => ip2axi_aclk, 
        scndry_resetn              => '0',
        scndry_out                 => open, 
        scndry_vect_out            => axi2ip_wrdata_cdc_tig
    );

    -- Double register address in
--    REG_WADDR_TO_IPCLK : process(ip2axi_aclk)
--        begin
--            if(ip2axi_aclk'EVENT and ip2axi_aclk = '1')then
--                if(ip2axi_aresetn = '0')then
--                    awaddr_d1_cdc_tig           <= (others => '0');
--                --    axi2ip_wraddr_i     <= (others => '0');
--                    axi2ip_wrdata_cdc_tig <= (others => '0');
--                else
--                    awaddr_d1_cdc_tig           <= s_axi_lite_awaddr;
--                    axi2ip_wrdata_cdc_tig       <= s_axi_lite_wdata;
--                --    axi2ip_wraddr_i     <= awaddr_d1_cdc_tig;           -- CR605883
--                end if;
--            end if;
--        end process REG_WADDR_TO_IPCLK;

    -- Flag that address has been captured
    REG_IP_ADDR_CAP : process(ip2axi_aclk)
        begin
            if(ip2axi_aclk'EVENT and ip2axi_aclk = '1')then
                if(ip2axi_aresetn = '0' or rdy_shut = '1')then
                    ip_addr_cap <= '0';
                elsif(ip_awvalid_re = '1')then
                    ip_addr_cap <= '1';
                end if;
            end if;
        end process REG_IP_ADDR_CAP;


    REG_WREADY : process(ip2axi_aclk)
    begin
        if(ip2axi_aclk'EVENT and ip2axi_aclk = '1')then
            if(ip2axi_aresetn = '0' or rdy_shut = '1') then -- or rdy = '1') then
                rdy <= '0';
            elsif (ip_data_cap = '1' and ip_addr_cap = '1') then
                rdy <= '1';
            end if;
        end if;
    end process REG_WREADY;

REG3_WREADY : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axi_lite_aclk,
        prmry_resetn               => '0', 
        prmry_in                   => rdy_to2_cdc_from, 
        prmry_vect_in              => (others => '0'),
                                    
        scndry_aclk                => ip2axi_aclk, 
        scndry_resetn              => '0',
        scndry_out                 => rdy_back_to,
        scndry_vect_out            => open
    );

--    REG3_WREADY : process(ip2axi_aclk)
--    begin
--        if(ip2axi_aclk'EVENT and ip2axi_aclk = '1')then
--                rdy_back_cdc_to <= rdy_to2_cdc_from;
--                rdy_back_to <= rdy_back_cdc_to;
--        end if;
--    end process REG3_WREADY;


    REG3_WREADY2 : process(ip2axi_aclk)
    begin
        if(ip2axi_aclk'EVENT and ip2axi_aclk = '1')then
            if(ip2axi_aresetn = '0') then
                rdy_back <= '0';
            else
                rdy_back <= rdy_back_to;
            end if;
        end if;
    end process REG3_WREADY2;

    rdy_shut <= rdy_back_to and (not rdy_back);


    REG1_WREADY : process(ip2axi_aclk)
    begin
        if(ip2axi_aclk'EVENT and ip2axi_aclk = '1')then
            if(ip2axi_aresetn = '0' or rdy_shut = '1') then
                rdy_cdc_from <= '0';
            elsif (rdy = '1') then
                rdy_cdc_from <= '1';
            end if;
        end if;
    end process REG1_WREADY;


REG2_WREADY : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => ip2axi_aclk,
        prmry_resetn               => '0', 
        prmry_in                   => rdy_cdc_from, 
        prmry_vect_in              => (others => '0'),
                                    
        scndry_aclk                => s_axi_lite_aclk, 
        scndry_resetn              => '0',
        scndry_out                 => rdy_to,
        scndry_vect_out            => open
    );


--    REG2_WREADY : process(s_axi_lite_aclk)
--    begin
--        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
--                rdy_cdc_to <= rdy_cdc_from;
--                rdy_to <= rdy_cdc_to;
--        end if;
--    end process REG2_WREADY;

    REG2_WREADY2 : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0') then
                rdy_to2 <= '0';
                rdy_to2_cdc_from <= '0';
            else
                rdy_to2 <= rdy_to;
                rdy_to2_cdc_from <= rdy_to;
            end if;
        end if;
    end process REG2_WREADY2;


   rdy_out <= not (rdy_to) and rdy_to2;

                wready_i <= rdy_out;
                awready_i <= rdy_out;


    --*************************************************************************
    --** Write Data Support
    --*************************************************************************

    -------------------------------------------------------------------------------
    -- Capture write data
    -------------------------------------------------------------------------------
--    WRDATA_S_H : process(s_axi_lite_aclk)
--        begin
--            if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
--                if(s_axi_lite_aresetn = '0')then
--                    wr_data_cdc_from <= (others => '0');
--                elsif(wvalid_re = '1')then
--                    wr_data_cdc_from <= wdata;
--                end if;
--            end if;
--        end process WRDATA_S_H;


    -- Flag that data has been captured
    REG_IP_DATA_CAP : process(ip2axi_aclk)
        begin
            if(ip2axi_aclk'EVENT and ip2axi_aclk = '1')then
                if(ip2axi_aresetn = '0' or rdy_shut = '1')then
                    ip_data_cap <= '0';
                elsif(ip_wvalid_re = '1')then
                    ip_data_cap <= '1';
                end if;
            end if;
        end process REG_IP_DATA_CAP;

    -- Must have both a valid address and valid data before updating
    -- a register.  Note in AXI write address can come before or
    -- after AXI write data.

      axi2ip_wren <= rdy;
--    axi2ip_wren <= '1' when ip_data_cap = '1' and ip_addr_cap = '1'
--                else '0';

    -------------------------------------------------------------------------------
    -- Decode and assert proper chip enable per captured axi lite write address
    -------------------------------------------------------------------------------
    WRCE_GEN: for j in 0 to C_NUM_CE - 1 generate

    constant BAR    : std_logic_vector(CE_ADDR_SIZE-1 downto 0) :=
                    std_logic_vector(to_unsigned(j,CE_ADDR_SIZE));
    begin

        wrce(j) <= axi2ip_wren when awaddr_d1_cdc_tig
                                    ((CE_ADDR_SIZE + ADDR_OFFSET) - 1
                                                        downto ADDR_OFFSET)

                                    = BAR(CE_ADDR_SIZE-1 downto 0)
              else '0';

    end generate WRCE_GEN;

    -------------------------------------------------------------------------------
    -- register write ce's and data out to axi dma register module
    -------------------------------------------------------------------------------
    REG_WR_OUT : process(ip2axi_aclk)
        begin
        if(ip2axi_aclk'EVENT and ip2axi_aclk = '1')then
            if(ip2axi_aresetn = '0')then
                axi2ip_wrce     <= (others => '0');
            else
                axi2ip_wrce     <= wrce;
            end if;
        end if;
    end process REG_WR_OUT;

     axi2ip_wrdata  <=  axi2ip_wrdata_cdc_tig; --s_axi_lite_wdata;

    --*************************************************************************
    --** Write Response Support
    --*************************************************************************

    -- Minimum of 2 IP clocks for addr and data capture, therefore delaying
    -- Lite clock addr and data capture by 2 Lite clocks will guarenttee bvalid
    -- responce occurs after write data acutally written.
--    REG_ALIGN_CAP : process(s_axi_lite_aclk)
--        begin
--            if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
--                if(s_axi_lite_aresetn = '0')then
--                    lite_data_cap_d1 <= '0';
--                    lite_data_cap_d2 <= '0';

--                    lite_addr_cap_d1 <= '0';
--                    lite_addr_cap_d2 <= '0';
--                else
--                    lite_data_cap_d1 <= rdy; --wr_data_cap;
--                    lite_data_cap_d2 <= lite_data_cap_d1;

--                    lite_addr_cap_d1 <= rdy; --wr_addr_cap;
--                    lite_addr_cap_d2 <= lite_addr_cap_d1;
--                end if;
--            end if;
--        end process REG_ALIGN_CAP;

    -- Pseudo write enable used simply to assert bvalid
  --  lite_axi2ip_wren <= rdy; --'1' when wr_data_cap = '1' and wr_addr_cap = '1'
              --  else '0';

    WRESP_PROCESS : process(s_axi_lite_aclk)
        begin
            if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
                if(s_axi_lite_aresetn = '0')then
                    bvalid_i        <= '0';
                    rst_wvalid_re   <= '0';     -- CR576999
                -- If response issued and target indicates ready then
                -- clear response
                elsif(bvalid_i = '1' and s_axi_lite_bready = '1')then
                    bvalid_i        <= '0';
                    rst_wvalid_re   <= '0';     -- CR576999
                -- Issue a resonse on write
                elsif(rdy_out = '1')then
            --    elsif(lite_axi2ip_wren = '1')then
                    bvalid_i        <= '1';
                    rst_wvalid_re   <= '1';     -- CR576999
                end if;
            end if;
        end process WRESP_PROCESS;

    s_axi_lite_bresp    <= OKAY_RESP;


end generate GEN_ASYNC_WRITE;





--*****************************************************************************
--** AXI LITE READ
--*****************************************************************************

-------------------------------------------------------------------------------
-- Assert Read Adddress Ready Handshake
-- Capture rising edge of valid and register out as ready.  This creates
-- a 3 clock cycle address phase but also registers all inputs and outputs.
-- Note : Single clock cycle address phase can be accomplished using
-- combinatorial logic.
-------------------------------------------------------------------------------
REG_ARVALID : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0' or rst_rvalid_re = '1')then
                arvalid_d1 <= '0';
            else
                arvalid_d1 <= arvalid;
            end if;
        end if;
    end process REG_ARVALID;

arvalid_re  <= arvalid and not arvalid_d1
                and not rst_rvalid_re and not read_in_progress; -- CR607165

-- register for proper alignment
REG_ARREADY : process(s_axi_lite_aclk)
    begin
        if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
            if(s_axi_lite_aresetn = '0')then
                arready_i <= '0';
            else
                arready_i <= arvalid_re;
            end if;
        end if;
    end process REG_ARREADY;

-- Always respond 'okay' axi lite read
s_axi_lite_rresp    <= OKAY_RESP;
s_axi_lite_rvalid   <= s_axi_lite_rvalid_i;


-- s_axi_lite_aclk is synchronous to ip clock
GEN_SYNC_READ : if C_AXI_LITE_IS_ASYNC = 0 generate
begin

    read_in_progress <= '0'; --Not used for sync mode (CR607165)

    -------------------------------------------------------------------------------
    -- Capture Read Address
    -------------------------------------------------------------------------------
    REG_READ_ADDRESS : process(s_axi_lite_aclk)
        begin
            if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
                if(s_axi_lite_aresetn = '0')then
                    axi2ip_rdaddr_i   <= (others => '0');

                -- Register address on valid
                elsif(arvalid_re = '1')then
                    axi2ip_rdaddr_i   <= araddr;

                end if;
            end if;
        end process REG_READ_ADDRESS;



    -------------------------------------------------------------------------------
    -- Generate RdCE based on address match to address bar
    -------------------------------------------------------------------------------
    RDCE_GEN: for j in 0 to C_NUM_CE - 1 generate

    constant BAR    : std_logic_vector(CE_ADDR_SIZE-1 downto 0) :=
                    std_logic_vector(to_unsigned(j,CE_ADDR_SIZE));
    begin

      rdce(j) <= arvalid_re_d1
        when axi2ip_rdaddr_i((CE_ADDR_SIZE + ADDR_OFFSET) - 1
                              downto ADDR_OFFSET)
             = BAR(CE_ADDR_SIZE-1 downto 0)
        else '0';

    end generate RDCE_GEN;

    -------------------------------------------------------------------------------
    -- Register out to IP
    -------------------------------------------------------------------------------
    REG_RDCNTRL_OUT : process(s_axi_lite_aclk)
        begin
            if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
                if(s_axi_lite_aresetn = '0')then
                    --axi2ip_rdce     <= (others => '0');
                    axi2ip_rdaddr   <= (others => '0');
                else
                    --axi2ip_rdce     <= rdce;
                    axi2ip_rdaddr   <= axi2ip_rdaddr_i;
                end if;
            end if;
        end process REG_RDCNTRL_OUT;


    -- Sample and hold rdce value until rvalid assertion
    REG_RDCE_OUT : process(s_axi_lite_aclk)
        begin
            if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
                if(s_axi_lite_aresetn = '0' or rst_rvalid_re = '1')then
                    axi2ip_rdce     <= (others => '0');
                elsif(arvalid_re_d1 = '1')then
                    axi2ip_rdce     <= rdce;
                end if;
            end if;
        end process REG_RDCE_OUT;

    -- Register for proper alignment
    REG_RVALID : process(s_axi_lite_aclk)
        begin
            if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
                if(s_axi_lite_aresetn = '0')then
                    arvalid_re_d1   <= '0';
                    rvalid          <= '0';
                    rvalid1          <= '0';
                else
                    arvalid_re_d1   <= arvalid_re;
                    rvalid          <= arvalid_re_d1;
                    rvalid1         <= rvalid;
                end if;
            end if;
        end process REG_RVALID;

    -------------------------------------------------------------------------------
    -- Drive read data and read data valid out on capture of valid address.
    -------------------------------------------------------------------------------
    REG_RD_OUT : process(s_axi_lite_aclk)
        begin
            if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
                if(s_axi_lite_aresetn = '0')then
                    s_axi_lite_rdata    <= (others => '0');
                    s_axi_lite_rvalid_i <= '0';
                    rst_rvalid_re       <= '0';                 -- CR576999

                -- If rvalid driving out to target and target indicates ready
                -- then de-assert rvalid. (structure guarentees min 1 clock of rvalid)
                elsif(s_axi_lite_rvalid_i = '1' and s_axi_lite_rready = '1')then
                    s_axi_lite_rdata    <= (others => '0');
                    s_axi_lite_rvalid_i <= '0';
                    rst_rvalid_re       <= '0';                 -- CR576999

                -- If read cycle then assert rvalid and rdata out to target
                elsif(rvalid1 = '1')then
                    s_axi_lite_rdata    <= ip2axi_rddata;
                    s_axi_lite_rvalid_i <= '1';
                    rst_rvalid_re       <= '1';                 -- CR576999

                end if;
            end if;
        end process REG_RD_OUT;


end generate GEN_SYNC_READ;



-- s_axi_lite_aclk is asynchronous to ip clock
GEN_ASYNC_READ : if C_AXI_LITE_IS_ASYNC = 1 generate

  ATTRIBUTE async_reg                      : STRING;

signal ip_arvalid_d1_cdc_tig        : std_logic := '0';
signal ip_arvalid_d2        : std_logic := '0';
signal ip_arvalid_d3        : std_logic := '0';
signal ip_arvalid_re        : std_logic := '0';

signal araddr_d1_cdc_tig            : std_logic_vector(C_S_AXI_LITE_ADDR_WIDTH-1 downto 0) :=(others => '0');
signal araddr_d2            : std_logic_vector(C_S_AXI_LITE_ADDR_WIDTH-1 downto 0) :=(others => '0');
signal araddr_d3            : std_logic_vector(C_S_AXI_LITE_ADDR_WIDTH-1 downto 0) :=(others => '0');

signal lite_rdata_cdc_from           : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) :=(others => '0');
signal lite_rdata_d1_cdc_to        : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) :=(others => '0');
signal lite_rdata_d2        : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) :=(others => '0');

  --ATTRIBUTE async_reg OF ip_arvalid_d1_cdc_tig  : SIGNAL IS "true";
  --ATTRIBUTE async_reg OF ip_arvalid_d2  : SIGNAL IS "true";

  --ATTRIBUTE async_reg OF araddr_d1_cdc_tig  : SIGNAL IS "true";
  --ATTRIBUTE async_reg OF araddr_d2  : SIGNAL IS "true";

  --ATTRIBUTE async_reg OF lite_rdata_d1_cdc_to : SIGNAL IS "true";
  --ATTRIBUTE async_reg OF lite_rdata_d2  : SIGNAL IS "true";

signal p_pulse_s_h          : std_logic := '0';
signal p_pulse_s_h_clr      : std_logic := '0';
signal s_pulse_d1           : std_logic := '0';
signal s_pulse_d2           : std_logic := '0';
signal s_pulse_d3           : std_logic := '0';
signal s_pulse_re           : std_logic := '0';

signal p_pulse_re_d1        : std_logic := '0';
signal p_pulse_re_d2        : std_logic := '0';
signal p_pulse_re_d3        : std_logic := '0';

signal arready_d1           : std_logic := '0'; -- CR605883
signal arready_d2           : std_logic := '0'; -- CR605883
signal arready_d3           : std_logic := '0'; -- CR605883
signal arready_d4           : std_logic := '0'; -- CR605883
signal arready_d5           : std_logic := '0'; -- CR605883
signal arready_d6           : std_logic := '0'; -- CR605883
signal arready_d7           : std_logic := '0'; -- CR605883
signal arready_d8           : std_logic := '0'; -- CR605883
signal arready_d9           : std_logic := '0'; -- CR605883
signal arready_d10           : std_logic := '0'; -- CR605883
signal arready_d11           : std_logic := '0'; -- CR605883
signal arready_d12           : std_logic := '0'; -- CR605883

begin

    -- CR607165
    -- Flag to prevent overlapping reads
    RD_PROGRESS : process(s_axi_lite_aclk)
        begin
            if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
                if(s_axi_lite_aresetn = '0' or rst_rvalid_re = '1')then
                    read_in_progress <= '0';

                elsif(arvalid_re = '1')then
                    read_in_progress <= '1';
                end if;
            end if;
        end process RD_PROGRESS;


    -- Double register address in
REG_RADDR_TO_IPCLK : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 0,
        C_VECTOR_WIDTH             => C_S_AXI_LITE_ADDR_WIDTH,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axi_lite_aclk,
        prmry_resetn               => '0',
        prmry_in                   => '0',
        prmry_vect_in              => s_axi_lite_araddr,
        
        scndry_aclk                => ip2axi_aclk,
        scndry_resetn              => '0',
        scndry_out                 => open,
        scndry_vect_out            => araddr_d3
    );


--    REG_RADDR_TO_IPCLK : process(ip2axi_aclk)
--        begin
--            if(ip2axi_aclk'EVENT and ip2axi_aclk = '1')then
--                if(ip2axi_aresetn = '0')then
--                    araddr_d1_cdc_tig           <= (others => '0');
--                    araddr_d2           <= (others => '0');
--                    araddr_d3           <= (others => '0');
--                else
--                    araddr_d1_cdc_tig   <= s_axi_lite_araddr;
--                    araddr_d2           <= araddr_d1_cdc_tig;
--                    araddr_d3           <= araddr_d2;
--                end if;
--            end if;
--        end process REG_RADDR_TO_IPCLK;

    -- Latch and hold read address
    REG_ARADDR_PROCESS : process(ip2axi_aclk)
        begin
            if(ip2axi_aclk'EVENT and ip2axi_aclk = '1')then
                if(ip2axi_aresetn = '0')then
                    axi2ip_rdaddr_i <= (others => '0');
                elsif(ip_arvalid_re = '1')then
                    axi2ip_rdaddr_i <= araddr_d3;
                end if;
            end if;
        end process REG_ARADDR_PROCESS;

    axi2ip_rdaddr   <= axi2ip_rdaddr_i;

    -- Register awready into IP clock domain.  awready
    -- is a 1 axi_lite clock delay of the rising edge of
    -- arvalid.  This provides a signal that asserts when
    -- araddr is known to be stable.

REG_ARVALID_TO_IPCLK : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => C_S_AXI_LITE_ADDR_WIDTH,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => s_axi_lite_aclk,
        prmry_resetn               => '0',
        prmry_in                   => arready_i,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => ip2axi_aclk,
        scndry_resetn              => '0',
        scndry_out                 => ip_arvalid_d2,
        scndry_vect_out            => open
    );



    REG_ARVALID_TO_IPCLK1 : process(ip2axi_aclk)
        begin
            if(ip2axi_aclk'EVENT and ip2axi_aclk = '1')then
                if(ip2axi_aresetn = '0')then
--                    ip_arvalid_d1_cdc_tig <= '0';
--                    ip_arvalid_d2 <= '0';
                    ip_arvalid_d3 <= '0';
                else
--                    ip_arvalid_d1_cdc_tig <= arready_i;
--                    ip_arvalid_d2 <= ip_arvalid_d1_cdc_tig;
                    ip_arvalid_d3 <= ip_arvalid_d2;
                end if;
            end if;
        end process REG_ARVALID_TO_IPCLK1;

    ip_arvalid_re <= ip_arvalid_d2 and not ip_arvalid_d3;

    -------------------------------------------------------------------------------
    -- Generate Read CE's
    -------------------------------------------------------------------------------
    RDCE_GEN: for j in 0 to C_NUM_CE - 1 generate

    constant BAR    : std_logic_vector(CE_ADDR_SIZE-1 downto 0) :=
                    std_logic_vector(to_unsigned(j,CE_ADDR_SIZE));
    begin

      rdce(j) <= ip_arvalid_re
        when araddr_d3((CE_ADDR_SIZE + ADDR_OFFSET) - 1
                              downto ADDR_OFFSET)
             = BAR(CE_ADDR_SIZE-1 downto 0)
        else '0';

    end generate RDCE_GEN;

    -------------------------------------------------------------------------------
    -- Register RDCE and RD Data out to IP
    -------------------------------------------------------------------------------
    REG_RDCNTRL_OUT : process(ip2axi_aclk)
        begin
            if(ip2axi_aclk'EVENT and ip2axi_aclk = '1')then
                if(ip2axi_aresetn = '0')then
                    axi2ip_rdce     <= (others => '0');
                elsif(ip_arvalid_re = '1')then
                    axi2ip_rdce     <= rdce;
                else
                    axi2ip_rdce     <= (others => '0');
                end if;
            end if;
        end process REG_RDCNTRL_OUT;

    -- Generate sample and hold pulse to capture read data from IP
    REG_RVALID : process(ip2axi_aclk)
        begin
            if(ip2axi_aclk'EVENT and ip2axi_aclk = '1')then
                if(ip2axi_aresetn = '0')then
                    rvalid          <= '0';
                    rvalid1          <= '0';
                else
                    rvalid          <= ip_arvalid_re;
                    rvalid1 <= rvalid;
                end if;
            end if;
        end process REG_RVALID;

    -------------------------------------------------------------------------------
    -- Sample and hold read data from IP
    -------------------------------------------------------------------------------
    S_H_READ_DATA : process(ip2axi_aclk)
        begin
            if(ip2axi_aclk'EVENT and ip2axi_aclk = '1')then
                if(ip2axi_aresetn = '0')then
                    lite_rdata_cdc_from    <= (others => '0');

                -- If read cycle then assert rvalid and rdata out to target
                elsif(rvalid1 = '1')then
                    lite_rdata_cdc_from    <= ip2axi_rddata;

                end if;
            end if;
        end process S_H_READ_DATA;

    -- Cross read data to axi_lite clock domain
REG_DATA2LITE_CLOCK : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 0,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => ip2axi_aclk,
        prmry_resetn               => '0',
        prmry_in                   => '0', --lite_rdata_cdc_from,
        prmry_vect_in              => lite_rdata_cdc_from,

        scndry_aclk                => s_axi_lite_aclk,
        scndry_resetn              => '0',
        scndry_out                 => open, --lite_rdata_d2,
        scndry_vect_out            => lite_rdata_d2
    );

--    REG_DATA2LITE_CLOCK : process(s_axi_lite_aclk)
--        begin
--            if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
--                if(s_axi_lite_aresetn = '0')then
--                    lite_rdata_d1_cdc_to   <= (others => '0');
--                    lite_rdata_d2   <= (others => '0');
--                else
--                    lite_rdata_d1_cdc_to   <= lite_rdata_cdc_from;
--                    lite_rdata_d2   <= lite_rdata_d1_cdc_to;
--                end if;
--            end if;
--        end process REG_DATA2LITE_CLOCK;



    -- CR605883 (CDC) modified to remove
    -- Because axi_lite_aclk must be less than or equal to ip2axi_aclk
    -- then read data will appear a maximum 6 clocks from assertion
    -- of arready.
    REG_ALIGN_RDATA_LATCH : process(s_axi_lite_aclk)
        begin
            if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
                if(s_axi_lite_aresetn = '0')then
                    arready_d1 <= '0';
                    arready_d2 <= '0';
                    arready_d3 <= '0';
                    arready_d4 <= '0';
                    arready_d5 <= '0';
                    arready_d6 <= '0';
                    arready_d7 <= '0';
                    arready_d8 <= '0';
                    arready_d9 <= '0';
                    arready_d10 <= '0';
                    arready_d11 <= '0';
                    arready_d12 <= '0';
                else
                    arready_d1 <= arready_i;
                    arready_d2 <= arready_d1;
                    arready_d3 <= arready_d2;
                    arready_d4 <= arready_d3;
                    arready_d5 <= arready_d4;
                    arready_d6 <= arready_d5;
                    arready_d7 <= arready_d6;
                    arready_d8 <= arready_d7;
                    arready_d9 <= arready_d8;
                    arready_d10 <= arready_d9;
                    arready_d11 <= arready_d10;
                    arready_d12 <= arready_d11;
                end if;
            end if;
        end process REG_ALIGN_RDATA_LATCH;

    -------------------------------------------------------------------------------
    -- Drive read data and read data valid out on capture of valid address.
    -------------------------------------------------------------------------------
    REG_RD_OUT : process(s_axi_lite_aclk)
        begin
            if(s_axi_lite_aclk'EVENT and s_axi_lite_aclk = '1')then
                if(s_axi_lite_aresetn = '0')then
                    s_axi_lite_rdata    <= (others => '0');
                    s_axi_lite_rvalid_i <= '0';
                    rst_rvalid_re       <= '0';                 -- CR576999

                -- If rvalid driving out to target and target indicates ready
                -- then de-assert rvalid. (structure guarentees min 1 clock of rvalid)
                elsif(s_axi_lite_rvalid_i = '1' and s_axi_lite_rready = '1')then
                    s_axi_lite_rdata    <= (others => '0');
                    s_axi_lite_rvalid_i <= '0';
                    rst_rvalid_re       <= '0';                 -- CR576999

                -- If read cycle then assert rvalid and rdata out to target
                -- CR605883
                --elsif(s_pulse_re = '1')then
                elsif(arready_d12 = '1')then
                    s_axi_lite_rdata    <= lite_rdata_d2;
                    s_axi_lite_rvalid_i <= '1';
                    rst_rvalid_re       <= '1';                 -- CR576999

                end if;
            end if;
        end process REG_RD_OUT;


end generate GEN_ASYNC_READ;

end implementation;





-------------------------------------------------------------------------------
-- axi_mcdma_register
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_mcdma_register.vhd
--
-- Description:     This entity encompasses the channel register set.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_mcdma_register is
    generic(
        C_NUM_REGISTERS             : integer                   := 11       ;
        C_INCLUDE_SG                : integer                   := 1        ;
        C_ENABLE_SINGLE_INTR        : integer range 0 to 1      := 0        ;
        C_SG_LENGTH_WIDTH           : integer range 8 to 23     := 14       ;
        C_S_AXI_LITE_DATA_WIDTH     : integer range 32 to 32    := 32       ;
        C_ACTUAL_ADDR_WIDTH         : integer range 32 to 64    := 32       ;
        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 64    := 32       ;
        C_INCLUDE_MM2S              : integer range 0 to 1      := 0
        --C_CHANNEL_IS_S2MM           : integer range 0 to 1      := 0 CR603034
    );
    port (
        m_axi_sg_aclk               : in  std_logic                         ;          --
        m_axi_sg_aresetn            : in  std_logic                         ;          --
                                                                                       --
        -- AXI Interface Control                                                       --
        axi2ip_wrce                 : in  std_logic_vector                             --
                                        (C_NUM_REGISTERS-1 downto 0)        ;          --
        axi2ip_wrdata               : in  std_logic_vector                             --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);          --
                                                                                       --
        -- DMASR Control                                                               --
        stop_dma                    : in  std_logic                         ;          --
        sg_idle                     : in  std_logic                         ;
        ch_service                  : in  std_logic                         ;
        channel_service_run         : in  std_logic                         ;
        dma_run_stop                : in  std_logic                         ;
        dma_halted                  : in  std_logic                         ;
        halted_clr                  : in  std_logic                         ;          --
        halted_set                  : in  std_logic                         ;          --
        idle_set                    : in  std_logic                         ;          --
        idle_clr                    : in  std_logic                         ;          --
        ioc_irq_set                 : in  std_logic                         ;          --
        pktdrp_irq_set              : in  std_logic                         ;          --
        dly_irq_set                 : in  std_logic                         ;          --
        irqdelay_status             : in  std_logic_vector(7 downto 0)      ;          --
        irqthresh_status            : in  std_logic_vector(7 downto 0)      ;          --
        pktirqthresh_status         : in  std_logic_vector(7 downto 0)      ;          --
        irqthresh_wren              : out std_logic                         ;          --
        pktdrp_irqthresh_wren       : out std_logic                         ;          --
        irqdelay_wren               : out std_logic                         ;          --
        dlyirq_dsble                : out std_logic                         ;          -- CR605888
                                                                                       --
        -- Error Control                                                               --
        dma_interr_set              : in  std_logic                         ;          --
        dma_slverr_set              : in  std_logic                         ;          --
        dma_decerr_set              : in  std_logic                         ;          --
        ftch_interr_set             : in  std_logic                         ;          --
        ftch_slverr_set             : in  std_logic                         ;          --
        ftch_decerr_set             : in  std_logic                         ;          --
        ftch_error_addr             : in  std_logic_vector                             --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;          --
        updt_interr_set             : in  std_logic                         ;          --
        updt_slverr_set             : in  std_logic                         ;          --
        updt_decerr_set             : in  std_logic                         ;          --
        updt_error_addr             : in  std_logic_vector                             --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;          --
        error_in                    : in  std_logic                         ;          --
        error_in_other                    : in  std_logic                         ;          --
        error_out                   : out std_logic                         ;          --
        introut                     : out std_logic                         ;          --
        introut_to_cmn                 : out std_logic                         ;          --
        soft_reset_in               : in  std_logic                         ;          --
        soft_reset_clr              : in  std_logic                         ;          --
                                                                                       --
        -- CURDESC Update                                                              --
        update_curdesc              : in  std_logic                         ;          --
        new_curdesc                 : in  std_logic_vector                             --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;          --
        -- TAILDESC Update                                                             --
        tailpntr_updated            : out std_logic                         ;          --
                                                                                       --
        -- Channel Register Out                                                        --
        dmacr                       : out std_logic_vector                             --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);       --
        dmasr                       : out std_logic_vector                             --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);       --
        curdesc_lsb                 : out std_logic_vector                             --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);       --
        curdesc_msb                 : out std_logic_vector                             --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);       --
        taildesc_lsb                : out std_logic_vector                             --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);       --
        taildesc_lsb_rd                : out std_logic_vector                             --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);       --
        taildesc_msb                : out std_logic_vector                             --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)       --
    );                                                                                 --
end axi_mcdma_register;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_register is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";


-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
constant DMACR_INDEX            : integer := 0;                     -- DMACR Register index
constant DMASR_INDEX            : integer := 1;                     -- DMASR Register index
constant CURDESC_LSB_INDEX      : integer := 2;                     -- CURDESC LSB Reg index
constant CURDESC_MSB_INDEX      : integer := 3;                     -- CURDESC MSB Reg index
constant TAILDESC_LSB_INDEX     : integer := 4;                     -- TAILDESC LSB Reg index
constant TAILDESC_MSB_INDEX     : integer := 5;                     -- TAILDESC MSB Reg index
-- CR603034 moved s2mm back to offset 6
--constant SA_ADDRESS_INDEX       : integer := 6;                     -- Buffer Address Reg (SA)
--constant DA_ADDRESS_INDEX       : integer := 8;                     -- Buffer Address Reg (DA)
--
--
--constant BUFF_ADDRESS_INDEX     : integer := address_index_select   -- Buffer Address Reg (SA or DA)
--                                                    (C_CHANNEL_IS_S2MM, -- Channel Type 1=rx 0=tx
--                                                     SA_ADDRESS_INDEX,  -- Source Address Index
--                                                     DA_ADDRESS_INDEX); -- Destination Address Index
constant BUFF_ADDRESS_INDEX     : integer := 6;
constant BUFF_LENGTH_INDEX      : integer := 10;                    -- Buffer Length Reg

constant ZERO_VALUE             : std_logic_vector(31 downto 0) := (others => '0');

constant DMA_CONFIG             : std_logic_vector(0 downto 0)
                                    := std_logic_vector(to_unsigned(C_INCLUDE_SG,1));

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal dmacr_i              : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal dmasr_i              : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal curdesc_lsb_i        : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal curdesc_msb_i        : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal taildesc_lsb_i       : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal taildesc_lsb_i2       : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal taildesc_lsb_i3       : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal taildesc_msb_i       : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal buffer_address_i     : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal buffer_length_i      : std_logic_vector
                                (C_SG_LENGTH_WIDTH-1 downto 0)       := (others => '0');

signal taildesc_msb_i2       : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal curdesc_msb_i2        : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');



-- DMASR Signals
signal halted               : std_logic := '0';
signal idle                 : std_logic := '0';
signal cmplt                : std_logic := '0';
signal error                : std_logic := '0';
signal error_other                : std_logic := '0';
signal dma_interr           : std_logic := '0';
signal dma_slverr           : std_logic := '0';
signal dma_decerr           : std_logic := '0';
signal sg_interr            : std_logic := '0';
signal sg_slverr            : std_logic := '0';
signal sg_decerr            : std_logic := '0';
signal ioc_irq              : std_logic := '0';
signal dly_irq              : std_logic := '0';
signal error_d1             : std_logic := '0';
signal error_d1_other             : std_logic := '0';
signal error_re             : std_logic := '0';
signal error_re_other             : std_logic := '0';
signal err_irq              : std_logic := '0';
signal err_irq_other        : std_logic := '0';
signal pktdrp_irq           : std_logic := '0';

signal sg_ftch_error        : std_logic := '0';
signal sg_updt_error        : std_logic := '0';
signal error_pointer_set    : std_logic := '0';

-- interrupt coalescing support signals
signal different_delay      : std_logic := '0';
signal different_thresh     : std_logic := '0';
signal threshold_is_zero    : std_logic := '0';
signal pktdrp_threshold_is_zero : std_logic := '0';
signal pktdrp_different_thresh : std_logic := '0';

-- soft reset support signals
signal soft_reset_i         : std_logic := '0';
signal run_stop_clr         : std_logic := '0';
signal bd_under_run         : std_logic := '0';
signal introut_int              : std_logic := '0';

signal tailpntr_updated_d2  : std_logic := '0';
signal tailpntr_updated_d1  : std_logic := '0';
-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

soft_reset_i 		<= '0';
dmacr                   <= dmacr_i          ;
dmasr                   <= dmasr_i          ;
curdesc_lsb             <= curdesc_lsb_i    ;
curdesc_msb             <= curdesc_msb_i    ;
taildesc_lsb            <= taildesc_lsb_i   ;
taildesc_lsb_rd         <= taildesc_lsb_i2   ;
taildesc_msb            <= taildesc_msb_i   ;

---------------------------------------------------------------------------
-- DMA Control Register
---------------------------------------------------------------------------
-- DMACR - Interrupt Delay Value
-------------------------------------------------------------------------------
DMACR_DELAY : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dmacr_i(CHDMACR_IRQDELAY_MSB_BIT
                 downto CHDMACR_IRQDELAY_LSB_BIT) <= (others => '0');
            elsif((axi2ip_wrce(DMACR_INDEX) = '1') and (C_ENABLE_SINGLE_INTR = 0))then
                dmacr_i(CHDMACR_IRQDELAY_MSB_BIT
                 downto CHDMACR_IRQDELAY_LSB_BIT) <= axi2ip_wrdata(CHDMACR_IRQDELAY_MSB_BIT
                                                          downto CHDMACR_IRQDELAY_LSB_BIT);
            end if;
        end if;
    end process DMACR_DELAY;

-- If written delay is different than previous value then assert write enable
different_delay <= '1' when dmacr_i(CHDMACR_IRQDELAY_MSB_BIT downto CHDMACR_IRQDELAY_LSB_BIT)
                   /= axi2ip_wrdata(CHDMACR_IRQDELAY_MSB_BIT downto CHDMACR_IRQDELAY_LSB_BIT)
              else '0';

-- delay value different, drive write of delay value to interrupt controller
NEW_DELAY_WRITE : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                irqdelay_wren <= '0';
            -- If AXI Lite write to DMACR and delay different than current
            -- setting then update delay value
            elsif(axi2ip_wrce(DMACR_INDEX) = '1' and different_delay = '1' and C_ENABLE_SINGLE_INTR = 0)then
                irqdelay_wren <= '1';
            else
                irqdelay_wren <= '0';
            end if;
        end if;
    end process NEW_DELAY_WRITE;

-------------------------------------------------------------------------------
-- DMACR - Interrupt Threshold Value
-------------------------------------------------------------------------------
threshold_is_zero <= '1' when axi2ip_wrdata(CHDMACR_IRQTHRESH_MSB_BIT
                                     downto CHDMACR_IRQTHRESH_LSB_BIT) = ZERO_THRESHOLD
                else '0';

DMACR_THRESH : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dmacr_i(CHDMACR_IRQTHRESH_MSB_BIT
                        downto CHDMACR_IRQTHRESH_LSB_BIT) <= ONE_THRESHOLD;
            -- On AXI Lite write
            elsif(axi2ip_wrce(DMACR_INDEX) = '1' and C_ENABLE_SINGLE_INTR = 0)then

                -- If value is 0 then set threshold to 1
                if(threshold_is_zero='1')then
                    dmacr_i(CHDMACR_IRQTHRESH_MSB_BIT
                     downto CHDMACR_IRQTHRESH_LSB_BIT)    <= ONE_THRESHOLD;

                -- else set threshold to axi lite wrdata value
                else
                    dmacr_i(CHDMACR_IRQTHRESH_MSB_BIT
                     downto CHDMACR_IRQTHRESH_LSB_BIT)    <= axi2ip_wrdata(CHDMACR_IRQTHRESH_MSB_BIT
                                                                  downto CHDMACR_IRQTHRESH_LSB_BIT);
                end if;
            end if;
        end if;
    end process DMACR_THRESH;

-- If written threshold is different than previous value then assert write enable
different_thresh <= '1' when dmacr_i(CHDMACR_IRQTHRESH_MSB_BIT downto CHDMACR_IRQTHRESH_LSB_BIT)
                    /= axi2ip_wrdata(CHDMACR_IRQTHRESH_MSB_BIT downto CHDMACR_IRQTHRESH_LSB_BIT)
              else '0';

-- new treshold written therefore drive write of threshold out
NEW_THRESH_WRITE : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                irqthresh_wren <= '0';
            -- If AXI Lite write to DMACR and threshold different than current
            -- setting then update threshold value
            elsif(axi2ip_wrce(DMACR_INDEX) = '1' and different_thresh = '1' and C_ENABLE_SINGLE_INTR = 0)then
                irqthresh_wren <= '1';
            else
                irqthresh_wren <= '0';
            end if;
        end if;
    end process NEW_THRESH_WRITE;

PACKET_DROP_REGISTER : if C_INCLUDE_MM2S = 0 generate
begin
-------------------------------------------------------------------------------
-- DMACR - Packet Drop Interrupt Threshold Value
-------------------------------------------------------------------------------
pktdrp_threshold_is_zero <= '1' when axi2ip_wrdata(CHDMACR_PKTTHRESH_MSB_BIT
                                     downto CHDMACR_PKTTHRESH_LSB_BIT) = ZERO_THRESHOLD
                else '0';

DMACR_PKTTHRESH : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dmacr_i(CHDMACR_PKTTHRESH_MSB_BIT
                        downto CHDMACR_PKTTHRESH_LSB_BIT) <= ONE_THRESHOLD;
            -- On AXI Lite write
            elsif(axi2ip_wrce(DMACR_INDEX) = '1' and C_ENABLE_SINGLE_INTR = 0)then

                -- If value is 0 then set threshold to 1
                if(pktdrp_threshold_is_zero='1')then
                    dmacr_i(CHDMACR_PKTTHRESH_MSB_BIT
                     downto CHDMACR_PKTTHRESH_LSB_BIT)    <= ONE_THRESHOLD;

                -- else set threshold to axi lite wrdata value
                else
                    dmacr_i(CHDMACR_PKTTHRESH_MSB_BIT
                     downto CHDMACR_PKTTHRESH_LSB_BIT)    <= axi2ip_wrdata(CHDMACR_PKTTHRESH_MSB_BIT
                                                                  downto CHDMACR_PKTTHRESH_LSB_BIT);
                end if;
            end if;
        end if;
    end process DMACR_PKTTHRESH;

-- If written threshold is different than previous value then assert write enable
pktdrp_different_thresh <= '1' when dmacr_i(CHDMACR_PKTTHRESH_MSB_BIT downto CHDMACR_PKTTHRESH_LSB_BIT)
                    /= axi2ip_wrdata(CHDMACR_PKTTHRESH_MSB_BIT downto CHDMACR_PKTTHRESH_LSB_BIT)
              else '0';

-- new treshold written therefore drive write of threshold out
NEW_PKTDRPTHRESH_WRITE : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                pktdrp_irqthresh_wren <= '0';
            -- If AXI Lite write to DMACR and threshold different than current
            -- setting then update threshold value
            elsif(axi2ip_wrce(DMACR_INDEX) = '1' and pktdrp_different_thresh = '1' and C_ENABLE_SINGLE_INTR = 0)then
                pktdrp_irqthresh_wren <= '1';
            else
                pktdrp_irqthresh_wren <= '0';
            end if;
        end if;
    end process NEW_PKTDRPTHRESH_WRITE;

end generate PACKET_DROP_REGISTER;


NO_PACKET_DROP_REGISTER : if C_INCLUDE_MM2S = 1 generate
begin

                dmacr_i(CHDMACR_PKTTHRESH_MSB_BIT downto CHDMACR_PKTTHRESH_LSB_BIT) <= (others => '0');
                pktdrp_irqthresh_wren <= '0';

end generate NO_PACKET_DROP_REGISTER;
-------------------------------------------------------------------------------
-- DMACR - Remainder of DMA Control Register
-------------------------------------------------------------------------------
DMACR_REGISTER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dmacr_i(CHDMACR_ERR_IRQEN_BIT
                        downto CHDMACR_RESERVED1_BIT)   <= (others => '0');

            elsif(axi2ip_wrce(DMACR_INDEX) = '1' and C_ENABLE_SINGLE_INTR = 0)then
                dmacr_i(CHDMACR_ERR_IRQEN_BIT              
                        downto CHDMACR_RESERVED1_BIT)   <=  -- bit 7
                                                        axi2ip_wrdata(CHDMACR_ERR_IRQEN_BIT)
                                                        -- bit 6
                                                        & axi2ip_wrdata(CHDMACR_DLY_IRQEN_BIT)
                                                        -- bit 5
                                                        & axi2ip_wrdata(CHDMACR_IOC_IRQEN_BIT)
                                                        -- bit 4
                                                        & axi2ip_wrdata(CHDMACR_PKT_IRQEN_BIT)
                                                        -- bits 3 
                                                        & axi2ip_wrdata(CHDMACR_ERR_OTHER_IRQEN_BIT)
                                                        & ZERO_VALUE(CHDMACR_RESERVED2_BIT downto CHDMACR_RESERVED1_BIT);
            end if;
        end if;
    end process DMACR_REGISTER;

-------------------------------------------------------------------------------
-- DMACR - Reset Bit
-- this moves to common register
-------------------------------------------------------------------------------
--DMACR_RESET : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(soft_reset_clr = '1')then
--                dmacr_i(DMACR_RESET_BIT)  <= '0';
--            -- If soft reset set in other channel then set
--            -- reset bit here too
--            elsif(soft_reset_in = '1')then
--                dmacr_i(DMACR_RESET_BIT)  <= '1';
--
--           -- If DMACR Write then pass axi lite write bus to DMARC reset bit
--            elsif(soft_reset_i = '0' and axi2ip_wrce(DMACR_INDEX) = '1')then
--                dmacr_i(DMACR_RESET_BIT)  <= axi2ip_wrdata(DMACR_RESET_BIT);
--
--            end if;
--        end if;
--    end process DMACR_RESET;

--soft_reset_i <= dmacr_i(DMACR_RESET_BIT);

-------------------------------------------------------------------------------
-- Tail Pointer Enable fixed at 1 for this release of axi dma
-------------------------------------------------------------------------------
--dmacr_i(DMACR_TAILPEN_BIT) <= '1';

-------------------------------------------------------------------------------
-- DMACR - Run/Stop Bit
-- A plain vanilla run stop; actual run stop moves to common register
-------------------------------------------------------------------------------
--run_stop_clr <= '1' when error = '1'                -- MM2S DataMover Error
--                      or error_in = '1'             -- S2MM Error
--                      or stop_dma = '1'             -- Stop due to error
--                      or soft_reset_i = '1'         -- MM2S Soft Reset
--                      or soft_reset_in  = '1'       -- S2MM Soft Reset
--           else '0';


DMACR_RUNSTOP : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dmacr_i(CHDMACR_START_STOP_BIT)  <= '0';
--            -- Clear on sg error (i.e. error) or other channel
--            -- error (i.e. error_in) or dma error or soft reset
--            elsif(run_stop_clr = '1')then
--                dmacr_i(DMACR_RS_BIT)  <= '0';
            elsif(axi2ip_wrce(DMACR_INDEX) = '1')then
                dmacr_i(CHDMACR_START_STOP_BIT)  <= axi2ip_wrdata(CHDMACR_START_STOP_BIT);
            end if;
        end if;
    end process DMACR_RUNSTOP;

---------------------------------------------------------------------------
-- DMA Status Halted bit (BIT 0) - Set by dma controller indicating DMA
-- channel is halted.

-- this moves to common register
---------------------------------------------------------------------------
--DMASR_HALTED : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0' or halted_set = '1')then
--                halted <= '1';
--            elsif(halted_clr = '1')then
--                halted <= '0';
--            end if;
--        end if;
--    end process DMASR_HALTED;

---------------------------------------------------------------------------
-- DMA Status Idle bit (BIT 1) - Set by dma controller indicating DMA
-- channel is IDLE waiting at tail pointer.  Update of Tail Pointer
-- will cause engine to resume.  Note: Halted channels return to a
-- reset condition.
-- this will now show only SG idle for a channel
---------------------------------------------------------------------------
DMASR_IDLE : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0') then
                idle   <= '0';
            else
                idle   <= sg_idle;
            end if;
        end if;
    end process DMASR_IDLE;

---------------------------------------------------------------------------
-- DMA Status Error bit (BIT 3)
-- Note: any error will cause entire engine to halt
---------------------------------------------------------------------------
error  <= dma_interr
            or dma_slverr
            or dma_decerr
            or sg_interr
            or sg_slverr
            or sg_decerr;
---- Map out to halt opposing channel
error_out   <= error;

-- Scatter Gather Error
--sg_ftch_error <= ftch_interr_set or ftch_slverr_set or ftch_decerr_set;

-- SG Update Errors or DMA errors assert flag on descriptor update
-- Used to latch current descriptor pointer
--sg_updt_error <= updt_interr_set or updt_slverr_set or updt_decerr_set
--              or dma_interr or dma_slverr or dma_decerr;

ERROR_LOG : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
               sg_ftch_error <= '0';
               sg_updt_error <= '0';
            else
               sg_ftch_error <= ftch_interr_set or ftch_slverr_set or ftch_decerr_set;
               sg_updt_error <= updt_interr_set or updt_slverr_set or updt_decerr_set
                                or dma_interr or dma_slverr or dma_decerr;
            end if;
        end if;
    end process ERROR_LOG;


---------------------------------------------------------------------------
-- DMA Status DMA Internal Error bit (BIT 4)
---------------------------------------------------------------------------
DMASR_DMAINTERR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dma_interr <= '0';
            elsif(dma_interr_set = '1' )then
                dma_interr <= '1';
            end if;
        end if;
    end process DMASR_DMAINTERR;

---------------------------------------------------------------------------
-- DMA Status DMA Slave Error bit (BIT 5)
---------------------------------------------------------------------------
DMASR_DMASLVERR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dma_slverr <= '0';

            elsif(dma_slverr_set = '1' )then
                dma_slverr <= '1';

            end if;
        end if;
    end process DMASR_DMASLVERR;

---------------------------------------------------------------------------
-- DMA Status DMA Decode Error bit (BIT 6)
---------------------------------------------------------------------------
DMASR_DMADECERR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dma_decerr <= '0';

            elsif(dma_decerr_set = '1' )then
                dma_decerr <= '1';

            end if;
        end if;
    end process DMASR_DMADECERR;

---------------------------------------------------------------------------
-- DMA Status SG Internal Error bit (BIT 8)
-- (SG Mode only - trimmed at build time if simple mode)
---------------------------------------------------------------------------
DMASR_SGINTERR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                sg_interr <= '0';

            elsif(ftch_interr_set = '1' or updt_interr_set = '1')then
                sg_interr <= '1';


            end if;
        end if;
    end process DMASR_SGINTERR;

---------------------------------------------------------------------------
-- DMA Status SG Slave Error bit (BIT 9)
-- (SG Mode only - trimmed at build time if simple mode)
---------------------------------------------------------------------------
DMASR_SGSLVERR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                sg_slverr <= '0';

            elsif(ftch_slverr_set = '1' or updt_slverr_set = '1')then
                sg_slverr <= '1';

            end if;
        end if;
    end process DMASR_SGSLVERR;

---------------------------------------------------------------------------
-- DMA Status SG Decode Error bit (BIT 10)
-- (SG Mode only - trimmed at build time if simple mode)
-------------------------------------------------------------------------
DMASR_SGDECERR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                sg_decerr <= '0';

            elsif(ftch_decerr_set = '1' or updt_decerr_set = '1')then
                sg_decerr <= '1';

            end if;
        end if;
    end process DMASR_SGDECERR;

---------------------------------------------------------------------------
-- DMA Status IOC Interrupt status bit (BIT 11)
---------------------------------------------------------------------------
DMASR_IOCIRQ : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                ioc_irq <= '0';

            -- CPU Writing a '1' to clear - OR'ed with setting to prevent
            -- missing a 'set' during the write.
            elsif(axi2ip_wrce(DMASR_INDEX) = '1' and C_ENABLE_SINGLE_INTR = 0)then

                ioc_irq <= (ioc_irq and not(axi2ip_wrdata(CHDMASR_IOCIRQ_BIT)))
                             or ioc_irq_set;

            elsif(ioc_irq_set = '1' and C_ENABLE_SINGLE_INTR = 0)then
                ioc_irq <= '1';

            end if;
        end if;
    end process DMASR_IOCIRQ;

---------------------------------------------------------------------------
-- DMA Status Delay Interrupt status bit (BIT 12)
---------------------------------------------------------------------------
DMASR_DLYIRQ : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dly_irq <= '0';

            -- CPU Writing a '1' to clear - OR'ed with setting to prevent
            -- missing a 'set' during the write.
            elsif(axi2ip_wrce(DMASR_INDEX) = '1' and C_ENABLE_SINGLE_INTR = 0)then

                dly_irq <= (dly_irq and not(axi2ip_wrdata(CHDMASR_DLYIRQ_BIT)))
                             or dly_irq_set;

            elsif(dly_irq_set = '1' and C_ENABLE_SINGLE_INTR = 0)then
                dly_irq <= '1';

            end if;
        end if;
    end process DMASR_DLYIRQ;

-- CR605888 Disable delay timer if halted or on delay irq set
--dlyirq_dsble    <= dmasr_i(DMASR_HALTED_BIT)              -- CR606348

-- kapil : need to get the real RS here
dlyirq_dsble    <= not dma_run_stop                -- CR606348
                    or dmasr_i(CHDMASR_DLYIRQ_BIT);



---------------------------------------------------------------------------
-- DMA Status Error Interrupt status bit (BIT 12)
---------------------------------------------------------------------------
-- Delay error setting for generation of error strobe
GEN_ERROR_RE : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                error_d1 <= '0';
            else
                error_d1 <= error;
            end if;
        end if;
    end process GEN_ERROR_RE;

-- Generate rising edge pulse on error
error_re   <= error and not error_d1;

DMASR_ERRIRQ : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                err_irq <= '0';

            -- CPU Writing a '1' to clear - OR'ed with setting to prevent
            -- missing a 'set' during the write.
            elsif(axi2ip_wrce(DMASR_INDEX) = '1' and C_ENABLE_SINGLE_INTR = 0)then

                err_irq <= (err_irq and not(axi2ip_wrdata(CHDMASR_ERRIRQ_BIT)))
                             or error_re;

            elsif(error_re = '1' and C_ENABLE_SINGLE_INTR = 0)then
                err_irq <= '1';

            end if;
        end if;
    end process DMASR_ERRIRQ;


GEN_ERROR_RE_OTHER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                error_d1_other <= '0';
            else
                error_d1_other <= error_in_other;
            end if;
        end if;
    end process GEN_ERROR_RE_OTHER;

-- Generate rising edge pulse on error
error_re_other   <= (error_in_other and not error_d1_other) and (not error);

DMASR_ERRIRQ_OTHER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                err_irq_other <= '0';

            -- CPU Writing a '1' to clear - OR'ed with setting to prevent
            -- missing a 'set' during the write.
            elsif(axi2ip_wrce(DMASR_INDEX) = '1' and C_ENABLE_SINGLE_INTR = 0)then

                err_irq_other <= (err_irq_other and not(axi2ip_wrdata(CHDMASR_ERRIRQ_OTHER_BIT)))
                             or error_re_other;

            elsif(error_re_other = '1' and C_ENABLE_SINGLE_INTR = 0)then
                err_irq_other <= '1';

            end if;
        end if;
    end process DMASR_ERRIRQ_OTHER;


---------------------------------------------------------------------------
-- DMA Status IOC Interrupt status bit (BIT 11)
---------------------------------------------------------------------------
DMASR_PKTIRQ : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                pktdrp_irq <= '0';

            -- CPU Writing a '1' to clear - OR'ed with setting to prevent
            -- missing a 'set' during the write.
            elsif(axi2ip_wrce(DMASR_INDEX) = '1' and C_ENABLE_SINGLE_INTR = 0)then

                pktdrp_irq <= (pktdrp_irq and not(axi2ip_wrdata(CHDMASR_PKTIRQ_BIT)))
                             or pktdrp_irq_set;

            elsif(pktdrp_irq_set = '1' and C_ENABLE_SINGLE_INTR = 0)then
                pktdrp_irq <= '1';

            end if;
        end if;
    end process DMASR_PKTIRQ;

---------------------------------------------------------------------------
-- DMA Interrupt OUT
---------------------------------------------------------------------------
REG_INTR_INT : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0' or soft_reset_i = '1')then
                introut_int <= '0';
            else --if (C_ENABLE_SINGLE_INTR = 0) then
                introut_int <=    (dly_irq and dmacr_i(CHDMACR_DLY_IRQEN_BIT))
                               or (ioc_irq and dmacr_i(CHDMACR_IOC_IRQEN_BIT))
                               or (pktdrp_irq and dmacr_i(CHDMACR_PKT_IRQEN_BIT))
                               or (err_irq and dmacr_i(CHDMACR_ERR_IRQEN_BIT))
                               or (err_irq_other and dmacr_i(CHDMACR_ERR_OTHER_IRQEN_BIT));
      --      else
      --          introut_int <= '0';
            end if;
        end if;
    end process;

 introut <= introut_int;

REG_INTR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0' or soft_reset_i = '1')then
                introut_to_cmn <= '0';
            else
                introut_to_cmn <= introut_int;
            end if;
        end if;
    end process;


BD_UNDER_RUN_REG : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0' or soft_reset_i = '1' or error_d1 = '1')then
                bd_under_run <= '0'; 
            else
                bd_under_run <= sg_idle and channel_service_run; 
            end if;
        end if;
    end process;

---------------------------------------------------------------------------
-- DMA Status Register
---------------------------------------------------------------------------
dmasr_i    <=  irqdelay_status         -- Bits 31 downto 24
             & irqthresh_status        -- Bits 23 downto 16
             & pktirqthresh_status     -- Bit  15 downto 8
             & err_irq          -- Bit  7
             & dly_irq          -- Bit  6
             & ioc_irq          -- Bit  5
             & pktdrp_irq              -- Bit  4
             & err_irq_other        -- Bit  3
             & '0'        -- Bit  2
             & bd_under_run        -- Bit  1
             & idle;              -- Bit  0





-- Generate current descriptor and tail descriptor register for Scatter Gather Mode
GEN_DESC_REG_FOR_SG : if C_INCLUDE_SG = 1 generate
begin

    -- Signals not used for Scatter Gather Mode, only simple mode

    ---------------------------------------------------------------------------
    -- Current Descriptor LSB Register
    ---------------------------------------------------------------------------
    CURDESC_LSB_REGISTER : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    curdesc_lsb_i  <= (others => '0');
                    error_pointer_set   <= '0';

                -- Detected error has NOT register a desc pointer
                elsif(error_pointer_set = '0')then

                    -- Scatter Gather Fetch Error
                    if(sg_ftch_error = '1')then
                        curdesc_lsb_i       <= ftch_error_addr(C_S_AXI_LITE_DATA_WIDTH-1 downto 0);
                        error_pointer_set   <= '1';
                    -- Scatter Gather Update Error
                    elsif(sg_updt_error = '1')then
                        curdesc_lsb_i       <= ftch_error_addr(C_S_AXI_LITE_DATA_WIDTH-1 downto 0);
                        error_pointer_set   <= '1';

                    -- Commanded to update descriptor value - used for indicating
                    -- current descriptor begin processed by dma controller
                    elsif(update_curdesc = '1' and dma_run_stop  = '1')then
                        curdesc_lsb_i       <= new_curdesc(C_S_AXI_LITE_DATA_WIDTH-1 downto 0);
                        error_pointer_set   <= '0';

                    -- CPU update of current descriptor pointer.  CPU
                    -- only allowed to update when engine is halted.
                    elsif(axi2ip_wrce(CURDESC_LSB_INDEX) = '1' and dmacr_i(CHDMACR_START_STOP_BIT) = '0') then --dma_halted = '1')then
                        curdesc_lsb_i       <= axi2ip_wrdata(CURDESC_LOWER_MSB_BIT
                                                      downto CURDESC_LOWER_LSB_BIT)
                                              & ZERO_VALUE(CURDESC_RESERVED_BIT5
                                                      downto CURDESC_RESERVED_BIT0);
                        error_pointer_set   <= '0';

                    end if;
                end if;
            end if;
        end process CURDESC_LSB_REGISTER;

    ---------------------------------------------------------------------------
    -- Tail Descriptor LSB Register
    ---------------------------------------------------------------------------
    TAILDESC_LSB_REGISTER : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    taildesc_lsb_i2  <= (others => '0');
                elsif(axi2ip_wrce(TAILDESC_LSB_INDEX) = '1')then
                    taildesc_lsb_i2  <= axi2ip_wrdata(TAILDESC_LOWER_MSB_BIT
                                              downto TAILDESC_LOWER_LSB_BIT)
                                       & ZERO_VALUE(TAILDESC_RESERVED_BIT5
                                              downto TAILDESC_RESERVED_BIT0);

                end if;
            end if;
        end process TAILDESC_LSB_REGISTER;

    ---------------------------------------------------------------------------
    -- Current Descriptor MSB Register
    ---------------------------------------------------------------------------
    -- Scatter Gather Interface configured for 64-Bit SG Addresses
    GEN_SG_ADDR_EQL64 :if C_M_AXI_SG_ADDR_WIDTH = 64 generate
    begin
        CURDESC_MSB_REGISTER : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0')then
                        curdesc_msb_i2  <= (others => '0');

                    elsif(error_pointer_set = '0')then
                        -- Scatter Gather Fetch Error
                        if(sg_ftch_error = '1')then
                            curdesc_msb_i2   <= ftch_error_addr(C_M_AXI_SG_ADDR_WIDTH - 1 downto C_S_AXI_LITE_DATA_WIDTH);

                        -- Scatter Gather Update Error
                        elsif(sg_updt_error = '1')then
                            curdesc_msb_i2   <= ftch_error_addr(C_M_AXI_SG_ADDR_WIDTH - 1 downto C_S_AXI_LITE_DATA_WIDTH);

                        -- Commanded to update descriptor value - used for indicating
                        -- current descriptor begin processed by dma controller
                        elsif(update_curdesc = '1' and dma_run_stop = '1')then
                            curdesc_msb_i2 <= new_curdesc (C_M_AXI_SG_ADDR_WIDTH - 1 downto C_S_AXI_LITE_DATA_WIDTH);

                        -- CPU update of current descriptor pointer.  CPU
                        -- only allowed to update when engine is halted.
                        elsif(axi2ip_wrce(CURDESC_MSB_INDEX) = '1' and dmacr_i(CHDMACR_START_STOP_BIT) = '0') then --dma_halted = '1')then
                            curdesc_msb_i2  <= axi2ip_wrdata;

                        end if;
                    end if;
                end if;
            end process CURDESC_MSB_REGISTER;

        ---------------------------------------------------------------------------
        -- Tail Descriptor MSB Register
        ---------------------------------------------------------------------------
        TAILDESC_MSB_REGISTER : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0')then
                        taildesc_msb_i2  <= (others => '0');
                        taildesc_lsb_i3   <= (others => '0');
                    elsif(axi2ip_wrce(TAILDESC_MSB_INDEX) = '1')then
                        taildesc_msb_i2  <= axi2ip_wrdata;
                        taildesc_lsb_i3 <= taildesc_lsb_i2; 
                    end if;
                end if;
            end process TAILDESC_MSB_REGISTER;

        taildesc_lsb_i <= taildesc_lsb_i3;

        end generate GEN_SG_ADDR_EQL64;

    -- Scatter Gather Interface configured for 32-Bit SG Addresses
    GEN_SG_ADDR_EQL32 : if C_M_AXI_SG_ADDR_WIDTH = 32 generate
    begin
        curdesc_msb_i  <= (others => '0');
        taildesc_msb_i <= (others => '0');
        taildesc_lsb_i <= taildesc_lsb_i2;
    end generate GEN_SG_ADDR_EQL32;


    GEN_SG_ADDR_NEQL32 : if C_M_AXI_SG_ADDR_WIDTH /= 32 generate
    begin
    RESIDUE: if C_ACTUAL_ADDR_WIDTH < C_M_AXI_SG_ADDR_WIDTH generate
    begin

     taildesc_msb_i (32-1 downto C_ACTUAL_ADDR_WIDTH-32) <= (others => '0');
         curdesc_msb_i (32-1 downto C_ACTUAL_ADDR_WIDTH-32) <= (others => '0');


         curdesc_msb_i (C_ACTUAL_ADDR_WIDTH-32-1 downto 0) <= curdesc_msb_i2 (C_ACTUAL_ADDR_WIDTH-32-1 downto 0);
         taildesc_msb_i (C_ACTUAL_ADDR_WIDTH-32-1 downto 0) <= taildesc_msb_i2 (C_ACTUAL_ADDR_WIDTH-32-1 downto 0);

    end generate RESIDUE;

    NO_RESIDUE: if C_ACTUAL_ADDR_WIDTH = C_M_AXI_SG_ADDR_WIDTH generate
    begin

         curdesc_msb_i  <= curdesc_msb_i2;
         taildesc_msb_i <= taildesc_msb_i2;

    end generate NO_RESIDUE;

    end generate GEN_SG_ADDR_NEQL32;



    -- Scatter Gather Interface configured for 32-Bit SG Addresses
    GEN_TAILUPDATE_EQL32 : if C_M_AXI_SG_ADDR_WIDTH = 32 generate
    begin
        TAILPNTR_UPDT_PROCESS : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0') then -- or dma_run_stop='0')then
                        tailpntr_updated_d1    <= '0';
                    elsif(axi2ip_wrce(TAILDESC_LSB_INDEX) = '1')then
                        tailpntr_updated_d1    <= '1';
                    else
                        tailpntr_updated_d1    <= '0';
                    end if;
                end if;
            end process TAILPNTR_UPDT_PROCESS;

       TAILPNTR_UPDT_PROCESS_DEL : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0')then
                        tailpntr_updated_d2    <= '0';
                    else
                        tailpntr_updated_d2    <= tailpntr_updated_d1;
                    end if;
                end if;
            end process TAILPNTR_UPDT_PROCESS_DEL;

          tailpntr_updated <= tailpntr_updated_d1 and (not tailpntr_updated_d2);



    end generate GEN_TAILUPDATE_EQL32;

    -- Scatter Gather Interface configured for 64-Bit SG Addresses
    GEN_TAILUPDATE_EQL64 : if C_M_AXI_SG_ADDR_WIDTH = 64 generate
    begin
        TAILPNTR_UPDT_PROCESS : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0') then -- or dma_run_stop='0')then
                        tailpntr_updated_d1    <= '0';
                    elsif(axi2ip_wrce(TAILDESC_MSB_INDEX) = '1')then
                        tailpntr_updated_d1    <= '1';
                    else
                        tailpntr_updated_d1    <= '0';
                    end if;
                end if;
            end process TAILPNTR_UPDT_PROCESS;

       TAILPNTR_UPDT_PROCESS_DEL : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0')then
                        tailpntr_updated_d2    <= '0';
                    else
                        tailpntr_updated_d2    <= tailpntr_updated_d1;
                    end if;
                end if;
            end process TAILPNTR_UPDT_PROCESS_DEL;

          tailpntr_updated <= tailpntr_updated_d1 and (not tailpntr_updated_d2);


    end generate GEN_TAILUPDATE_EQL64;

end generate GEN_DESC_REG_FOR_SG;





end implementation;



-------------------------------------------------------------------------------
-- axi_mcdma_common_register
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_mcdma_common_register.vhd
--
-- Description:     This entity encompasses the channel register set.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_mcdma_common_register is
    generic(
        C_NUM_REGISTERS             : integer                   := 11       ;
        C_INCLUDE_SG                : integer                   := 1        ;
        C_ENABLE_SINGLE_INTR        : integer range 0 to 1      := 0        ;
        C_MAX_CHANNELS               : integer range 1 to 16     := 1        ;
        C_SG_LENGTH_WIDTH           : integer range 8 to 23     := 14       ;
        C_S_AXI_LITE_DATA_WIDTH     : integer range 32 to 32    := 32       ;
        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 64    := 32       ;
        C_NUM_MM2S_CHANNELS         : integer range 1 to 16     := 1        ;
        C_MM2S_SCHEDULE             : integer range 0 to 3      := 1        ;
        C_INCLUDE_MM2S              : integer range 0 to 1      := 1        ;
        C_INCLUDE_S2MM              : integer range 0 to 1      := 1        ;
        C_GROUP1_MM2S               : std_logic_vector (15 downto 0) := x"FFFF";
        C_GROUP2_MM2S               : std_logic_vector (15 downto 0) := x"0000";
        C_GROUP3_MM2S               : std_logic_vector (15 downto 0) := x"0000";
        C_GROUP4_MM2S               : std_logic_vector (15 downto 0) := x"0000";
        C_GROUP5_MM2S               : std_logic_vector (15 downto 0) := x"0000";
        C_GROUP6_MM2S               : std_logic_vector (15 downto 0) := x"0000";
        C_GROUP1_S2MM               : std_logic_vector (15 downto 0) := x"FFFF";
        C_GROUP2_S2MM               : std_logic_vector (15 downto 0) := x"0000";
        C_GROUP3_S2MM               : std_logic_vector (15 downto 0) := x"0000";
        C_GROUP4_S2MM               : std_logic_vector (15 downto 0) := x"0000";
        C_GROUP5_S2MM               : std_logic_vector (15 downto 0) := x"0000";
        C_GROUP6_S2MM               : std_logic_vector (15 downto 0) := x"0000"
        --C_CHANNEL_IS_MM2S           : integer range 0 to 1      := 0 CR603034
    );
    port (
        m_axi_sg_aclk               : in  std_logic                         ;          --
        m_axi_sg_aresetn            : in  std_logic                         ;          --
                                                                                       --
        -- AXI Interface Control                                                       --
        axi2ip_wrce                 : in  std_logic_vector                             --
                                        (C_NUM_REGISTERS-1 downto 0)        ;          --
        axi2ip_wrdata               : in  std_logic_vector                             --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);          --
        sg_user_cache             : out std_logic_vector
                                         (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);

        mm2s_ch_ser               : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        s2mm_ch_ser               : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);

        mm2s_gr_1_clr             : in std_logic;
        mm2s_gr_2_clr             : in std_logic;
        mm2s_gr_3_clr             : in std_logic;
        mm2s_gr_4_clr             : in std_logic;
        mm2s_gr_5_clr             : in std_logic;
        mm2s_gr_6_clr             : in std_logic;
        mm2s_gr_1                 : out std_logic_vector (31 downto 0);
        mm2s_gr_2                 : out std_logic_vector (31 downto 0);
        mm2s_gr_3                 : out std_logic_vector (31 downto 0);
        mm2s_gr_4                 : out std_logic_vector (31 downto 0);
        mm2s_gr_5                 : out std_logic_vector (31 downto 0);
        mm2s_gr_6                 : out std_logic_vector (31 downto 0);

        s2mm_gr_1_clr             : in std_logic;
        s2mm_gr_2_clr             : in std_logic;
        s2mm_gr_3_clr             : in std_logic;
        s2mm_gr_4_clr             : in std_logic;
        s2mm_gr_5_clr             : in std_logic;
        s2mm_gr_6_clr             : in std_logic;
        s2mm_gr_1                 : out std_logic_vector (31 downto 0);
        s2mm_gr_2                 : out std_logic_vector (31 downto 0);
        s2mm_gr_3                 : out std_logic_vector (31 downto 0);
        s2mm_gr_4                 : out std_logic_vector (31 downto 0);
        s2mm_gr_5                 : out std_logic_vector (31 downto 0);
        s2mm_gr_6                 : out std_logic_vector (31 downto 0)

    );                                                                                 --
end axi_mcdma_common_register;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_common_register is

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
constant CACHE_INDEX            : integer := 0;                     
signal mm2s_gr_1_int                 : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_gr_2_int                 : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_gr_3_int                 : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_gr_4_int                 : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_gr_5_int                 : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_gr_6_int                 : std_logic_vector (C_MAX_CHANNELS-1 downto 0);

signal s2mm_gr_1_int                 : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_gr_2_int                 : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_gr_3_int                 : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_gr_4_int                 : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_gr_5_int                 : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_gr_6_int                 : std_logic_vector (C_MAX_CHANNELS-1 downto 0);

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin



CACHE_REGISTER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
               sg_user_cache (15 downto 0) <= "0000000000000011";
               sg_user_cache (31 downto 16) <= "0000000000000011";
            elsif(axi2ip_wrce(CACHE_INDEX) = '1')then
               sg_user_cache <= axi2ip_wrdata;
            end if;
        end if;
    end process CACHE_REGISTER;

INCLUDE_MM2S : if C_INCLUDE_MM2S = 1 generate
begin

MM2S_GROUP_REGISTER1 : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                mm2s_gr_1_int <= (others => '0');
            elsif  (mm2s_gr_1_clr = '1') then -- ensures it will not miss any values
                mm2s_gr_1_int <= mm2s_ch_ser and C_GROUP1_MM2S;
            else
                mm2s_gr_1_int <= mm2s_gr_1_int or (mm2s_ch_ser and C_GROUP1_MM2S);
            end if;
        end if;
    end process MM2S_GROUP_REGISTER1;
            
MM2S_GROUP_REGISTER2 : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                mm2s_gr_2_int <= (others => '0');
            elsif  (mm2s_gr_2_clr = '1') then -- ensures it will not miss any values
                mm2s_gr_2_int <= mm2s_ch_ser and C_GROUP2_MM2S;
            else
                mm2s_gr_2_int <= mm2s_gr_2_int or (mm2s_ch_ser and C_GROUP2_MM2S);
            end if;
        end if;
    end process MM2S_GROUP_REGISTER2;
            
MM2S_GROUP_REGISTER3 : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                mm2s_gr_3_int <= (others => '0');
            elsif  (mm2s_gr_3_clr = '1') then -- ensures it will not miss any values
                mm2s_gr_3_int <= mm2s_ch_ser and C_GROUP3_MM2S;
            else
                mm2s_gr_3_int <= mm2s_gr_3_int or (mm2s_ch_ser and C_GROUP3_MM2S);
            end if;
        end if;
    end process MM2S_GROUP_REGISTER3;
            
MM2S_GROUP_REGISTER4 : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                mm2s_gr_4_int <= (others => '0');
            elsif  (mm2s_gr_4_clr = '1') then -- ensures it will not miss any values
                mm2s_gr_4_int <= mm2s_ch_ser and C_GROUP4_MM2S;
            else
                mm2s_gr_4_int <= mm2s_gr_4_int or (mm2s_ch_ser and C_GROUP4_MM2S);
            end if;
        end if;
    end process MM2S_GROUP_REGISTER4;
            
MM2S_GROUP_REGISTER5 : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                mm2s_gr_5_int <= (others => '0');
            elsif  (mm2s_gr_5_clr = '1') then -- ensures it will not miss any values
                mm2s_gr_5_int <= mm2s_ch_ser and C_GROUP5_MM2S;
            else
                mm2s_gr_5_int <= mm2s_gr_5_int or (mm2s_ch_ser and C_GROUP5_MM2S);
            end if;
        end if;
    end process MM2S_GROUP_REGISTER5;
            
MM2S_GROUP_REGISTER6 : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                mm2s_gr_6_int<= (others => '0');
            elsif  (mm2s_gr_6_clr = '1') then -- ensures it will not miss any values
                mm2s_gr_6_int <= mm2s_ch_ser and C_GROUP6_MM2S;
            else
                mm2s_gr_6_int <= mm2s_gr_6_int or (mm2s_ch_ser and C_GROUP6_MM2S);
            end if;
        end if;
    end process MM2S_GROUP_REGISTER6;


mm2s_gr_1 (15 downto 0) <= mm2s_gr_1_int;
mm2s_gr_2 (15 downto 0) <= mm2s_gr_2_int;
mm2s_gr_3 (15 downto 0) <= mm2s_gr_3_int;
mm2s_gr_4 (15 downto 0) <= mm2s_gr_4_int;
mm2s_gr_5 (15 downto 0) <= mm2s_gr_5_int;
mm2s_gr_6 (15 downto 0) <= mm2s_gr_6_int;

mm2s_gr_1 (31 downto 16) <= (others => '0');
mm2s_gr_2 (31 downto 16) <= (others => '0');
mm2s_gr_3 (31 downto 16) <= (others => '0');
mm2s_gr_4 (31 downto 16) <= (others => '0');
mm2s_gr_5 (31 downto 16) <= (others => '0');
mm2s_gr_6 (31 downto 16) <= (others => '0');

end generate INCLUDE_MM2S;


NO_INCLUDE_MM2S : if C_INCLUDE_MM2S = 0 generate
begin
mm2s_gr_1 <= (others => '0');
mm2s_gr_2 <= (others => '0');
mm2s_gr_3 <= (others => '0');
mm2s_gr_4 <= (others => '0');
mm2s_gr_5 <= (others => '0');
mm2s_gr_6 <= (others => '0');

end generate NO_INCLUDE_MM2S;

INCLUDE_S2MM : if C_INCLUDE_S2MM = 1 generate
begin

S2MM_GROUP_REGISTER1 : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                s2mm_gr_1_int <= (others => '0');
            elsif  (s2mm_gr_1_clr = '1') then -- ensures it will not miss any values
                s2mm_gr_1_int <= s2mm_ch_ser and C_GROUP1_S2MM;
            else
                s2mm_gr_1_int <= s2mm_gr_1_int or (s2mm_ch_ser and C_GROUP1_S2MM);
            end if;
        end if;
    end process S2MM_GROUP_REGISTER1;
            
S2MM_GROUP_REGISTER2 : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                s2mm_gr_2_int <= (others => '0');
            elsif  (s2mm_gr_2_clr = '1') then -- ensures it will not miss any values
                s2mm_gr_2_int <= s2mm_ch_ser and C_GROUP2_S2MM;
            else
                s2mm_gr_2_int <= s2mm_gr_2_int or (s2mm_ch_ser and C_GROUP2_S2MM);
            end if;
        end if;
    end process S2MM_GROUP_REGISTER2;
            
S2MM_GROUP_REGISTER3 : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                s2mm_gr_3_int <= (others => '0');
            elsif  (s2mm_gr_3_clr = '1') then -- ensures it will not miss any values
                s2mm_gr_3_int <= s2mm_ch_ser and C_GROUP3_S2MM;
            else
                s2mm_gr_3_int <= s2mm_gr_3_int or (s2mm_ch_ser and C_GROUP3_S2MM);
            end if;
        end if;
    end process S2MM_GROUP_REGISTER3;
            
S2MM_GROUP_REGISTER4 : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                s2mm_gr_4_int <= (others => '0');
            elsif  (s2mm_gr_4_clr = '1') then -- ensures it will not miss any values
                s2mm_gr_4_int <= s2mm_ch_ser and C_GROUP4_S2MM;
            else
                s2mm_gr_4_int <= s2mm_gr_4_int or (s2mm_ch_ser and C_GROUP4_S2MM);
            end if;
        end if;
    end process S2MM_GROUP_REGISTER4;
            
S2MM_GROUP_REGISTER5 : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                s2mm_gr_5_int <= (others => '0');
            elsif  (s2mm_gr_5_clr = '1') then -- ensures it will not miss any values
                s2mm_gr_5_int <= s2mm_ch_ser and C_GROUP5_S2MM;
            else
                s2mm_gr_5_int <= s2mm_gr_5_int or (s2mm_ch_ser and C_GROUP5_S2MM);
            end if;
        end if;
    end process S2MM_GROUP_REGISTER5;
            
S2MM_GROUP_REGISTER6 : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                s2mm_gr_6_int <= (others => '0');
            elsif  (s2mm_gr_6_clr = '1') then -- ensures it will not miss any values
                s2mm_gr_6_int <= s2mm_ch_ser and C_GROUP6_S2MM;
            else
                s2mm_gr_6_int <= s2mm_gr_6_int or (s2mm_ch_ser and C_GROUP6_S2MM);
            end if;
        end if;
    end process S2MM_GROUP_REGISTER6;


s2mm_gr_1 (15 downto 0) <= s2mm_gr_1_int;
s2mm_gr_2 (15 downto 0) <= s2mm_gr_2_int;
s2mm_gr_3 (15 downto 0) <= s2mm_gr_3_int;
s2mm_gr_4 (15 downto 0) <= s2mm_gr_4_int;
s2mm_gr_5 (15 downto 0) <= s2mm_gr_5_int;
s2mm_gr_6 (15 downto 0) <= s2mm_gr_6_int;

s2mm_gr_1 (31 downto 16) <= (others => '0');
s2mm_gr_2 (31 downto 16) <= (others => '0');
s2mm_gr_3 (31 downto 16) <= (others => '0');
s2mm_gr_4 (31 downto 16) <= (others => '0');
s2mm_gr_5 (31 downto 16) <= (others => '0');
s2mm_gr_6 (31 downto 16) <= (others => '0');

end generate INCLUDE_S2MM;

NO_INCLUDE_S2MM : if C_INCLUDE_S2MM = 0 generate
begin
s2mm_gr_1 <= (others => '0');
s2mm_gr_2 <= (others => '0');
s2mm_gr_3 <= (others => '0');
s2mm_gr_4 <= (others => '0');
s2mm_gr_5 <= (others => '0');
s2mm_gr_6 <= (others => '0');

end generate NO_INCLUDE_S2MM;


end implementation;



-------------------------------------------------------------------------------
-- axi_mcdma_s2mm_common_register
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_mcdma_s2mm_common_register.vhd
--
-- Description:     This entity encompasses the channel register set.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_mcdma_s2mm_common_register is
    generic(
        C_NUM_REGISTERS             : integer                   := 11       ;
        C_INCLUDE_SG                : integer                   := 1        ;
        C_ENABLE_SINGLE_INTR        : integer range 0 to 1      := 0        ;
        C_MAX_CHANNELS               : integer range 1 to 16     := 1        ;
        C_SG_LENGTH_WIDTH           : integer range 8 to 23     := 14       ;
        C_S_AXI_LITE_DATA_WIDTH     : integer range 32 to 32    := 32       ;
        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 64    := 32       ;
        C_NUM_S2MM_CHANNELS         : integer range 1 to 16     := 1
        --C_CHANNEL_IS_S2MM           : integer range 0 to 1      := 0 CR603034
    );
    port (
        m_axi_sg_aclk               : in  std_logic                         ;          --
        m_axi_sg_aresetn            : in  std_logic                         ;          --
                                                                                       --
        -- AXI Interface Control                                                       --
        axi2ip_wrce                 : in  std_logic_vector                             --
                                        (C_NUM_REGISTERS-1 downto 0)        ;          --
        axi2ip_wrdata               : in  std_logic_vector                             --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);          --
        channel_in                  : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        s2mm_ch_serviced            : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        s2mm_ch_ser_reset           : in std_logic;
        pktdrp_count_in             : in std_logic_vector (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);

        ch_s2mm_ftch_channel_id     : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        ch_s2mm_updt_channel_id     : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
                                                                                       --
        -- DMASR Control                                                               --
        stop_dma                    : in  std_logic                         ;          --
        all_idle                    : in  std_logic                         ;
        halted_clr                  : in  std_logic                         ;          --
        halted_set                  : in  std_logic                         ;          --
        idle_set                    : in  std_logic                         ;          --
        idle_clr                    : in  std_logic                         ;          --
        ioc_irq_set                 : in  std_logic                         ;          --
        pktdrp_irq_set              : in  std_logic                         ;          --
        dly_irq_set                 : in  std_logic                         ;          --
        irqdelay_status             : in  std_logic_vector(7 downto 0)      ;          --
        irqthresh_status            : in  std_logic_vector(7 downto 0)      ;          --
        pktirqthresh_status         : in  std_logic_vector(7 downto 0)      ;          --
        intr_status                 : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        irqthresh_wren              : out std_logic                         ;          --
        pktdrp_irqthresh_wren       : out std_logic                         ;          --
        irqdelay_wren               : out std_logic                         ;          --
        dlyirq_dsble                : out std_logic                         ;          -- CR605888
        s2mm_run_stop               : out std_logic                         ;
        s2mm_halted                 : out std_logic                         ;
                                                                                       --
        -- Error Control                                                               --
        dma_interr_set              : in  std_logic                         ;          --
        dma_slverr_set              : in  std_logic                         ;          --
        dma_decerr_set              : in  std_logic                         ;          --
        ftch_interr_set             : in  std_logic                         ;          --
        ftch_slverr_set             : in  std_logic                         ;          --
        ftch_decerr_set             : in  std_logic                         ;          --
        ftch_error_addr             : in  std_logic_vector                             --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;          --
        updt_interr_set             : in  std_logic                         ;          --
        updt_slverr_set             : in  std_logic                         ;          --
        updt_decerr_set             : in  std_logic                         ;          --
        updt_error_addr             : in  std_logic_vector                             --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;          --
        error_in                    : in  std_logic                         ;          --
        error_out                   : out std_logic                         ;          --
        introut                     : out std_logic                         ;          --
        soft_reset_in               : in  std_logic                         ;          --
        soft_reset_clr              : in  std_logic                         ;          --
                                                                                       --
        -- Channel Register Out                                                        --
        dmacr                       : out std_logic_vector                             --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);       --
        dmasr                       : out std_logic_vector                             --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);       --
        enable_channels             : out std_logic_vector 
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);
        dma_ch_ser                  : out std_logic_vector 
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);
        dma_pktdrp                  : out std_logic_vector 
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);
        dma_err                     : out std_logic_vector 
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);
        dma_ch_serviced             : out std_logic_vector 
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);
        s2mm_user_cache             : out std_logic_vector 
                                            (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);
        dma_ch_intr_status          : out std_logic_vector 
                                            (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)
    );                                                                                 --
end axi_mcdma_s2mm_common_register;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_s2mm_common_register is

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
constant DMACR_INDEX            : integer := 0;                     -- DMACR Register index
constant DMASR_INDEX            : integer := 1;                     -- DMASR Register index
constant CHEN_INDEX             : integer := 2;                     -- Channel Enable Register
constant CHSER_INDEX            : integer := 3;                     -- Channel Service Register
constant PKTDRP_INDEX           : integer := 4;                     -- packet drop count
constant DMAERR_INDEX           : integer := 5;                     -- DMA Error register
constant CACHE_INDEX           : integer := 7;                     -- DMA Error register

constant BUFF_ADDRESS_INDEX     : integer := 6;
constant BUFF_LENGTH_INDEX      : integer := 10;                    -- Buffer Length Reg

constant ZERO_VALUE             : std_logic_vector(31 downto 0) := (others => '0');

constant DMA_CONFIG             : std_logic_vector(0 downto 0)
                                    := std_logic_vector(to_unsigned(C_INCLUDE_SG,1));

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal dmacr_i              : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal dmasr_i              : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');

signal dma_ch_ser_i              : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal dma_ch_en_i          : std_logic_vector (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);
signal dma_pktdrp_i         : std_logic_vector (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);
signal dmaerr_i             : std_logic_vector (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);
-- DMASR Signals
signal halted               : std_logic := '0';
signal idle                 : std_logic := '0';
signal cmplt                : std_logic := '0';
signal error                : std_logic := '0';
signal dma_interr           : std_logic := '0';
signal dma_slverr           : std_logic := '0';
signal dma_decerr           : std_logic := '0';
signal sg_interr            : std_logic := '0';
signal sg_slverr            : std_logic := '0';
signal sg_decerr            : std_logic := '0';
signal ioc_irq              : std_logic := '0';
signal dly_irq              : std_logic := '0';
signal error_d1             : std_logic := '0';
signal error_re             : std_logic := '0';
signal err_irq              : std_logic := '0';
signal pktdrp_irq           : std_logic := '0';

signal sg_ftch_error        : std_logic := '0';
signal sg_updt_error        : std_logic := '0';
signal error_pointer_set    : std_logic := '0';

-- interrupt coalescing support signals
signal different_delay      : std_logic := '0';
signal different_thresh     : std_logic := '0';
signal threshold_is_zero    : std_logic := '0';
signal pktdrp_threshold_is_zero : std_logic := '0';
signal pktdrp_different_thresh : std_logic := '0';

-- soft reset support signals
signal soft_reset_i         : std_logic := '0';
signal run_stop_clr         : std_logic := '0';
signal dma_run_stop         : std_logic := '0';
signal no_update            : std_logic := '0';
signal dma_ch_serviced_i    : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

dmacr                   <= dmacr_i          ;
dmasr                   <= dmasr_i          ;

dma_err                 <= dmaerr_i;
dmacr_i(MCDMACR_RESERVED1_BIT) <= '0';
---------------------------------------------------------------------------
-- DMA Control Register
---------------------------------------------------------------------------
-- DMACR - Interrupt Delay Value
-------------------------------------------------------------------------------
--DMACR_DELAY : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
                dmacr_i(MCDMACR_IRQDELAY_MSB_BIT
                 downto MCDMACR_IRQDELAY_LSB_BIT) <= (others => '0');
--            elsif((axi2ip_wrce(DMACR_INDEX) = '1') and (C_ENABLE_SINGLE_INTR = 1))then
--                dmacr_i(MCDMACR_IRQDELAY_MSB_BIT
--                 downto MCDMACR_IRQDELAY_LSB_BIT) <= axi2ip_wrdata(MCDMACR_IRQDELAY_MSB_BIT
--                                                          downto MCDMACR_IRQDELAY_LSB_BIT);
--            end if;
--        end if;
--    end process DMACR_DELAY;

-- If written delay is different than previous value then assert write enable
different_delay <= '1';
--different_delay <= '1' when dmacr_i(MCDMACR_IRQDELAY_MSB_BIT downto MCDMACR_IRQDELAY_LSB_BIT)
--                   /= axi2ip_wrdata(MCDMACR_IRQDELAY_MSB_BIT downto MCDMACR_IRQDELAY_LSB_BIT)
--              else '0';

-- delay value different, drive write of delay value to interrupt controller
--NEW_DELAY_WRITE : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
                irqdelay_wren <= '0';
            -- If AXI Lite write to DMACR and delay different than current
            -- setting then update delay value
--            elsif(axi2ip_wrce(DMACR_INDEX) = '1' and different_delay = '1' and C_ENABLE_SINGLE_INTR = 1)then
--                irqdelay_wren <= '1';
--            else
--                irqdelay_wren <= '0';
--            end if;
--        end if;
--    end process NEW_DELAY_WRITE;

-------------------------------------------------------------------------------
-- DMACR - Interrupt Threshold Value
-------------------------------------------------------------------------------
threshold_is_zero <= '1';
--threshold_is_zero <= '1' when axi2ip_wrdata(MCDMACR_IRQTHRESH_MSB_BIT
--                                     downto MCDMACR_IRQTHRESH_LSB_BIT) = ZERO_THRESHOLD
--                else '0';

--DMACR_THRESH : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
                dmacr_i(MCDMACR_IRQTHRESH_MSB_BIT
                        downto MCDMACR_IRQTHRESH_LSB_BIT) <= ONE_THRESHOLD;
            -- On AXI Lite write
--            elsif(axi2ip_wrce(DMACR_INDEX) = '1' and C_ENABLE_SINGLE_INTR = 1)then
--
--                -- If value is 0 then set threshold to 1
--                if(threshold_is_zero='1')then
--                    dmacr_i(MCDMACR_IRQTHRESH_MSB_BIT
--                     downto MCDMACR_IRQTHRESH_LSB_BIT)    <= ONE_THRESHOLD;
--
--                -- else set threshold to axi lite wrdata value
--                else
--                    dmacr_i(MCDMACR_IRQTHRESH_MSB_BIT
--                     downto MCDMACR_IRQTHRESH_LSB_BIT)    <= axi2ip_wrdata(MCDMACR_IRQTHRESH_MSB_BIT
--                                                                  downto MCDMACR_IRQTHRESH_LSB_BIT);
--                end if;
--            end if;
--        end if;
--    end process DMACR_THRESH;

-- If written threshold is different than previous value then assert write enable
different_thresh <= '1';
--different_thresh <= '1' when dmacr_i(MCDMACR_IRQTHRESH_MSB_BIT downto MCDMACR_IRQTHRESH_LSB_BIT)
--                    /= axi2ip_wrdata(MCDMACR_IRQTHRESH_MSB_BIT downto MCDMACR_IRQTHRESH_LSB_BIT)
--              else '0';

-- new treshold written therefore drive write of threshold out
--NEW_THRESH_WRITE : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
                irqthresh_wren <= '0';
            -- If AXI Lite write to DMACR and threshold different than current
            -- setting then update threshold value
--            elsif(axi2ip_wrce(DMACR_INDEX) = '1' and different_thresh = '1' and C_ENABLE_SINGLE_INTR = 1)then
--                irqthresh_wren <= '1';
--            else
--                irqthresh_wren <= '0';
--            end if;
--        end if;
--    end process NEW_THRESH_WRITE;


-------------------------------------------------------------------------------
-- DMACR - Packet Drop Interrupt Threshold Value
-------------------------------------------------------------------------------
pktdrp_threshold_is_zero <= '1';
--pktdrp_threshold_is_zero <= '1' when axi2ip_wrdata(MCDMACR_PKTTHRESH_MSB_BIT
--                                     downto MCDMACR_PKTTHRESH_LSB_BIT) = ZERO_THRESHOLD
--                else '0';

--DMACR_PKTTHRESH : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
                dmacr_i(MCDMACR_PKTTHRESH_MSB_BIT
                        downto MCDMACR_PKTTHRESH_LSB_BIT) <= ONE_THRESHOLD;
            -- On AXI Lite write
--            elsif(axi2ip_wrce(DMACR_INDEX) = '1' and C_ENABLE_SINGLE_INTR = 1)then

                -- If value is 0 then set threshold to 1
--                if(pktdrp_threshold_is_zero='1')then
--                    dmacr_i(MCDMACR_PKTTHRESH_MSB_BIT
--                     downto MCDMACR_PKTTHRESH_LSB_BIT)    <= ONE_THRESHOLD;

                -- else set threshold to axi lite wrdata value
--                else
--                    dmacr_i(MCDMACR_PKTTHRESH_MSB_BIT
--                     downto MCDMACR_PKTTHRESH_LSB_BIT)    <= axi2ip_wrdata(MCDMACR_PKTTHRESH_MSB_BIT
--                                                                  downto MCDMACR_PKTTHRESH_LSB_BIT);
--                end if;
--            end if;
--        end if;
--    end process DMACR_PKTTHRESH;

-- If written threshold is different than previous value then assert write enable
pktdrp_different_thresh <= '1';
--pktdrp_different_thresh <= '1' when dmacr_i(MCDMACR_PKTTHRESH_MSB_BIT downto MCDMACR_PKTTHRESH_LSB_BIT)
--                    /= axi2ip_wrdata(MCDMACR_PKTTHRESH_MSB_BIT downto MCDMACR_PKTTHRESH_LSB_BIT)
--              else '0';

-- new treshold written therefore drive write of threshold out
--NEW_PKTDRPTHRESH_WRITE : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
                pktdrp_irqthresh_wren <= '0';
            -- If AXI Lite write to DMACR and threshold different than current
            -- setting then update threshold value
--            elsif(axi2ip_wrce(DMACR_INDEX) = '1' and pktdrp_different_thresh = '1' and C_ENABLE_SINGLE_INTR = 1)then
--                pktdrp_irqthresh_wren <= '1';
--            else
--                pktdrp_irqthresh_wren <= '0';
--            end if;
--        end if;
--    end process NEW_PKTDRPTHRESH_WRITE;

-- Channel Enable Register

DMACH_EN_REGISTER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dma_ch_en_i(C_MAX_CHANNELS-1
                        downto MCDMACH_EN_LSB+1)   <= (others => '0');
                dma_ch_en_i (MCDMACH_EN_LSB) <= '1';
            elsif(axi2ip_wrce(CHEN_INDEX) = '1')then
                dma_ch_en_i(C_NUM_S2MM_CHANNELS-1              
                        downto MCDMACH_EN_LSB)   <= axi2ip_wrdata (C_NUM_S2MM_CHANNELS-1 downto MCDMACH_EN_LSB);
            end if;
        end if;
    end process DMACH_EN_REGISTER;

dma_ch_en_i (MCDMACH_EN_RSDV_MSB downto C_MAX_CHANNELS) <= (others => '0');

enable_channels <= dma_ch_en_i;

-- channel service register

DMACH_SER_REGISTER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dma_ch_ser_i <= (others => '0');
                no_update <= '0';
            elsif (sg_ftch_error = '1' and no_update = '0') then
                no_update <= '1';
                dma_ch_ser_i (C_MAX_CHANNELS-1 downto 0) <= ch_s2mm_ftch_channel_id; 
      
            elsif (sg_updt_error = '1' and no_update = '0') then
                no_update <= '1';
                dma_ch_ser_i (C_MAX_CHANNELS-1 downto 0) <= ch_s2mm_updt_channel_id; 

            elsif (no_update = '0') then
                dma_ch_ser_i (C_MAX_CHANNELS-1 downto 0) <= channel_in; 
            end if;
        end if;
    end process DMACH_SER_REGISTER;

dma_ch_ser <= dma_ch_ser_i;


-- packet drop register

DMA_PKTDRP_REGISTER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dma_pktdrp_i <= (others => '0');
            else
                dma_pktdrp_i <= pktdrp_count_in; 
            end if;
        end if;
    end process DMA_PKTDRP_REGISTER;

dma_pktdrp <= dma_pktdrp_i;

-- channels serviced register

DMA_PKTSER_REGISTER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dma_ch_serviced_i <= (others => '0');
            elsif  (s2mm_ch_ser_reset = '1') then -- ensures it will not miss any values
                dma_ch_serviced_i <= s2mm_ch_serviced;
            else
                dma_ch_serviced_i <= dma_ch_serviced_i or s2mm_ch_serviced;
            end if;
        end if;
    end process DMA_PKTSER_REGISTER;

                dma_ch_serviced (C_MAX_CHANNELS-1 downto 0) <= dma_ch_serviced_i;
                dma_ch_serviced (31 downto C_MAX_CHANNELS) <= (others => '0');

CACHE_REGISTER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
               s2mm_user_cache (15 downto 0) <= "0000000000000011";
            elsif(axi2ip_wrce(CACHE_INDEX) = '1')then
               s2mm_user_cache (15 downto 0) <= axi2ip_wrdata (15 downto 0);
            end if;
        end if;
    end process CACHE_REGISTER;

s2mm_user_cache (31 downto 16) <= (others => '0');

DMA_INTR_REGISTER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dma_ch_intr_status (C_MAX_CHANNELS-1 downto 0) <= (others => '0');
            elsif (C_ENABLE_SINGLE_INTR = 0) then
                dma_ch_intr_status (C_MAX_CHANNELS-1 downto 0) <= intr_status;
            end if;
        end if;
    end process DMA_INTR_REGISTER;

    dma_ch_intr_status (31 downto C_MAX_CHANNELS) <= (others => '0');

-------------------------------------------------------------------------------
-- DMACR - Remainder of DMA Control Register
-------------------------------------------------------------------------------
--DMACR_REGISTER : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
                dmacr_i(MCDMACR_ERR_IRQEN_BIT
                        downto MCDMACR_RESERVED3_BIT)   <= (others => '0');

--            elsif(axi2ip_wrce(DMACR_INDEX) = '1' and C_ENABLE_SINGLE_INTR = 1)then
--                dmacr_i(MCDMACR_ERR_IRQEN_BIT              
--                        downto MCDMACR_RESERVED3_BIT)   <=  -- bit 7
--                                                        axi2ip_wrdata(MCDMACR_ERR_IRQEN_BIT)
--                                                        -- bit 6
--                                                        & axi2ip_wrdata(MCDMACR_DLY_IRQEN_BIT)
--                                                        -- bit 5
--                                                        & axi2ip_wrdata(MCDMACR_IOC_IRQEN_BIT)
--                                                        -- bit 4
--                                                        & axi2ip_wrdata(MCDMACR_PKT_IRQEN_BIT)
--                                                        -- bits 3 downto 1
--                                                        & ZERO_VALUE(MCDMACR_RESERVED3_BIT);
--            end if;
--        end if;
--    end process DMACR_REGISTER;

-------------------------------------------------------------------------------
-- DMACR - Reset Bit
-------------------------------------------------------------------------------
DMACR_RESET : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(soft_reset_clr = '1')then
                dmacr_i(MCDMACR_RESET_BIT)  <= '0';
            -- If soft reset set in other channel then set
            -- reset bit here too
            elsif(soft_reset_in = '1')then
                dmacr_i(MCDMACR_RESET_BIT)  <= '1';

           -- If DMACR Write then pass axi lite write bus to DMARC reset bit
            elsif(soft_reset_i = '0' and axi2ip_wrce(DMACR_INDEX) = '1')then
                dmacr_i(MCDMACR_RESET_BIT)  <= axi2ip_wrdata(MCDMACR_RESET_BIT);

            end if;
        end if;
    end process DMACR_RESET;

soft_reset_i <= dmacr_i(MCDMACR_RESET_BIT);

-------------------------------------------------------------------------------
-- DMACR - Run/Stop Bit
-- A plain vanilla run stop; actual run stop moves to common register
-------------------------------------------------------------------------------
run_stop_clr <= '1' when error = '1'                -- MM2S DataMover Error
                      or error_in = '1'             -- S2MM Error
                      or stop_dma = '1'             -- Stop due to error
                      or soft_reset_i = '1'         -- MM2S Soft Reset
                      or soft_reset_in  = '1'       -- S2MM Soft Reset
           else '0';


DMACR_RUNSTOP : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dmacr_i(MCDMACR_RS_BIT)  <= '0';
            -- Clear on sg error (i.e. error) or other channel
            -- error (i.e. error_in) or dma error or soft reset
            elsif(run_stop_clr = '1')then
                dmacr_i(MCDMACR_RS_BIT)  <= '0';
            elsif(axi2ip_wrce(DMACR_INDEX) = '1')then
                dmacr_i(MCDMACR_RS_BIT)  <= axi2ip_wrdata(MCDMACR_RS_BIT);
            end if;
        end if;
    end process DMACR_RUNSTOP;

dma_run_stop <= dmacr_i(MCDMACR_RS_BIT);
s2mm_run_stop <= dmacr_i(MCDMACR_RS_BIT);

---------------------------------------------------------------------------
-- DMA Status Halted bit (BIT 0) - Set by dma controller indicating DMA
-- channel is halted.
---------------------------------------------------------------------------
DMASR_HALTED : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0' or halted_set = '1')then
                halted <= '1';
            elsif(halted_clr = '1')then
                halted <= '0';
            end if;
        end if;
    end process DMASR_HALTED;

s2mm_halted <= halted;

---------------------------------------------------------------------------
-- DMA Status Idle bit (BIT 1) - Set by dma controller indicating DMA
-- channel is IDLE waiting at tail pointer.  Update of Tail Pointer
-- will cause engine to resume.  Note: Halted channels return to a
-- reset condition.
-- this will now show only SG idle for a channel
---------------------------------------------------------------------------
DMASR_IDLE : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0'
            or idle_clr = '1'
            or halted_set = '1')then
                idle   <= '0';
            elsif(idle_set = '1')then
                idle   <= '1';
            end if;
        end if;
    end process DMASR_IDLE;

---------------------------------------------------------------------------
-- DMA Status Error bit (BIT 3)
-- Note: any error will cause entire engine to halt
---------------------------------------------------------------------------
error  <= dma_interr
            or dma_slverr
            or dma_decerr
            or sg_interr
            or sg_slverr
            or sg_decerr;
---- Map out to halt opposing channel
error_out   <= error;

-- Scatter Gather Error
--sg_ftch_error <= ftch_interr_set or ftch_slverr_set or ftch_decerr_set;

-- SG Update Errors or DMA errors assert flag on descriptor update
-- Used to latch current descriptor pointer
--sg_updt_error <= updt_interr_set or updt_slverr_set or updt_decerr_set
--              or dma_interr or dma_slverr or dma_decerr;


ERROR_LOG : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
               sg_ftch_error <= '0';
               sg_updt_error <= '0';
            else
               sg_ftch_error <= ftch_interr_set or ftch_slverr_set or ftch_decerr_set;
               sg_updt_error <= updt_interr_set or updt_slverr_set or updt_decerr_set
                                or dma_interr or dma_slverr or dma_decerr;
            end if;
        end if;
    end process ERROR_LOG;

---------------------------------------------------------------------------
-- DMA Status DMA Internal Error bit (BIT 4)
---------------------------------------------------------------------------
DMASR_DMAINTERR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dma_interr <= '0';
            elsif(dma_interr_set = '1' )then
                dma_interr <= '1';
            end if;
        end if;
    end process DMASR_DMAINTERR;

---------------------------------------------------------------------------
-- DMA Status DMA Slave Error bit (BIT 5)
---------------------------------------------------------------------------
DMASR_DMASLVERR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dma_slverr <= '0';

            elsif(dma_slverr_set = '1' )then
                dma_slverr <= '1';

            end if;
        end if;
    end process DMASR_DMASLVERR;

---------------------------------------------------------------------------
-- DMA Status DMA Decode Error bit (BIT 6)
---------------------------------------------------------------------------
DMASR_DMADECERR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dma_decerr <= '0';

            elsif(dma_decerr_set = '1' )then
                dma_decerr <= '1';

            end if;
        end if;
    end process DMASR_DMADECERR;

---------------------------------------------------------------------------
-- DMA Status SG Internal Error bit (BIT 8)
-- (SG Mode only - trimmed at build time if simple mode)
---------------------------------------------------------------------------
DMASR_SGINTERR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                sg_interr <= '0';

            elsif(ftch_interr_set = '1' or updt_interr_set = '1')then
                sg_interr <= '1';


            end if;
        end if;
    end process DMASR_SGINTERR;

---------------------------------------------------------------------------
-- DMA Status SG Slave Error bit (BIT 9)
-- (SG Mode only - trimmed at build time if simple mode)
---------------------------------------------------------------------------
DMASR_SGSLVERR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                sg_slverr <= '0';

            elsif(ftch_slverr_set = '1' or updt_slverr_set = '1')then
                sg_slverr <= '1';

            end if;
        end if;
    end process DMASR_SGSLVERR;

---------------------------------------------------------------------------
-- DMA Status SG Decode Error bit (BIT 10)
-- (SG Mode only - trimmed at build time if simple mode)
-------------------------------------------------------------------------
DMASR_SGDECERR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                sg_decerr <= '0';

            elsif(ftch_decerr_set = '1' or updt_decerr_set = '1')then
                sg_decerr <= '1';

            end if;
        end if;
    end process DMASR_SGDECERR;

---------------------------------------------------------------------------
-- DMA Status IOC Interrupt status bit (BIT 11)
---------------------------------------------------------------------------
--DMASR_IOCIRQ : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
                ioc_irq <= '0';

            -- CPU Writing a '1' to clear - OR'ed with setting to prevent
            -- missing a 'set' during the write.
--            elsif(axi2ip_wrce(DMASR_INDEX) = '1' and C_ENABLE_SINGLE_INTR = 1)then
--
--                ioc_irq <= (ioc_irq and not(axi2ip_wrdata(MCDMASR_IOCIRQ_BIT)))
--                             or ioc_irq_set;
--
--            elsif(ioc_irq_set = '1' and C_ENABLE_SINGLE_INTR = 1)then
--                ioc_irq <= '1';
--
--            end if;
--        end if;
--    end process DMASR_IOCIRQ;

---------------------------------------------------------------------------
-- DMA Status Delay Interrupt status bit (BIT 12)
---------------------------------------------------------------------------
--DMASR_DLYIRQ : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
                dly_irq <= '0';

            -- CPU Writing a '1' to clear - OR'ed with setting to prevent
            -- missing a 'set' during the write.
--            elsif(axi2ip_wrce(DMASR_INDEX) = '1' and C_ENABLE_SINGLE_INTR = 1)then
--
--                dly_irq <= (dly_irq and not(axi2ip_wrdata(MCDMASR_DLYIRQ_BIT)))
--                             or dly_irq_set;
--
--            elsif(dly_irq_set = '1' and C_ENABLE_SINGLE_INTR = 1)then
--                dly_irq <= '1';
--
--            end if;
--        end if;
--    end process DMASR_DLYIRQ;

-- CR605888 Disable delay timer if halted or on delay irq set
--dlyirq_dsble    <= dmasr_i(DMASR_HALTED_BIT)              -- CR606348

-- kapil : need to get the real RS here
dlyirq_dsble    <= (not dma_run_stop                -- CR606348
                    or dmasr_i(MCDMASR_DLYIRQ_BIT));-- and (C_ENABLE_SINGLE_INTR = 1);



---------------------------------------------------------------------------
-- DMA Status Error Interrupt status bit (BIT 12)
---------------------------------------------------------------------------
-- Delay error setting for generation of error strobe
GEN_ERROR_RE : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                error_d1 <= '0';
            else
                error_d1 <= error;
            end if;
        end if;
    end process GEN_ERROR_RE;

-- Generate rising edge pulse on error
error_re   <= error and not error_d1;

--DMASR_ERRIRQ : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
                err_irq <= '0';

--            -- CPU Writing a '1' to clear - OR'ed with setting to prevent
--            -- missing a 'set' during the write.
--            elsif(axi2ip_wrce(DMASR_INDEX) = '1' and C_ENABLE_SINGLE_INTR = 1)then
--
--                err_irq <= (err_irq and not(axi2ip_wrdata(MCDMASR_ERRIRQ_BIT)))
--                             or error_re;
--
--            elsif(error_re = '1' and C_ENABLE_SINGLE_INTR = 1)then
--                err_irq <= '1';
--
--            end if;
--        end if;
--    end process DMASR_ERRIRQ;


---------------------------------------------------------------------------
-- DMA Status IOC Interrupt status bit (BIT 11)
---------------------------------------------------------------------------
--DMASR_PKTIRQ : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
                pktdrp_irq <= '0';

            -- CPU Writing a '1' to clear - OR'ed with setting to prevent
            -- missing a 'set' during the write.
--            elsif(axi2ip_wrce(DMASR_INDEX) = '1' and C_ENABLE_SINGLE_INTR = 1)then
--
--                pktdrp_irq <= (pktdrp_irq and not(axi2ip_wrdata(MCDMASR_PKTIRQ_BIT)))
--                             or pktdrp_irq_set;
--
--            elsif(pktdrp_irq_set = '1' and C_ENABLE_SINGLE_INTR = 1)then
--                pktdrp_irq <= '1';
--
--            end if;
--        end if;
--    end process DMASR_PKTIRQ;

---------------------------------------------------------------------------
-- DMA Interrupt OUT
---------------------------------------------------------------------------
--REG_INTR : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0' or soft_reset_i = '1')then
                introut <= '0';
--            elsif (C_ENABLE_SINGLE_INTR = 1) then
--                introut <= (dly_irq and dmacr_i(MCDMACR_DLY_IRQEN_BIT))
--                        or (ioc_irq and dmacr_i(MCDMACR_IOC_IRQEN_BIT))
--                        or (pktdrp_irq and dmacr_i(MCDMACR_PKT_IRQEN_BIT))
--                        or (err_irq and dmacr_i(MCDMACR_ERR_IRQEN_BIT));
--            else
--                introut <= '0';
--            end if;
--        end if;
--    end process;

---------------------------------------------------------------------------
-- DMA Status Register
---------------------------------------------------------------------------
dmasr_i    <=  irqdelay_status         -- Bits 31 downto 24
             & irqthresh_status        -- Bits 23 downto 16
             & pktirqthresh_status     -- Bit  15 downto 8
             & err_irq          -- Bit  7
             & dly_irq          -- Bit  6
             & ioc_irq          -- Bit  5
             & pktdrp_irq              -- Bit  4
             & '0'        -- Bit  3
             & '0'        -- Bit  2
             & idle              -- Bit  1
             & halted;    -- Bit 0  


dmaerr_i <= "0000000000000000000000000"
            &   sg_decerr
            &   sg_slverr
            &   sg_interr
            &   '0'
            &   dma_decerr
            &   dma_slverr
            &   dma_interr;

end implementation;



-------------------------------------------------------------------------------
-- axi_mcdma_mm2s_common_register
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_mcdma_mm2s_common_register.vhd
--
-- Description:     This entity encompasses the channel register set.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_mcdma_mm2s_common_register is
    generic(
        C_NUM_REGISTERS             : integer                   := 11       ;
        C_INCLUDE_SG                : integer                   := 1        ;
        C_ENABLE_SINGLE_INTR        : integer range 0 to 1      := 0        ;
        C_MAX_CHANNELS               : integer range 1 to 16     := 1        ;
        C_SG_LENGTH_WIDTH           : integer range 8 to 23     := 14       ;
        C_S_AXI_LITE_DATA_WIDTH     : integer range 32 to 32    := 32       ;
        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 64    := 32       ;
        C_NUM_MM2S_CHANNELS         : integer range 1 to 16     := 1        ;
        C_MM2S_SCHEDULE             : integer range 0 to 3      := 1
        --C_CHANNEL_IS_MM2S           : integer range 0 to 1      := 0 CR603034
    );
    port (
        m_axi_sg_aclk               : in  std_logic                         ;          --
        m_axi_sg_aresetn            : in  std_logic                         ;          --
                                                                                       --
        -- AXI Interface Control                                                       --
        axi2ip_wrce                 : in  std_logic_vector                             --
                                        (C_NUM_REGISTERS-1 downto 0)        ;          --
        axi2ip_wrdata               : in  std_logic_vector                             --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);          --
        channel_in                  : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        mm2s_ch_serviced            : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        mm2s_ch_ser_reset           : in std_logic;
        pktdrp_count_in             : in std_logic_vector (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);

        ch_mm2s_ftch_channel_id     : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        ch_mm2s_updt_channel_id     : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
                                                                                       --
        -- DMASR Control                                                               --
        stop_dma                    : in  std_logic                         ;          --
        all_idle                    : in  std_logic                         ;
        halted_clr                  : in  std_logic                         ;          --
        halted_set                  : in  std_logic                         ;          --
        idle_set                    : in  std_logic                         ;          --
        idle_clr                    : in  std_logic                         ;          --
        ioc_irq_set                 : in  std_logic                         ;          --
        pktdrp_irq_set              : in  std_logic                         ;          --
        dly_irq_set                 : in  std_logic                         ;          --
        irqdelay_status             : in  std_logic_vector(7 downto 0)      ;          --
        irqthresh_status            : in  std_logic_vector(7 downto 0)      ;          --
        pktirqthresh_status         : in  std_logic_vector(7 downto 0)      ;          --
        intr_status                 : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        irqthresh_wren              : out std_logic                         ;          --
        pktdrp_irqthresh_wren       : out std_logic                         ;          --
        irqdelay_wren               : out std_logic                         ;          --
        dlyirq_dsble                : out std_logic                         ;          -- CR605888
        mm2s_run_stop               : out std_logic                         ;
        mm2s_halted                 : out std_logic                         ;
                                                                                       --
        -- Error Control                                                               --
        dma_interr_set              : in  std_logic                         ;          --
        dma_slverr_set              : in  std_logic                         ;          --
        dma_decerr_set              : in  std_logic                         ;          --
        ftch_interr_set             : in  std_logic                         ;          --
        ftch_slverr_set             : in  std_logic                         ;          --
        ftch_decerr_set             : in  std_logic                         ;          --
        ftch_error_addr             : in  std_logic_vector                             --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;          --
        updt_interr_set             : in  std_logic                         ;          --
        updt_slverr_set             : in  std_logic                         ;          --
        updt_decerr_set             : in  std_logic                         ;          --
        updt_error_addr             : in  std_logic_vector                             --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;          --
        error_in                    : in  std_logic                         ;          --
        error_out                   : out std_logic                         ;          --
        introut                     : out std_logic                         ;          --
        soft_reset_in               : in  std_logic                         ;          --
        soft_reset_clr              : in  std_logic                         ;          --
                                                                                       --
        -- Channel Register Out                                                        --
        mm2s_sch                    : out std_logic_vector                             --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);       --
        channel_weight              : out std_logic_vector                             --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);       --
        channel_weight_2            : out std_logic_vector                             --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);       --
        dmacr                       : out std_logic_vector                             --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);       --
        dmasr                       : out std_logic_vector                             --
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);       --
        enable_channels             : out std_logic_vector 
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);
        dma_ch_ser                  : out std_logic_vector 
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);
        dma_pktdrp                  : out std_logic_vector 
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);
        dma_err                     : out std_logic_vector 
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);
        dma_ch_serviced             : out std_logic_vector
                                           (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);
        mm2s_user_cache             : out std_logic_vector
                                         (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);
        dma_ch_intr_status          : out std_logic_vector
                                         (C_S_AXI_LITE_DATA_WIDTH-1 downto 0)

    );                                                                                 --
end axi_mcdma_mm2s_common_register;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_mm2s_common_register is

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
constant DMACR_INDEX            : integer := 0;                     -- DMACR Register index
constant DMASR_INDEX            : integer := 1;                     -- DMASR Register index
constant CHEN_INDEX             : integer := 2;                     -- Channel Enable Register
constant CHSER_INDEX            : integer := 3;                     -- Channel Service Register
constant DMAERR_INDEX           : integer := 4;                     
constant BD_SCH_INDEX           : integer := 5;                     
constant WRR1_INDEX             : integer := 6;                     
constant WRR2_INDEX             : integer := 7;                     
constant CACHE_INDEX            : integer := 9;                     

constant ZERO_VALUE             : std_logic_vector(31 downto 0) := (others => '0');

constant DMA_CONFIG             : std_logic_vector(0 downto 0)
                                    := std_logic_vector(to_unsigned(C_INCLUDE_SG,1));

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal dmacr_i              : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal dmasr_i              : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');

signal dma_ch_ser_i              : std_logic_vector
                                (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal dma_ch_en_i          : std_logic_vector (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);
signal dma_pktdrp_i         : std_logic_vector (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);
signal dmaerr_i             : std_logic_vector (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);
-- DMASR Signals
signal halted               : std_logic := '0';
signal idle                 : std_logic := '0';
signal cmplt                : std_logic := '0';
signal error                : std_logic := '0';
signal dma_interr           : std_logic := '0';
signal dma_slverr           : std_logic := '0';
signal dma_decerr           : std_logic := '0';
signal sg_interr            : std_logic := '0';
signal sg_slverr            : std_logic := '0';
signal sg_decerr            : std_logic := '0';
signal ioc_irq              : std_logic := '0';
signal dly_irq              : std_logic := '0';
signal error_d1             : std_logic := '0';
signal error_re             : std_logic := '0';
signal err_irq              : std_logic := '0';
signal pktdrp_irq           : std_logic := '0';

signal sg_ftch_error        : std_logic := '0';
signal sg_updt_error        : std_logic := '0';
signal error_pointer_set    : std_logic := '0';

-- interrupt coalescing support signals
signal different_delay      : std_logic := '0';
signal different_thresh     : std_logic := '0';
signal threshold_is_zero    : std_logic := '0';
signal pktdrp_threshold_is_zero : std_logic := '0';
signal pktdrp_different_thresh : std_logic := '0';

-- soft reset support signals
signal soft_reset_i         : std_logic := '0';
signal run_stop_clr         : std_logic := '0';
signal dma_run_stop         : std_logic := '0';
signal no_update            : std_logic := '0';
signal sch_valid : std_logic := '0';
signal dma_ch_serviced_i : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

dmacr                   <= dmacr_i          ;
dmasr                   <= dmasr_i          ;

dma_err                 <= dmaerr_i;
dmacr_i(MCDMACR_PKTTHRESH_MSB_BIT downto 
		MCDMACR_PKTTHRESH_LSB_BIT) <= (others => '0');
dmacr_i(MCDMACR_RESERVED1_BIT) <= '0';
---------------------------------------------------------------------------
-- DMA Control Register
---------------------------------------------------------------------------
-- DMACR - Interrupt Delay Value
-------------------------------------------------------------------------------
--DMACR_DELAY : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
                dmacr_i(MCDMACR_IRQDELAY_MSB_BIT
                 downto MCDMACR_IRQDELAY_LSB_BIT) <= (others => '0');
--            elsif((axi2ip_wrce(DMACR_INDEX) = '1') and (C_ENABLE_SINGLE_INTR = 1))then
--                dmacr_i(MCDMACR_IRQDELAY_MSB_BIT
--                 downto MCDMACR_IRQDELAY_LSB_BIT) <= axi2ip_wrdata(MCDMACR_IRQDELAY_MSB_BIT
--                                                          downto MCDMACR_IRQDELAY_LSB_BIT);
--            end if;
--        end if;
--    end process DMACR_DELAY;

-- If written delay is different than previous value then assert write enable
--different_delay <= '1' when dmacr_i(MCDMACR_IRQDELAY_MSB_BIT downto MCDMACR_IRQDELAY_LSB_BIT)
--                   /= axi2ip_wrdata(MCDMACR_IRQDELAY_MSB_BIT downto MCDMACR_IRQDELAY_LSB_BIT)
--              else '0';
  different_delay <= '0';

-- delay value different, drive write of delay value to interrupt controller
--NEW_DELAY_WRITE : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
--                irqdelay_wren <= '0';
--            -- If AXI Lite write to DMACR and delay different than current
--            -- setting then update delay value
--            elsif(axi2ip_wrce(DMACR_INDEX) = '1' and different_delay = '1' and C_ENABLE_SINGLE_INTR = 1)then
--                irqdelay_wren <= '1';
--            else
                irqdelay_wren <= '0';
--            end if;
--        end if;
--    end process NEW_DELAY_WRITE;

-------------------------------------------------------------------------------
-- DMACR - Interrupt Threshold Value
-------------------------------------------------------------------------------
threshold_is_zero <= '1';
--threshold_is_zero <= '1' when axi2ip_wrdata(MCDMACR_IRQTHRESH_MSB_BIT
--                                     downto MCDMACR_IRQTHRESH_LSB_BIT) = ZERO_THRESHOLD
--                else '0';

--DMACR_THRESH : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
                dmacr_i(MCDMACR_IRQTHRESH_MSB_BIT
                        downto MCDMACR_IRQTHRESH_LSB_BIT) <= ONE_THRESHOLD;
--            -- On AXI Lite write
--            elsif(axi2ip_wrce(DMACR_INDEX) = '1' and C_ENABLE_SINGLE_INTR = 1)then
--
--                -- If value is 0 then set threshold to 1
--                if(threshold_is_zero='1')then
--                    dmacr_i(MCDMACR_IRQTHRESH_MSB_BIT
--                     downto MCDMACR_IRQTHRESH_LSB_BIT)    <= ONE_THRESHOLD;
--
--                -- else set threshold to axi lite wrdata value
--                else
--                    dmacr_i(MCDMACR_IRQTHRESH_MSB_BIT
--                     downto MCDMACR_IRQTHRESH_LSB_BIT)    <= axi2ip_wrdata(MCDMACR_IRQTHRESH_MSB_BIT
--                                                                  downto MCDMACR_IRQTHRESH_LSB_BIT);
--                end if;
--            end if;
--        end if;
--    end process DMACR_THRESH;

-- If written threshold is different than previous value then assert write enable
different_thresh <= '1';
--different_thresh <= '1' when dmacr_i(MCDMACR_IRQTHRESH_MSB_BIT downto MCDMACR_IRQTHRESH_LSB_BIT)
--                    /= axi2ip_wrdata(MCDMACR_IRQTHRESH_MSB_BIT downto MCDMACR_IRQTHRESH_LSB_BIT)
--              else '0';

-- new treshold written therefore drive write of threshold out
--NEW_THRESH_WRITE : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
--                irqthresh_wren <= '0';
--            -- If AXI Lite write to DMACR and threshold different than current
--            -- setting then update threshold value
--            elsif(axi2ip_wrce(DMACR_INDEX) = '1' and different_thresh = '1' and C_ENABLE_SINGLE_INTR = 1)then
--                irqthresh_wren <= '1';
--            else
                irqthresh_wren <= '0';
--            end if;
--        end if;
--    end process NEW_THRESH_WRITE;



FIXED_SCH : if C_MM2S_SCHEDULE /= 0 generate
begin

ONE_SCH: if (C_MM2S_SCHEDULE = 1) generate
begin
                mm2s_sch (2 downto 0) <= "001";
end generate ONE_SCH;

TWO_SCH: if (C_MM2S_SCHEDULE = 2) generate
begin
                mm2s_sch (2 downto 0) <= "010";
end generate TWO_SCH;

THREE_SCH: if (C_MM2S_SCHEDULE = 3) generate
begin
                mm2s_sch (2 downto 0) <= "100";
end generate THREE_SCH;


end generate FIXED_SCH;


PROG_SCH : if C_MM2S_SCHEDULE = 0 generate
begin

sch_valid <= '1' when ((axi2ip_wrdata (2 downto 0) = "001" or 
                        axi2ip_wrdata (2 downto 0) = "010" or
                        axi2ip_wrdata (2 downto 0) = "100")) else '0';

MM2S_SCH_REG : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if (m_axi_sg_aresetn = '0') then
                mm2s_sch (2 downto 0) <= "010";
            elsif (axi2ip_wrce(BD_SCH_INDEX) = '1' and sch_valid = '1') then
                mm2s_sch (2 downto 0) <= axi2ip_wrdata (2 downto 0);
            elsif (axi2ip_wrce(BD_SCH_INDEX) = '1' and sch_valid = '0') then
                mm2s_sch (2 downto 0) <= "010";
            end if;
        end if;
    end process MM2S_SCH_REG;

end generate PROG_SCH;

mm2s_sch (31 downto 3) <= (others => '0');


CH_WEIGHT_REGISTER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
               channel_weight <= "00010001000100010001000100010001";
            elsif(axi2ip_wrce(WRR1_INDEX) = '1')then
               channel_weight <= axi2ip_wrdata;
            end if;
        end if;
    end process CH_WEIGHT_REGISTER;


CH_WEIGHT2_REGISTER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
               channel_weight_2 <= "00010001000100010001000100010001";
            elsif(axi2ip_wrce(WRR2_INDEX) = '1')then
               channel_weight_2 <= axi2ip_wrdata;
            end if;
        end if;
    end process CH_WEIGHT2_REGISTER;


CACHE_REGISTER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
               mm2s_user_cache (15 downto 0) <= "0000000000000011";
            elsif(axi2ip_wrce(CACHE_INDEX) = '1')then
               mm2s_user_cache (15 downto 0) <= axi2ip_wrdata (15 downto 0);
            end if;
        end if;
    end process CACHE_REGISTER;

mm2s_user_cache (31 downto 16) <= (others => '0');

DMACH_EN_REGISTER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dma_ch_en_i(C_MAX_CHANNELS-1
                        downto MCDMACH_EN_LSB+1)   <= (others => '0');
                dma_ch_en_i (MCDMACH_EN_LSB) <= '1';
            elsif(axi2ip_wrce(CHEN_INDEX) = '1')then
                dma_ch_en_i(C_NUM_MM2S_CHANNELS-1              
                        downto MCDMACH_EN_LSB)   <= axi2ip_wrdata (C_NUM_MM2S_CHANNELS-1 downto MCDMACH_EN_LSB);
            end if;
        end if;
    end process DMACH_EN_REGISTER;

dma_ch_en_i (MCDMACH_EN_RSDV_MSB downto C_MAX_CHANNELS) <= (others => '0');

enable_channels <= dma_ch_en_i;

-- channel service register

DMACH_SER_REGISTER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dma_ch_ser_i <= (others => '0');
                no_update <= '0';
            elsif (sg_ftch_error = '1' and no_update = '0') then
                no_update <= '1';
                dma_ch_ser_i (C_MAX_CHANNELS-1 downto 0) <= ch_mm2s_ftch_channel_id; 
      
            elsif (sg_updt_error = '1' and no_update = '0') then
                no_update <= '1';
                dma_ch_ser_i (C_MAX_CHANNELS-1 downto 0) <= ch_mm2s_updt_channel_id; 

            elsif (no_update = '0' and channel_in /= x"0000") then
                dma_ch_ser_i (C_MAX_CHANNELS-1 downto 0) <= channel_in; 
            end if;
        end if;
    end process DMACH_SER_REGISTER;

dma_ch_ser <= dma_ch_ser_i;

-- channels serviced register

DMA_PKTSER_REGISTER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dma_ch_serviced_i <= (others => '0');
            elsif  (mm2s_ch_ser_reset = '1') then -- ensures it will not miss any values
                dma_ch_serviced_i <= mm2s_ch_serviced;
            else
                dma_ch_serviced_i <= dma_ch_serviced_i or mm2s_ch_serviced;
            end if;
        end if;
    end process DMA_PKTSER_REGISTER;

                dma_ch_serviced (C_MAX_CHANNELS-1 downto 0) <= dma_ch_serviced_i;
                dma_ch_serviced (31 downto C_MAX_CHANNELS) <= (others => '0');

DMA_INTR_REGISTER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dma_ch_intr_status (C_MAX_CHANNELS-1 downto 0) <= (others => '0');
            elsif (C_ENABLE_SINGLE_INTR = 0) then
                dma_ch_intr_status (C_MAX_CHANNELS-1 downto 0) <= intr_status;
            end if;
        end if;
    end process DMA_INTR_REGISTER;

    dma_ch_intr_status (31 downto C_MAX_CHANNELS) <= (others => '0');


-------------------------------------------------------------------------------
-- DMACR - Remainder of DMA Control Register
-------------------------------------------------------------------------------
--DMACR_REGISTER : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
                dmacr_i(MCDMACR_ERR_IRQEN_BIT
                        downto MCDMACR_RESERVED3_BIT)   <= (others => '0');

--            elsif(axi2ip_wrce(DMACR_INDEX) = '1' and C_ENABLE_SINGLE_INTR = 1)then
--                dmacr_i(MCDMACR_ERR_IRQEN_BIT              
--                        downto MCDMACR_RESERVED3_BIT)   <=  -- bit 7
--                                                        axi2ip_wrdata(MCDMACR_ERR_IRQEN_BIT)
--                                                        -- bit 6
--                                                        & axi2ip_wrdata(MCDMACR_DLY_IRQEN_BIT)
--                                                        -- bit 5
--                                                        & axi2ip_wrdata(MCDMACR_IOC_IRQEN_BIT)
--                                                        -- bit 4
--                                                        & '0'
--                                                        -- bits 3 downto 1
--                                                        & ZERO_VALUE(MCDMACR_RESERVED3_BIT);
--            end if;
--        end if;
--    end process DMACR_REGISTER;

-------------------------------------------------------------------------------
-- DMACR - Reset Bit
-------------------------------------------------------------------------------
DMACR_RESET : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(soft_reset_clr = '1')then
                dmacr_i(MCDMACR_RESET_BIT)  <= '0';
            -- If soft reset set in other channel then set
            -- reset bit here too
            elsif(soft_reset_in = '1')then
                dmacr_i(MCDMACR_RESET_BIT)  <= '1';

           -- If DMACR Write then pass axi lite write bus to DMARC reset bit
            elsif(soft_reset_i = '0' and axi2ip_wrce(DMACR_INDEX) = '1')then
                dmacr_i(MCDMACR_RESET_BIT)  <= axi2ip_wrdata(MCDMACR_RESET_BIT);

            end if;
        end if;
    end process DMACR_RESET;

soft_reset_i <= dmacr_i(MCDMACR_RESET_BIT);

-------------------------------------------------------------------------------
-- DMACR - Run/Stop Bit
-- A plain vanilla run stop; actual run stop moves to common register
-------------------------------------------------------------------------------
run_stop_clr <= '1' when error = '1'                -- MM2S DataMover Error
                      or error_in = '1'             -- MM2S Error
                      or stop_dma = '1'             -- Stop due to error
                      or soft_reset_i = '1'         -- MM2S Soft Reset
                      or soft_reset_in  = '1'       -- MM2S Soft Reset
           else '0';


DMACR_RUNSTOP : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dmacr_i(MCDMACR_RS_BIT)  <= '0';
            -- Clear on sg error (i.e. error) or other channel
            -- error (i.e. error_in) or dma error or soft reset
            elsif(run_stop_clr = '1')then
                dmacr_i(MCDMACR_RS_BIT)  <= '0';
            elsif(axi2ip_wrce(DMACR_INDEX) = '1')then
                dmacr_i(MCDMACR_RS_BIT)  <= axi2ip_wrdata(MCDMACR_RS_BIT);
            end if;
        end if;
    end process DMACR_RUNSTOP;

dma_run_stop <= dmacr_i(MCDMACR_RS_BIT);
mm2s_run_stop <= dmacr_i(MCDMACR_RS_BIT);

---------------------------------------------------------------------------
-- DMA Status Halted bit (BIT 0) - Set by dma controller indicating DMA
-- channel is halted.
---------------------------------------------------------------------------
DMASR_HALTED : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0' or halted_set = '1')then
                halted <= '1';
            elsif(halted_clr = '1')then
                halted <= '0';
            end if;
        end if;
    end process DMASR_HALTED;

mm2s_halted <= halted;

---------------------------------------------------------------------------
-- DMA Status Idle bit (BIT 1) - Set by dma controller indicating DMA
-- channel is IDLE waiting at tail pointer.  Update of Tail Pointer
-- will cause engine to resume.  Note: Halted channels return to a
-- reset condition.
-- this will now show only SG idle for a channel
---------------------------------------------------------------------------
DMASR_IDLE : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0'
            or idle_clr = '1'
            or halted_set = '1')then
                idle   <= '0';
            elsif(idle_set = '1')then
                idle   <= '1';
            end if;
        end if;
    end process DMASR_IDLE;

---------------------------------------------------------------------------
-- DMA Status Error bit (BIT 3)
-- Note: any error will cause entire engine to halt
---------------------------------------------------------------------------
error  <= dma_interr
            or dma_slverr
            or dma_decerr
            or sg_interr
            or sg_slverr
            or sg_decerr;
---- Map out to halt opposing channel
error_out   <= error;

-- Scatter Gather Error
--sg_ftch_error <= ftch_interr_set or ftch_slverr_set or ftch_decerr_set;

-- SG Update Errors or DMA errors assert flag on descriptor update
-- Used to latch current descriptor pointer
--sg_updt_error <= updt_interr_set or updt_slverr_set or updt_decerr_set
--              or dma_interr or dma_slverr or dma_decerr;


ERROR_LOG : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
               sg_ftch_error <= '0';
               sg_updt_error <= '0';
            else
               sg_ftch_error <= ftch_interr_set or ftch_slverr_set or ftch_decerr_set;
               sg_updt_error <= updt_interr_set or updt_slverr_set or updt_decerr_set
                                or dma_interr or dma_slverr or dma_decerr;
            end if;
        end if;
    end process ERROR_LOG;

---------------------------------------------------------------------------
-- DMA Status DMA Internal Error bit (BIT 4)
---------------------------------------------------------------------------
DMASR_DMAINTERR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dma_interr <= '0';
            elsif(dma_interr_set = '1' )then
                dma_interr <= '1';
            end if;
        end if;
    end process DMASR_DMAINTERR;

---------------------------------------------------------------------------
-- DMA Status DMA Slave Error bit (BIT 5)
---------------------------------------------------------------------------
DMASR_DMASLVERR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dma_slverr <= '0';

            elsif(dma_slverr_set = '1' )then
                dma_slverr <= '1';

            end if;
        end if;
    end process DMASR_DMASLVERR;

---------------------------------------------------------------------------
-- DMA Status DMA Decode Error bit (BIT 6)
---------------------------------------------------------------------------
DMASR_DMADECERR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                dma_decerr <= '0';

            elsif(dma_decerr_set = '1' )then
                dma_decerr <= '1';

            end if;
        end if;
    end process DMASR_DMADECERR;

---------------------------------------------------------------------------
-- DMA Status SG Internal Error bit (BIT 8)
-- (SG Mode only - trimmed at build time if simple mode)
---------------------------------------------------------------------------
DMASR_SGINTERR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                sg_interr <= '0';

            elsif(ftch_interr_set = '1' or updt_interr_set = '1')then
                sg_interr <= '1';


            end if;
        end if;
    end process DMASR_SGINTERR;

---------------------------------------------------------------------------
-- DMA Status SG Slave Error bit (BIT 9)
-- (SG Mode only - trimmed at build time if simple mode)
---------------------------------------------------------------------------
DMASR_SGSLVERR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                sg_slverr <= '0';

            elsif(ftch_slverr_set = '1' or updt_slverr_set = '1')then
                sg_slverr <= '1';

            end if;
        end if;
    end process DMASR_SGSLVERR;

---------------------------------------------------------------------------
-- DMA Status SG Decode Error bit (BIT 10)
-- (SG Mode only - trimmed at build time if simple mode)
-------------------------------------------------------------------------
DMASR_SGDECERR : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                sg_decerr <= '0';

            elsif(ftch_decerr_set = '1' or updt_decerr_set = '1')then
                sg_decerr <= '1';

            end if;
        end if;
    end process DMASR_SGDECERR;

---------------------------------------------------------------------------
-- DMA Status IOC Interrupt status bit (BIT 11)
---------------------------------------------------------------------------
--DMASR_IOCIRQ : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
                ioc_irq <= '0';
--
--            -- CPU Writing a '1' to clear - OR'ed with setting to prevent
--            -- missing a 'set' during the write.
--            elsif(axi2ip_wrce(DMASR_INDEX) = '1' and C_ENABLE_SINGLE_INTR = 1)then
--
--                ioc_irq <= (ioc_irq and not(axi2ip_wrdata(MCDMASR_IOCIRQ_BIT)))
--                             or ioc_irq_set;
--
--            elsif(ioc_irq_set = '1' and C_ENABLE_SINGLE_INTR = 1)then
--                ioc_irq <= '1';
--
--            end if;
--        end if;
--    end process DMASR_IOCIRQ;

---------------------------------------------------------------------------
-- DMA Status Delay Interrupt status bit (BIT 12)
---------------------------------------------------------------------------
--DMASR_DLYIRQ : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
                dly_irq <= '0';

--            -- CPU Writing a '1' to clear - OR'ed with setting to prevent
--            -- missing a 'set' during the write.
--            elsif(axi2ip_wrce(DMASR_INDEX) = '1' and C_ENABLE_SINGLE_INTR = 1)then
--
--                dly_irq <= (dly_irq and not(axi2ip_wrdata(MCDMASR_DLYIRQ_BIT)))
--                             or dly_irq_set;
--
--            elsif(dly_irq_set = '1' and C_ENABLE_SINGLE_INTR = 1)then
--                dly_irq <= '1';
--
--            end if;
--        end if;
--    end process DMASR_DLYIRQ;

-- CR605888 Disable delay timer if halted or on delay irq set
--dlyirq_dsble    <= dmasr_i(DMASR_HALTED_BIT)              -- CR606348

-- kapil : need to get the real RS here
dlyirq_dsble    <= (not dma_run_stop                -- CR606348
                    or dmasr_i(MCDMASR_DLYIRQ_BIT));-- and (C_ENABLE_SINGLE_INTR = 1);



---------------------------------------------------------------------------
-- DMA Status Error Interrupt status bit (BIT 12)
---------------------------------------------------------------------------
-- Delay error setting for generation of error strobe
GEN_ERROR_RE : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                error_d1 <= '0';
            else
                error_d1 <= error;
            end if;
        end if;
    end process GEN_ERROR_RE;

-- Generate rising edge pulse on error
error_re   <= error and not error_d1;

--DMASR_ERRIRQ : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
                err_irq <= '0';

--            -- CPU Writing a '1' to clear - OR'ed with setting to prevent
--            -- missing a 'set' during the write.
--            elsif(axi2ip_wrce(DMASR_INDEX) = '1' and C_ENABLE_SINGLE_INTR = 1)then
--
--                err_irq <= (err_irq and not(axi2ip_wrdata(MCDMASR_ERRIRQ_BIT)))
--                             or error_re;
--
--            elsif(error_re = '1' and C_ENABLE_SINGLE_INTR = 1)then
--                err_irq <= '1';
--
--            end if;
--        end if;
--    end process DMASR_ERRIRQ;



---------------------------------------------------------------------------
-- DMA Interrupt OUT
---------------------------------------------------------------------------
--REG_INTR : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0' or soft_reset_i = '1')then
                introut <= '0';
--            elsif (C_ENABLE_SINGLE_INTR = 1) then
--                introut <= (dly_irq and dmacr_i(MCDMACR_DLY_IRQEN_BIT))
--                        or (ioc_irq and dmacr_i(MCDMACR_IOC_IRQEN_BIT))
--                        or (err_irq and dmacr_i(MCDMACR_ERR_IRQEN_BIT));
--            else
--                introut <= '0';
--            end if;
--        end if;
--    end process;

---------------------------------------------------------------------------
-- DMA Status Register
---------------------------------------------------------------------------
dmasr_i    <=  irqdelay_status         -- Bits 31 downto 24
             & irqthresh_status        -- Bits 23 downto 16
             & pktirqthresh_status     -- Bit  15 downto 8
             & err_irq          -- Bit  7
             & dly_irq          -- Bit  6
             & ioc_irq          -- Bit  5
             & '0'              -- Bit  4
             & '0'        -- Bit  3
             & '0'        -- Bit  2
             & idle              -- Bit  1
             & halted;    -- Bit 0  


dmaerr_i <= "0000000000000000000000000"
            &   sg_decerr
            &   sg_slverr
            &   sg_interr
            &   '0'
            &   dma_decerr
            &   dma_slverr
            &   dma_interr;

end implementation;



--  (c) Copyright 2012 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;


entity axi_mcdma_read_mux is
     port (
           m_axi_sg_aclk                 : in std_logic;
           m_axi_sg_aresetn              : in std_logic;
           read_addr                     : in std_logic_vector (4 downto 0);
           channel_dmacr                 : in std_logic_vector (31 downto 0);
           channel_dmasr                 : in std_logic_vector (31 downto 0);
           channel_cd_lsb                 : in std_logic_vector (31 downto 0);
           channel_cd_msb                 : in std_logic_vector (31 downto 0);
           channel_td_lsb                 : in std_logic_vector (31 downto 0);
           channel_td_msb                 : in std_logic_vector (31 downto 0);
           channel_pktdrp_count           : in std_logic_vector (15 downto 0);
           channel_pktproc_count          : in std_logic_vector (15 downto 0);
           reg_out                        : out std_logic_vector (31 downto 0)
          );
end entity axi_mcdma_read_mux;

architecture implementation of axi_mcdma_read_mux is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";



begin


    READ_MUX : process(read_addr(4 downto 0)            ,
                       channel_dmacr ,
                       channel_dmasr,
                       channel_cd_lsb,
                       channel_cd_msb,
                       channel_td_lsb,
                       channel_td_msb,
                       channel_pktdrp_count,
                       channel_pktproc_count
                      )
        begin
            case read_addr(4 downto 0) is

                when S2MM_CH_DMACR_OFFSET        =>
                    reg_out <= channel_dmacr;
                when S2MM_CH_DMASR_OFFSET        =>
                    reg_out <= channel_dmasr;
                when S2MM_CH_CURDESC_LSB_OFFSET  =>
                    reg_out <= channel_cd_lsb;
                when S2MM_CH_CURDESC_MSB_OFFSET  =>
                    reg_out <= channel_cd_msb;
                when S2MM_CH_TAILDESC_LSB_OFFSET =>
                    reg_out <= channel_td_lsb;
                when S2MM_CH_TAILDESC_MSB_OFFSET =>
                    reg_out <= channel_td_msb;
                when S2MM_CH_PKTDRP_OFFSET =>
                    reg_out <= x"0000" & channel_pktdrp_count;
                when S2MM_CH_PKTPROC_OFFSET =>
                    reg_out <= x"0000" & channel_pktproc_count;
          -- coverage off
                when others =>
                    reg_out <= (others => '0');
          -- coverage on
             end case;
      end process READ_MUX;


end implementation;


-------------------------------------------------------------------------------
-- axi_mcdma_reg_module
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_mcdma_reg_module.vhd
-- Description: This entity is AXI DMA Register Module Top Level
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;
use ieee.std_logic_misc.or_reduce;

library unisim;
use unisim.vcomponents.all;

library lib_cdc_v1_0_2;
library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_mcdma_reg_module is
    generic(
        C_INCLUDE_MM2S              : integer range 0 to 1      := 1        ;
        C_INCLUDE_S2MM              : integer range 0 to 1      := 1        ;
        C_INCLUDE_SG                : integer range 0 to 1      := 1        ;
        C_NUM_MM2S_CHANNELS         : integer range 1 to 16     := 1        ;
        C_NUM_S2MM_CHANNELS         : integer range 1 to 16     := 1        ;
        C_ENABLE_SINGLE_INTR        : integer range 0 to 1      := 0        ;   
        C_SG_LENGTH_WIDTH           : integer range 8 to 23     := 14       ;
        C_AXI_LITE_IS_ASYNC         : integer range 0 to 1      := 0        ;
        C_S_AXI_LITE_ADDR_WIDTH     : integer    := 32       ;
        C_MAX_CHANNELS              : integer range 1 to 16     := 1        ;
        C_S_AXI_LITE_DATA_WIDTH     : integer range 32 to 32    := 32       ;
        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 64    := 32       ;
        C_ACTUAL_ADDR_WIDTH         : integer range 32 to 64    := 32       ;
        C_M_AXI_MM2S_ADDR_WIDTH     : integer range 32 to 64    := 32       ;
        C_M_AXI_S2MM_ADDR_WIDTH     : integer range 32 to 64    := 32       ;
        C_MM2S_SCHEDULE             : integer range 0 to 3      := 1        ;
        C_GROUP1_MM2S               : std_logic_vector (15 downto 0) := x"FFFF";
        C_GROUP2_MM2S               : std_logic_vector (15 downto 0) := x"0000";
        C_GROUP3_MM2S               : std_logic_vector (15 downto 0) := x"0000";
        C_GROUP4_MM2S               : std_logic_vector (15 downto 0) := x"0000";
        C_GROUP5_MM2S               : std_logic_vector (15 downto 0) := x"0000";
        C_GROUP6_MM2S               : std_logic_vector (15 downto 0) := x"0000";
        C_GROUP1_S2MM               : std_logic_vector (15 downto 0) := x"FFFF";
        C_GROUP2_S2MM               : std_logic_vector (15 downto 0) := x"0000";
        C_GROUP3_S2MM               : std_logic_vector (15 downto 0) := x"0000";
        C_GROUP4_S2MM               : std_logic_vector (15 downto 0) := x"0000";
        C_GROUP5_S2MM               : std_logic_vector (15 downto 0) := x"0000";
        C_GROUP6_S2MM               : std_logic_vector (15 downto 0) := x"0000"
    );
    port (
        -----------------------------------------------------------------------
        -- AXI Lite Control Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               : in  std_logic                         ;                   --
        m_axi_sg_aresetn            : in  std_logic                         ;                   --
        m_axi_sg_hrdresetn          : in  std_logic                         ;                   --
                                                                                                --
        s_axi_lite_aclk             : in  std_logic                         ;                   --
        axi_lite_reset_n            : in  std_logic                         ;                   --
                                                                                                --
        -- AXI Lite Write Address Channel                                                       --
        s_axi_lite_awvalid          : in  std_logic                         ;                   --
        s_axi_lite_awready          : out std_logic                         ;                   --
        s_axi_lite_awaddr           : in  std_logic_vector                                      --
                                        (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0);                   --
                                                                                                --
        -- AXI Lite Write Data Channel                                                          --
        s_axi_lite_wvalid           : in  std_logic                         ;                   --
        s_axi_lite_wready           : out std_logic                         ;                   --
        s_axi_lite_wdata            : in  std_logic_vector                                      --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);                   --
                                                                                                --
        -- AXI Lite Write Response Channel                                                      --
        s_axi_lite_bresp            : out std_logic_vector(1 downto 0)      ;                   --
        s_axi_lite_bvalid           : out std_logic                         ;                   --
        s_axi_lite_bready           : in  std_logic                         ;                   --
                                                                                                --
        -- AXI Lite Read Address Channel                                                        --
        s_axi_lite_arvalid          : in  std_logic                         ;                   --
        s_axi_lite_arready          : out std_logic                         ;                   --
        s_axi_lite_araddr           : in  std_logic_vector                                      --
                                        (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0);                   --
        s_axi_lite_rvalid           : out std_logic                         ;                   --
        s_axi_lite_rready           : in  std_logic                         ;                   --
        s_axi_lite_rdata            : out std_logic_vector                                      --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);                   --
        s_axi_lite_rresp            : out std_logic_vector(1 downto 0)      ;                   --
                                                                                                --
        sg_user_cache               : out std_logic_vector(31 downto 0);
                                                                                                --
        -- MM2S Signals                                                                         --
        mm2s_stop                   : in  std_logic                         ;                   --
        mm2s_halted_clr             : in  std_logic                         ;                   --
        mm2s_halted_set             : in  std_logic                         ;                   --
        mm2s_idle_set               : in  std_logic                         ;                   --
        mm2s_idle_clr               : in  std_logic                         ;                   --
        mm2s_dma_interr_set         : in  std_logic                         ;                   --
        mm2s_dma_slverr_set         : in  std_logic                         ;                   --
        mm2s_dma_decerr_set         : in  std_logic                         ;                   --
        mm2s_ioc_irq_set            : in  std_logic                         ;                   --
        mm2s_dly_irq_set            : in  std_logic                         ;                   --
        mm2s_irqdelay_status        : in  std_logic_vector(7 downto 0)      ;                   --
        mm2s_irqthresh_status       : in  std_logic_vector(7 downto 0)      ;                   --
        mm2s_ftch_interr_set        : in  std_logic                         ;                   --
        mm2s_ftch_slverr_set        : in  std_logic                         ;                   --
        mm2s_ftch_decerr_set        : in  std_logic                         ;                   --
        mm2s_updt_interr_set        : in  std_logic                         ;                   --
        mm2s_updt_slverr_set        : in  std_logic                         ;                   --
        mm2s_updt_decerr_set        : in  std_logic                         ;                   --
        mm2s_dlyirq_dsble           : out std_logic                         ; -- CR605888       --
        mm2s_irqthresh_rstdsbl      : out std_logic                         ; -- CR572013       --
        mm2s_irqthresh_wren         : out std_logic                         ;                   --
        mm2s_irqdelay_wren          : out std_logic                         ;                   --
        mm2s_tailpntr_updated       : out std_logic                         ;                   --
        mm2s_dmacr                  : out std_logic_vector                                      --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);                   --
        mm2s_dmasr                  : out std_logic_vector                                      --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);                   --

        mm2s_ch_stop                   : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        mm2s_ch_halted_clr             : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        mm2s_ch_halted_set             : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        mm2s_ch_idle_set               : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        mm2s_ch_idle_clr               : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        mm2s_ch_dma_interr_set         : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        mm2s_ch_dma_slverr_set         : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        mm2s_ch_dma_decerr_set         : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        mm2s_ch_ioc_irq_set            : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        mm2s_ch_dly_irq_set            : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        mm2s_ch_sg_idle                : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;
        mm2s_ch_irqdelay_status        : in  std_logic_vector(8*C_MAX_CHANNELS-1 downto 0)      ;                   --
        mm2s_ch_irqthresh_status       : in  std_logic_vector(8*C_MAX_CHANNELS-1 downto 0)      ;                   --
        mm2s_ch_pktcount               : in  std_logic_vector(16*C_MAX_CHANNELS-1 downto 0)     ;
        mm2s_ch_ftch_interr_set        : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        mm2s_ch_ftch_slverr_set        : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        mm2s_ch_ftch_decerr_set        : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        mm2s_ch_updt_interr_set        : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        mm2s_ch_updt_slverr_set        : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        mm2s_ch_updt_decerr_set        : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        mm2s_ch_new_curdesc_wren       : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        mm2s_ch_new_curdesc            : in  std_logic_vector                                      --
                                       (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                   --
        mm2s_ch_dlyirq_dsble           : out std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ; -- CR605888       --
        mm2s_ch_irqthresh_rstdsbl      : out std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ; -- CR572013       --
        mm2s_ch_irqthresh_wren         : out std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        mm2s_ch_irqdelay_wren          : out std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        mm2s_ch_tailpntr_updated       : out std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        mm2s_ch_dmacr                  : out std_logic_vector                                      --
                                       (C_MAX_CHANNELS*C_S_AXI_LITE_DATA_WIDTH-1 downto 0);                   --
        mm2s_ch_dmasr                  : out std_logic_vector                                      --
                                       (C_MAX_CHANNELS*C_S_AXI_LITE_DATA_WIDTH-1 downto 0);                   --
        mm2s_ch_curdesc                : out std_logic_vector                                      --
                                       (C_MAX_CHANNELS*C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                   --
        mm2s_ch_taildesc               : out std_logic_vector                                      --
                                        (C_MAX_CHANNELS*C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                   --
        mm2s_channel_enable         : out std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        mm2s_ch_serviced            : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        mm2s_channel_id             : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        mm2s_schedule               : out std_logic_vector(31 downto 0);
        mm2s_ch_weight              : out std_logic_vector(31 downto 0);
        mm2s_ch_weight_2            : out std_logic_vector(31 downto 0);
        mm2s_user_cache             : out std_logic_vector(15 downto 0);
                                                                                                --
        -- S2MM Signals                                                                         --
        s2mm_stop                   : in  std_logic                         ;                   --
        s2mm_halted_clr             : in  std_logic                         ;                   --
        s2mm_halted_set             : in  std_logic                         ;                   --
        s2mm_idle_set               : in  std_logic                         ;                   --
        s2mm_idle_clr               : in  std_logic                         ;                   --
        s2mm_dma_interr_set         : in  std_logic                         ;                   --
        s2mm_dma_slverr_set         : in  std_logic                         ;                   --
        s2mm_dma_decerr_set         : in  std_logic                         ;                   --
        s2mm_ioc_irq_set            : in  std_logic                         ;                   --
        s2mm_pktdrp_irq_set         : in  std_logic                         ;                   --
        s2mm_pktirqthresh_status    : in  std_logic_vector(7 downto 0)      ;                   --
        s2mm_pktirqthresh_wren      : out std_logic                         ;                   --
        pktdrp_count_in             : in  std_logic_vector (31 downto 0); 
        s2mm_dly_irq_set            : in  std_logic                         ;                   --
        s2mm_sg_idle                : in  std_logic                         ;
        s2mm_irqdelay_status        : in  std_logic_vector(7 downto 0)      ;                   --
        s2mm_irqthresh_status       : in  std_logic_vector(7 downto 0)      ;                   --
        s2mm_ftch_interr_set        : in  std_logic                         ;                   --
        s2mm_ftch_slverr_set        : in  std_logic                         ;                   --
        s2mm_ftch_decerr_set        : in  std_logic                         ;                   --
        s2mm_updt_interr_set        : in  std_logic                         ;                   --
        s2mm_updt_slverr_set        : in  std_logic                         ;                   --
        s2mm_updt_decerr_set        : in  std_logic                         ;                   --
        s2mm_dlyirq_dsble           : out std_logic                         ; -- CR605888       --
        s2mm_irqthresh_rstdsbl      : out std_logic                         ; -- CR572013       --
        s2mm_irqthresh_wren         : out std_logic                         ;                   --
        s2mm_irqdelay_wren          : out std_logic                         ;                   --
        s2mm_channel_id             : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        s2mm_channel_id_run             : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        s2mm_channel_enable         : out std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        s2mm_ch_serviced            : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        s2mm_user_cache             : out std_logic_vector(15 downto 0);
        s2mm_dmacr                  : out std_logic_vector                                      --
                                    (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);                   --
        s2mm_dmasr                  : out std_logic_vector                                      --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);                   --


        s2mm_ch_stop                   : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_halted_clr             : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_halted_set             : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_idle_set               : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_idle_clr               : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_dma_interr_set         : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_dma_slverr_set         : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_dma_decerr_set         : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_ioc_irq_set            : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_pktdrp_irq_set         : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_pktirqthresh_status    : in  std_logic_vector (8*C_MAX_CHANNELS-1 downto 0)      ;                   --
        s2mm_ch_pktirqthresh_wren      : out std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_pktdrp_count           : in  std_logic_vector (16*C_MAX_CHANNELS-1 downto 0);
        s2mm_ch_pktdrp_reset           : out std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;
        s2mm_ch_dly_irq_set            : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_sg_idle                : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;
        s2mm_ch_irqdelay_status        : in  std_logic_vector (8*C_MAX_CHANNELS-1 downto 0)      ;                   --
        s2mm_ch_irqthresh_status       : in  std_logic_vector (8*C_MAX_CHANNELS-1 downto 0)      ;                   --
        s2mm_ch_pktcount               : in  std_logic_vector(16*C_MAX_CHANNELS-1 downto 0)     ;
        s2mm_ch_ftch_interr_set        : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_ftch_slverr_set        : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_ftch_decerr_set        : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_updt_interr_set        : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_updt_slverr_set        : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_updt_decerr_set        : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_new_curdesc_wren       : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_new_curdesc            : in  std_logic_vector                                      --
                                       (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                   --
        s2mm_ch_dlyirq_dsble           : out std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ; -- CR605888       --
        s2mm_ch_irqthresh_rstdsbl      : out std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ; -- CR572013       --
        s2mm_ch_irqthresh_wren         : out std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_irqdelay_wren          : out std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_tailpntr_updated       : out std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_ch_dmacr                  : out std_logic_vector                                      --
                                       (C_MAX_CHANNELS*C_S_AXI_LITE_DATA_WIDTH-1 downto 0);                   --
        s2mm_ch_dmasr                  : out std_logic_vector                                      --
                                       (C_MAX_CHANNELS*C_S_AXI_LITE_DATA_WIDTH-1 downto 0);                   --
        s2mm_ch_curdesc                : out std_logic_vector                                      --
                                       (C_MAX_CHANNELS*C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                   --
        s2mm_ch_taildesc               : out std_logic_vector                                      --
                                        (C_MAX_CHANNELS*C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                   --


                                                                                                --
        soft_reset                  : out std_logic                         ;                   --
        soft_reset_clr              : in  std_logic                         ;                   --
                                                                                                --
        -- Fetch/Update error addresses                                                         --
        ftch_error_addr             : in  std_logic_vector                                      --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                   --
        updt_error_addr             : in  std_logic_vector                                      --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                   --

        ch_s2mm_ftch_channel_id     : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        ch_s2mm_updt_channel_id     : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        ch_mm2s_ftch_channel_id     : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        ch_mm2s_updt_channel_id     : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);

        mm2s_introut                : out std_logic                         ;                   --
        mm2s_ch_introut                : out std_logic_vector(C_MAX_CHANNELS-1 downto 0)                         ;                   --
        s2mm_introut                : out std_logic                             ;                --
        s2mm_ch_introut                : out std_logic_vector(C_MAX_CHANNELS-1 downto 0)                                             --


    );
end axi_mcdma_reg_module;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_reg_module is

  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";


-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
constant LENGTH_PAD_WIDTH   : integer := C_S_AXI_LITE_DATA_WIDTH - C_SG_LENGTH_WIDTH;
constant LENGTH_PAD         : std_logic_vector(LENGTH_PAD_WIDTH-1 downto 0) := (others => '0');

constant ZERO_BYTES         : std_logic_vector(C_SG_LENGTH_WIDTH-1 downto 0) := (others => '0');

-- Specifies to axi_mcdma_register which block belongs to S2MM channel
-- so simple dma s2mm_da register offset can be correctly assigned
-- CR603034
--constant NOT_S2MM_CHANNEL   : integer := 0;
--constant IS_S2MM_CHANNEL    : integer := 1;

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal axi2ip_wrce          : std_logic_vector(NUM_REG_TOTAL - 1 downto 0)      := (others => '0');
signal axi2ip_wrdata        : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal axi2ip_rdce          : std_logic_vector(NUM_REG_TOTAL - 1 downto 0)      := (others => '0');
signal axi2ip_rdaddr        : std_logic_vector(C_S_AXI_LITE_ADDR_WIDTH-1 downto 0) := (others => '0');
signal ip2axi_rddata        : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal ip2axi_rddata_mm2s        : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal ip2axi_rddata_s2mm_cmn    : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal ip2axi_rddata_s2mm_ch        : std_logic_vector(17*C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal ip2axi_rddata_s2mm_ch1        : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal ip2axi_rddata_s2mm_ch2        : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal ip2axi_rddata_s2mm_ch3        : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal ip2axi_rddata_s2mm_ch4        : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal ip2axi_rddata_s2mm_ch5        : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal ip2axi_rddata_mm2s_cmn    : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal ip2axi_rddata_mm2s_ch        : std_logic_vector(17*C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal ip2axi_rddata_mm2s_ch1        : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal ip2axi_rddata_mm2s_ch2        : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal ip2axi_rddata_mm2s_ch3        : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal ip2axi_rddata_mm2s_ch4        : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal ip2axi_rddata_mm2s_ch5        : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');

signal mm2s_dmacr_i         : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal mm2s_dmasr_i         : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal mm2s_curdesc_lsb_i   : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal mm2s_curdesc_msb_i   : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal mm2s_taildesc_lsb_i  : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal mm2s_taildesc_msb_i  : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal mm2s_error_in        : std_logic := '0';
signal mm2s_error_out       : std_logic := '0';
signal mm2s_introut_i_cdc_from       : std_logic := '0';
signal mm2s_introut_to      : std_logic := '0';


signal s2mm_dmacr_i         : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal s2mm_dmasr_i         : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal s2mm_curdesc_lsb_i   : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal s2mm_curdesc_msb_i   : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal s2mm_taildesc_lsb_i  : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal s2mm_taildesc_msb_i  : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal s2mm_error_in        : std_logic := '0';
signal s2mm_error_out       : std_logic := '0';
signal s2mm_introut_i_cdc_from       : std_logic := '0';
signal s2mm_introut_to      : std_logic := '0';

signal s2mm_ch_dmacr_i         : std_logic_vector(C_MAX_CHANNELS*C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal s2mm_ch_dmasr_i         : std_logic_vector(C_MAX_CHANNELS*C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal s2mm_ch_curdesc_lsb_i   : std_logic_vector(C_MAX_CHANNELS*C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal s2mm_ch_curdesc_msb_i   : std_logic_vector(C_MAX_CHANNELS*C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal s2mm_ch_taildesc_lsb_i  : std_logic_vector(C_MAX_CHANNELS*C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal s2mm_ch_taildesc_lsb_i_rd  : std_logic_vector(C_MAX_CHANNELS*C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal s2mm_ch_taildesc_msb_i  : std_logic_vector(C_MAX_CHANNELS*C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');

signal mm2s_ch_dmacr_i         : std_logic_vector(C_MAX_CHANNELS*C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal mm2s_ch_dmasr_i         : std_logic_vector(C_MAX_CHANNELS*C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal mm2s_ch_curdesc_lsb_i   : std_logic_vector(C_MAX_CHANNELS*C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal mm2s_ch_curdesc_msb_i   : std_logic_vector(C_MAX_CHANNELS*C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal mm2s_ch_taildesc_lsb_i  : std_logic_vector(C_MAX_CHANNELS*C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal mm2s_ch_taildesc_lsb_i_rd  : std_logic_vector(C_MAX_CHANNELS*C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal mm2s_ch_taildesc_msb_i  : std_logic_vector(C_MAX_CHANNELS*C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');



signal read_addr            : std_logic_vector(11 downto 0) := (others => '0');

signal enable_channels       : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal enable_channels_mm2s       : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal dma_ch_under_service  : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal dma_ch_under_service_mm2s  : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal dma_pkt_drp_count     : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal dma_errors           : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal dma_errors_mm2s           : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal dma_ch_serviced           : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');
signal dma_ch_serviced_mm2s           : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');

signal ch_pkt_rst : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_introut_i_cdc_from : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_introut_to_cmn : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_introut_to : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_error_out : std_logic_vector (C_MAX_CHANNELS-1 downto 0);

signal s2mm_ch_introut_i_cdc_from : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_introut_to_cmn : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_introut_to : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_error_out : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_error_or : std_logic;
signal mm2s_ch_error_or : std_logic;
signal error_or : std_logic;

signal mm2s_sch_int : std_logic_vector (31 downto 0);
signal channel_weight_int : std_logic_vector (31 downto 0);
signal channel_weight_2_int : std_logic_vector (31 downto 0);

signal s2mm_ch_ser_reset : std_logic;
signal mm2s_ch_ser_reset : std_logic;

signal sg_user_cache_int : std_logic_vector (31 downto 0);
signal mm2s_user_cache_int : std_logic_vector (31 downto 0);
signal s2mm_user_cache_int : std_logic_vector (31 downto 0);

signal s2mm_ch_intr_status : std_logic_vector (31 downto 0);
signal mm2s_ch_intr_status : std_logic_vector (31 downto 0);

signal mm2s_gr_1_clr : std_logic;
signal mm2s_gr_2_clr : std_logic;
signal mm2s_gr_3_clr : std_logic;
signal mm2s_gr_4_clr : std_logic;
signal mm2s_gr_5_clr : std_logic;
signal mm2s_gr_6_clr : std_logic;
signal mm2s_gr_1   : std_logic_vector (31 downto 0); 
signal mm2s_gr_2   : std_logic_vector (31 downto 0); 
signal mm2s_gr_3   : std_logic_vector (31 downto 0); 
signal mm2s_gr_4   : std_logic_vector (31 downto 0); 
signal mm2s_gr_5   : std_logic_vector (31 downto 0); 
signal mm2s_gr_6   : std_logic_vector (31 downto 0); 
             
signal s2mm_gr_1_clr : std_logic;
signal s2mm_gr_2_clr : std_logic;
signal s2mm_gr_3_clr : std_logic;
signal s2mm_gr_4_clr : std_logic;
signal s2mm_gr_5_clr : std_logic;
signal s2mm_gr_6_clr : std_logic;
signal s2mm_gr_1   : std_logic_vector (31 downto 0); 
signal s2mm_gr_2   : std_logic_vector (31 downto 0); 
signal s2mm_gr_3   : std_logic_vector (31 downto 0); 
signal s2mm_gr_4   : std_logic_vector (31 downto 0); 
signal s2mm_gr_5   : std_logic_vector (31 downto 0); 
signal s2mm_gr_6   : std_logic_vector (31 downto 0); 
signal ip2axi_rddata_mm2s_obs_ch : std_logic_vector (31 downto 0); 
signal ip2axi_rddata_s2mm_obs_ch : std_logic_vector (31 downto 0); 
-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

error_or <= s2mm_ch_error_or or mm2s_ch_error_or;

mm2s_dmacr      <= mm2s_dmacr_i;        -- MM2S DMA Control Register
mm2s_dmasr      <= mm2s_dmasr_i;        -- MM2S DMA Status Register

s2mm_dmacr      <= s2mm_dmacr_i;        -- S2MM DMA Control Register
s2mm_dmasr      <= s2mm_dmasr_i;        -- S2MM DMA Status Register

s2mm_ch_dmacr      <= s2mm_ch_dmacr_i;        -- S2MM DMA Control Register
s2mm_ch_dmasr      <= s2mm_ch_dmasr_i;        -- S2MM DMA Status Register

mm2s_ch_dmacr      <= mm2s_ch_dmacr_i;        -- S2MM DMA Control Register
mm2s_ch_dmasr      <= mm2s_ch_dmasr_i;        -- S2MM DMA Status Register

s2mm_irqthresh_rstdsbl <= not s2mm_dmacr_i (MCDMACR_DLY_IRQEN_BIT);
mm2s_irqthresh_rstdsbl <= not mm2s_dmacr_i (MCDMACR_DLY_IRQEN_BIT);

-- Soft reset set in mm2s DMACR or s2MM DMACR
soft_reset      <= mm2s_dmacr_i(MCDMACR_RESET_BIT)
                or s2mm_dmacr_i(MCDMACR_RESET_BIT);


-- CR572013 - added to match legacy SDMA operation
RSTDSBL_GEN : for I in 0 to C_MAX_CHANNELS-1 generate
begin
mm2s_ch_irqthresh_rstdsbl(I) <= not mm2s_ch_dmacr_i(CHDMACR_DLY_IRQEN_BIT+32*I);
s2mm_ch_irqthresh_rstdsbl(I) <= not s2mm_ch_dmacr_i(CHDMACR_DLY_IRQEN_BIT+32*I);

end generate RSTDSBL_GEN;


-- For 32 bit address map only lsb registers out
GEN_DESC_ADDR_EQL32 : if C_M_AXI_SG_ADDR_WIDTH = 32 generate
begin
    mm2s_ch_curdesc    <= mm2s_ch_curdesc_lsb_i;
    mm2s_ch_taildesc   <= mm2s_ch_taildesc_lsb_i;

    s2mm_ch_curdesc    <= s2mm_ch_curdesc_lsb_i;
    s2mm_ch_taildesc   <= s2mm_ch_taildesc_lsb_i;

    
end generate GEN_DESC_ADDR_EQL32;

-- For 64 bit address map lsb and msb registers out
GEN_DESC_ADDR_EQL64 : if C_M_AXI_SG_ADDR_WIDTH = 64 generate
begin

ADDR_APPEND : for I in 0 to C_MAX_CHANNELS-1 generate
begin

    mm2s_ch_curdesc(64*I+32-1 downto 64*I)       <= mm2s_ch_curdesc_lsb_i(32*I+32-1 downto 32*I);
    mm2s_ch_curdesc(64*I+64-1 downto 64*I+32)    <= mm2s_ch_curdesc_msb_i(32*I+32-1 downto 32*I);

    mm2s_ch_taildesc(64*I+32-1 downto 64*I)      <= mm2s_ch_taildesc_lsb_i(32*I+32-1 downto 32*I);
    mm2s_ch_taildesc(64*I+64-1 downto 64*I+32)   <= mm2s_ch_taildesc_msb_i(32*I+32-1 downto 32*I);

    s2mm_ch_curdesc(64*I+32-1 downto 64*I)       <= s2mm_ch_curdesc_lsb_i(32*I+32-1 downto 32*I);
    s2mm_ch_curdesc(64*I+64-1 downto 64*I+32)    <= s2mm_ch_curdesc_msb_i(32*I+32-1 downto 32*I);

    s2mm_ch_taildesc(64*I+32-1 downto 64*I)      <= s2mm_ch_taildesc_lsb_i(32*I+32-1 downto 32*I);
    s2mm_ch_taildesc(64*I+64-1 downto 64*I+32)   <= s2mm_ch_taildesc_msb_i(32*I+32-1 downto 32*I);
end generate ADDR_APPEND;
end generate GEN_DESC_ADDR_EQL64;

-------------------------------------------------------------------------------
-- Generate AXI Lite Inteface
-------------------------------------------------------------------------------
GEN_AXI_LITE_IF : if C_INCLUDE_MM2S = 1 or C_INCLUDE_S2MM = 1 generate
begin
    AXI_LITE_IF_I : entity axi_mcdma_v1_1_8.axi_mcdma_lite_if
        generic map(
            C_NUM_CE                    => NUM_REG_TOTAL            ,
            C_AXI_LITE_IS_ASYNC         => C_AXI_LITE_IS_ASYNC      ,
            C_S_AXI_LITE_ADDR_WIDTH     => C_S_AXI_LITE_ADDR_WIDTH  ,
            C_S_AXI_LITE_DATA_WIDTH     => C_S_AXI_LITE_DATA_WIDTH
        )
        port map(
            ip2axi_aclk                 => m_axi_sg_aclk            ,
            ip2axi_aresetn              => m_axi_sg_hrdresetn       ,

            s_axi_lite_aclk             => s_axi_lite_aclk          ,
            s_axi_lite_aresetn          => axi_lite_reset_n         ,

            -- AXI Lite Write Address Channel
            s_axi_lite_awvalid          => s_axi_lite_awvalid       ,
            s_axi_lite_awready          => s_axi_lite_awready       ,
            s_axi_lite_awaddr           => s_axi_lite_awaddr        ,

            -- AXI Lite Write Data Channel
            s_axi_lite_wvalid           => s_axi_lite_wvalid        ,
            s_axi_lite_wready           => s_axi_lite_wready        ,
            s_axi_lite_wdata            => s_axi_lite_wdata         ,

            -- AXI Lite Write Response Channel
            s_axi_lite_bresp            => s_axi_lite_bresp         ,
            s_axi_lite_bvalid           => s_axi_lite_bvalid        ,
            s_axi_lite_bready           => s_axi_lite_bready        ,

            -- AXI Lite Read Address Channel
            s_axi_lite_arvalid          => s_axi_lite_arvalid       ,
            s_axi_lite_arready          => s_axi_lite_arready       ,
            s_axi_lite_araddr           => s_axi_lite_araddr        ,
            s_axi_lite_rvalid           => s_axi_lite_rvalid        ,
            s_axi_lite_rready           => s_axi_lite_rready        ,
            s_axi_lite_rdata            => s_axi_lite_rdata         ,
            s_axi_lite_rresp            => s_axi_lite_rresp         ,

            -- User IP Interface
            axi2ip_wrce                 => axi2ip_wrce              ,
            axi2ip_wrdata               => axi2ip_wrdata            ,

            axi2ip_rdce                 => axi2ip_rdce              ,
            axi2ip_rdaddr               => axi2ip_rdaddr            ,
            ip2axi_rddata               => ip2axi_rddata

        );
end generate GEN_AXI_LITE_IF;


PKT_RST : for I in 0 to C_MAX_CHANNELS-1 generate
begin
ch_pkt_rst(I) <= axi2ip_rdce (S2MM_CH1_LOW_INDEX+16*I+6);

end generate PKT_RST;


process(m_axi_sg_aclk)
begin
     if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
         if (m_axi_sg_aresetn = '0') then
            s2mm_ch_pktdrp_reset <= (others => '0');
         else
            s2mm_ch_pktdrp_reset <= ch_pkt_rst;
          end if;
       end if;
end process;


--process(m_axi_sg_aclk)
--begin
--     if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
--         if (m_axi_sg_aresetn = '0') then
--            s2mm_ch_ser_reset <= '0';
--            mm2s_ch_ser_reset <= '0';
--            mm2s_gr_1_clr <= '0';
--            mm2s_gr_2_clr <= '0';
--            mm2s_gr_3_clr <= '0';
--            mm2s_gr_4_clr <= '0';
--            mm2s_gr_5_clr <= '0';
--            mm2s_gr_6_clr <= '0';
--            s2mm_gr_1_clr <= '0';
--            s2mm_gr_2_clr <= '0';
--            s2mm_gr_3_clr <= '0';
--            s2mm_gr_4_clr <= '0';
--            s2mm_gr_5_clr <= '0';
--            s2mm_gr_6_clr <= '0';
--         else
            s2mm_ch_ser_reset <= axi2ip_rdce (S2MM_COMMON_LOW_INDEX+6);
            mm2s_ch_ser_reset <= axi2ip_rdce (MM2S_COMMON_LOW_INDEX+8);
            mm2s_gr_1_clr <= axi2ip_rdce (MM2S_OBSER_LOW_INDEX);
            mm2s_gr_2_clr <= axi2ip_rdce (MM2S_OBSER_LOW_INDEX+1);
            mm2s_gr_3_clr <= axi2ip_rdce (MM2S_OBSER_LOW_INDEX+2);
            mm2s_gr_4_clr <= axi2ip_rdce (MM2S_OBSER_LOW_INDEX+3);
            mm2s_gr_5_clr <= axi2ip_rdce (MM2S_OBSER_LOW_INDEX+4);
            mm2s_gr_6_clr <= axi2ip_rdce (MM2S_OBSER_LOW_INDEX+5);
            s2mm_gr_1_clr <= axi2ip_rdce (S2MM_OBSER_LOW_INDEX);
            s2mm_gr_2_clr <= axi2ip_rdce (S2MM_OBSER_LOW_INDEX+1);
            s2mm_gr_3_clr <= axi2ip_rdce (S2MM_OBSER_LOW_INDEX+2);
            s2mm_gr_4_clr <= axi2ip_rdce (S2MM_OBSER_LOW_INDEX+3);
            s2mm_gr_5_clr <= axi2ip_rdce (S2MM_OBSER_LOW_INDEX+4);
            s2mm_gr_6_clr <= axi2ip_rdce (S2MM_OBSER_LOW_INDEX+5);
--          end if;
--       end if;
--end process;

-------------------------------------------------------------------------------
-- No channels therefore do not generate an AXI Lite interface
-------------------------------------------------------------------------------
GEN_NO_AXI_LITE_IF : if C_INCLUDE_MM2S = 0 and C_INCLUDE_S2MM = 0 generate
begin
    s_axi_lite_awready          <= '0';
    s_axi_lite_wready           <= '0';
    s_axi_lite_bresp            <= (others => '0');
    s_axi_lite_bvalid           <= '0';
    s_axi_lite_arready          <= '0';
    s_axi_lite_rvalid           <= '0';
    s_axi_lite_rdata            <= (others => '0');
    s_axi_lite_rresp            <= (others => '0');

end generate GEN_NO_AXI_LITE_IF;


    I_COMMON_REGISTER : entity axi_mcdma_v1_1_8.axi_mcdma_common_register
    generic map (
        C_NUM_REGISTERS             => 20      ,
        C_INCLUDE_SG                => C_INCLUDE_SG             ,
        C_ENABLE_SINGLE_INTR        => C_ENABLE_SINGLE_INTR     ,
        C_MAX_CHANNELS              => C_MAX_CHANNELS           ,
        C_SG_LENGTH_WIDTH           => C_SG_LENGTH_WIDTH        ,
        C_S_AXI_LITE_DATA_WIDTH     => C_S_AXI_LITE_DATA_WIDTH  ,
        C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH    ,
        C_NUM_MM2S_CHANNELS         => C_NUM_MM2S_CHANNELS      ,
        C_MM2S_SCHEDULE             => C_MM2S_SCHEDULE          ,
        C_INCLUDE_MM2S              => C_INCLUDE_MM2S           ,
        C_INCLUDE_S2MM              => C_INCLUDE_S2MM           ,
        C_GROUP1_MM2S               => C_GROUP1_MM2S,
        C_GROUP2_MM2S               => C_GROUP2_MM2S,
        C_GROUP3_MM2S               => C_GROUP3_MM2S,
        C_GROUP4_MM2S               => C_GROUP4_MM2S,
        C_GROUP5_MM2S               => C_GROUP5_MM2S,
        C_GROUP6_MM2S               => C_GROUP6_MM2S,
        C_GROUP1_S2MM               => C_GROUP1_S2MM,
        C_GROUP2_S2MM               => C_GROUP2_S2MM,
        C_GROUP3_S2MM               => C_GROUP3_S2MM,
        C_GROUP4_S2MM               => C_GROUP4_S2MM,
        C_GROUP5_S2MM               => C_GROUP5_S2MM,
        C_GROUP6_S2MM               => C_GROUP6_S2MM
    )
    port map(
        -- Secondary Clock / Reset
        m_axi_sg_aclk               => m_axi_sg_aclk            ,
        m_axi_sg_aresetn            => m_axi_sg_aresetn         ,

        -- CPU Write Control (via AXI Lite)
        axi2ip_wrdata               => axi2ip_wrdata            ,
        axi2ip_wrce                 => axi2ip_wrce
                                        (MCDMA_CMN_UP_INDEX
                                        downto MCDMA_CMN_LOW_INDEX),

        sg_user_cache             => sg_user_cache_int,

        mm2s_ch_ser               => mm2s_ch_serviced, 
        s2mm_ch_ser               => s2mm_ch_serviced, 
         
        mm2s_gr_1_clr             => mm2s_gr_1_clr ,
        mm2s_gr_2_clr             => mm2s_gr_2_clr ,
        mm2s_gr_3_clr             => mm2s_gr_3_clr ,
        mm2s_gr_4_clr             => mm2s_gr_4_clr ,
        mm2s_gr_5_clr             => mm2s_gr_5_clr ,
        mm2s_gr_6_clr             => mm2s_gr_6_clr ,
        mm2s_gr_1                 => mm2s_gr_1     ,
        mm2s_gr_2                 => mm2s_gr_2     ,
        mm2s_gr_3                 => mm2s_gr_3     ,
        mm2s_gr_4                 => mm2s_gr_4     ,
        mm2s_gr_5                 => mm2s_gr_5     ,
        mm2s_gr_6                 => mm2s_gr_6     ,

        s2mm_gr_1_clr             => s2mm_gr_1_clr ,
        s2mm_gr_2_clr             => s2mm_gr_2_clr ,
        s2mm_gr_3_clr             => s2mm_gr_3_clr ,
        s2mm_gr_4_clr             => s2mm_gr_4_clr ,
        s2mm_gr_5_clr             => s2mm_gr_5_clr ,
        s2mm_gr_6_clr             => s2mm_gr_6_clr ,
        s2mm_gr_1                 => s2mm_gr_1     ,
        s2mm_gr_2                 => s2mm_gr_2     ,
        s2mm_gr_3                 => s2mm_gr_3     ,
        s2mm_gr_4                 => s2mm_gr_4     ,
        s2mm_gr_5                 => s2mm_gr_5     ,
        s2mm_gr_6                 => s2mm_gr_6    

    );

sg_user_cache <= sg_user_cache_int;


GEN_MM2S_REGISTERS_OBS : if C_INCLUDE_MM2S = 1 generate
begin
    I_MM2S_OBSERVER_READ : entity axi_mcdma_v1_1_8.axi_mcdma_read_mux
    port map(
           m_axi_sg_aclk                 => m_axi_sg_aclk,
           m_axi_sg_aresetn              => m_axi_sg_aresetn,
           read_addr                     => read_addr (4 downto 0),
           channel_dmacr                 => mm2s_gr_1,
           channel_dmasr                 => mm2s_gr_2,
           channel_cd_lsb                => mm2s_gr_3, 
           channel_cd_msb                => mm2s_gr_4,
           channel_td_lsb                => mm2s_gr_5,
           channel_td_msb                => mm2s_gr_6,
           channel_pktdrp_count          => (others => '0'),
           channel_pktproc_count         => (others => '0'),
           reg_out                       => ip2axi_rddata_mm2s_obs_ch
     );


end generate GEN_MM2S_REGISTERS_OBS;

GEN_S2MM_REGISTERS_OBS : if C_INCLUDE_S2MM = 1 generate
begin
    I_S2MM_OBSERVER_READ : entity axi_mcdma_v1_1_8.axi_mcdma_read_mux
    port map(
           m_axi_sg_aclk                 => m_axi_sg_aclk,
           m_axi_sg_aresetn              => m_axi_sg_aresetn,
           read_addr                     => read_addr (4 downto 0),
           channel_dmacr                 => s2mm_gr_1,
           channel_dmasr                 => s2mm_gr_2,
           channel_cd_lsb                => s2mm_gr_3, 
           channel_cd_msb                => s2mm_gr_4,
           channel_td_lsb                => s2mm_gr_5,
           channel_td_msb                => s2mm_gr_6,
           channel_pktdrp_count          => (others => '0'),
           channel_pktproc_count         => (others => '0'),
           reg_out                       => ip2axi_rddata_s2mm_obs_ch
     );


end generate GEN_S2MM_REGISTERS_OBS;

-------------------------------------------------------------------------------
-- Generate MM2S Registers if included
-------------------------------------------------------------------------------
GEN_MM2S_REGISTERS : if C_INCLUDE_MM2S = 1 generate

signal mm2s_run_stop_common : std_logic; 
signal mm2s_halted_common : std_logic; 
begin


    I_MM2S_COMMON_REGISTER : entity axi_mcdma_v1_1_8.axi_mcdma_mm2s_common_register
    generic map (
        C_NUM_REGISTERS             => NUM_REG_PER_CHANNEL      ,
        C_INCLUDE_SG                => C_INCLUDE_SG             ,
        C_ENABLE_SINGLE_INTR        => C_ENABLE_SINGLE_INTR     ,
        C_MAX_CHANNELS              => C_MAX_CHANNELS           ,
        C_SG_LENGTH_WIDTH           => C_SG_LENGTH_WIDTH        ,
        C_S_AXI_LITE_DATA_WIDTH     => C_S_AXI_LITE_DATA_WIDTH  ,
        C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH    ,
        C_NUM_MM2S_CHANNELS         => C_NUM_MM2S_CHANNELS      ,
        C_MM2S_SCHEDULE             => C_MM2S_SCHEDULE
    )
    port map(
        -- Secondary Clock / Reset
        m_axi_sg_aclk               => m_axi_sg_aclk            ,
        m_axi_sg_aresetn            => m_axi_sg_aresetn         ,

        -- CPU Write Control (via AXI Lite)
        axi2ip_wrdata               => axi2ip_wrdata            ,
        axi2ip_wrce                 => axi2ip_wrce
                                        (MM2S_COMMON_UP_INDEX
                                        downto MM2S_COMMON_LOW_INDEX),

        -- Channel id under service
        channel_in                  => mm2s_channel_id          ,
        mm2s_ch_serviced            => mm2s_ch_serviced         ,
        mm2s_ch_ser_reset           => mm2s_ch_ser_reset        ,
        pktdrp_count_in             => (others => '0')          ,
        ch_mm2s_ftch_channel_id     => ch_mm2s_ftch_channel_id  ,
        ch_mm2s_updt_channel_id     => ch_mm2s_updt_channel_id  , 
 
        all_idle                    => '0',

        -- DMASR Register bit control/status
        stop_dma                    => mm2s_stop                ,
        halted_clr                  => mm2s_halted_clr          ,
        halted_set                  => mm2s_halted_set          ,
        idle_set                    => mm2s_idle_set            ,
        idle_clr                    => mm2s_idle_clr            ,
        ioc_irq_set                 => mm2s_ioc_irq_set         ,
        dly_irq_set                 => mm2s_dly_irq_set         ,
        irqdelay_status             => mm2s_irqdelay_status     ,
        irqthresh_status            => mm2s_irqthresh_status    ,
        pktdrp_irq_set              => '0', --mm2s_pktdrp_irq_set         ,
        pktdrp_irqthresh_wren       => open, --mm2s_pktirqthresh_wren      ,
        pktirqthresh_status         => (others => '0'), --mm2s_pktirqthresh_status    ,
        intr_status                 => mm2s_ch_introut_to_cmn,

        -- SG Error Control
        dma_interr_set              => mm2s_dma_interr_set      ,
        dma_slverr_set              => mm2s_dma_slverr_set      ,
        dma_decerr_set              => mm2s_dma_decerr_set      ,
        ftch_interr_set             => mm2s_ftch_interr_set     ,
        ftch_slverr_set             => mm2s_ftch_slverr_set     ,
        ftch_decerr_set             => mm2s_ftch_decerr_set     ,
        ftch_error_addr             => ftch_error_addr          ,
        updt_interr_set             => mm2s_updt_interr_set     ,
        updt_slverr_set             => mm2s_updt_slverr_set     ,
        updt_decerr_set             => mm2s_updt_decerr_set     ,
        updt_error_addr             => updt_error_addr          ,
        irqthresh_wren              => mm2s_irqthresh_wren      ,
        irqdelay_wren               => mm2s_irqdelay_wren       ,
        dlyirq_dsble                => mm2s_dlyirq_dsble        , -- CR605888
        error_in                    => s2mm_error_out           ,
        error_out                   => mm2s_error_out           ,
        introut                     => mm2s_introut_i_cdc_from  ,
        soft_reset_in               => s2mm_dmacr_i(MCDMACR_RESET_BIT),
        soft_reset_clr              => soft_reset_clr           ,

        -- Channel Registers
        mm2s_sch                    => mm2s_sch_int,
        channel_weight              => channel_weight_int,
        channel_weight_2            => channel_weight_2_int,
        dmacr                       => mm2s_dmacr_i             ,
        dmasr                       => mm2s_dmasr_i             ,
        enable_channels             => enable_channels_mm2s          ,
        dma_ch_ser                  => dma_ch_under_service_mm2s     ,
        dma_pktdrp                  => open, --dma_pkt_drp_count        ,
        dma_err                     => dma_errors_mm2s           ,
        dma_ch_serviced             => dma_ch_serviced_mm2s,
        mm2s_user_cache             => mm2s_user_cache_int,
        dma_ch_intr_status          => mm2s_ch_intr_status
    );

mm2s_channel_enable <= enable_channels_mm2s(C_MAX_CHANNELS-1 downto 0);
mm2s_run_stop_common <= mm2s_dmacr_i(MCDMACR_RS_BIT);
mm2s_halted_common <= mm2s_dmasr_i(MCDMASR_HALTED_BIT);

mm2s_schedule <= mm2s_sch_int;
mm2s_ch_weight <= channel_weight_int;
mm2s_ch_weight_2 <= channel_weight_2_int;
mm2s_user_cache <= mm2s_user_cache_int (15 downto 0);


    GEN_INTROUT_ASYNCCMN : if C_AXI_LITE_IS_ASYNC = 1 generate
    begin
        -- Cross interrupt out to AXI Lite clock domain

PROC_REG_INTR2LITE : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => mm2s_introut_i_cdc_from,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => s_axi_lite_aclk,
        scndry_resetn              => '0',
        scndry_out                 => mm2s_introut_to,
        scndry_vect_out            => open
    );


              mm2s_introut <= mm2s_introut_to;

    end generate GEN_INTROUT_ASYNCCMN;

    -- If sync then simply pass out
    GEN_INTROUT_SYNCCMN : if C_AXI_LITE_IS_ASYNC = 0 generate
    begin
        mm2s_introut    <= mm2s_introut_i_cdc_from;
    end generate GEN_INTROUT_SYNCCMN;

mm2s_ch_error_or <= or_reduce (mm2s_ch_error_out);

CHANNEL_USED : for I in 0 to C_NUM_MM2S_CHANNELS-1 generate
begin


    I_MM2S_DMA_REGISTER : entity axi_mcdma_v1_1_8.axi_mcdma_register
    generic map (
        C_NUM_REGISTERS             => NUM_REG_PER_CHANNEL      ,
        C_INCLUDE_SG                => C_INCLUDE_SG             ,
        C_ENABLE_SINGLE_INTR        => C_ENABLE_SINGLE_INTR     ,
        C_SG_LENGTH_WIDTH           => C_SG_LENGTH_WIDTH        ,
        C_S_AXI_LITE_DATA_WIDTH     => C_S_AXI_LITE_DATA_WIDTH  ,
        C_ACTUAL_ADDR_WIDTH         => C_ACTUAL_ADDR_WIDTH      , 
        C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH    ,
        C_INCLUDE_MM2S              => C_INCLUDE_MM2S
    )
    port map(
        -- Secondary Clock / Reset
        m_axi_sg_aclk               => m_axi_sg_aclk            ,
        m_axi_sg_aresetn            => m_axi_sg_aresetn         ,

        -- CPU Write Control (via AXI Lite)
        axi2ip_wrdata               => axi2ip_wrdata            ,
        axi2ip_wrce                 => axi2ip_wrce
                                        (MM2S_CH1_UP_INDEX+16*I
                                        downto MM2S_CH1_LOW_INDEX+16*I),

        -- DMASR Register bit control/status
        stop_dma                    => mm2s_ch_stop(I)                ,
        sg_idle                     => mm2s_ch_sg_idle(I)             ,
        ch_service                  => '0',
        channel_service_run         => '0'          ,
        dma_run_stop                => mm2s_run_stop_common     ,
        dma_halted                  => mm2s_halted_common       ,
        halted_clr                  => mm2s_ch_halted_clr(I)          ,
        halted_set                  => mm2s_ch_halted_set(I)          ,
        idle_set                    => mm2s_ch_idle_set(I)            ,
        idle_clr                    => mm2s_ch_idle_clr(I)            ,
        ioc_irq_set                 => mm2s_ch_ioc_irq_set(I)         ,
        pktdrp_irq_set              => '0', --mm2s_ch_pktdrp_irq_set(I)         ,
        pktdrp_irqthresh_wren       => open, --mm2s_ch_pktirqthresh_wren(I)      ,
        pktirqthresh_status         => (others => '0'), --mm2s_ch_pktirqthresh_status(8*I+7 downto 8*I)    ,
        dly_irq_set                 => mm2s_ch_dly_irq_set(I)         ,
        irqdelay_status             => mm2s_ch_irqdelay_status(8*I+7 downto 8*I)     ,
        irqthresh_status            => mm2s_ch_irqthresh_status(8*I+7 downto 8*I)    ,

        -- SG Error Control
        dma_interr_set              => mm2s_ch_dma_interr_set(I)      ,
        dma_slverr_set              => mm2s_ch_dma_slverr_set(I)      ,
        dma_decerr_set              => mm2s_ch_dma_decerr_set(I)      ,
        ftch_interr_set             => mm2s_ch_ftch_interr_set(I)     ,
        ftch_slverr_set             => mm2s_ch_ftch_slverr_set(I)     ,
        ftch_decerr_set             => mm2s_ch_ftch_decerr_set(I)     ,
        ftch_error_addr             => ftch_error_addr          ,
        updt_interr_set             => mm2s_ch_updt_interr_set(I)     ,
        updt_slverr_set             => mm2s_ch_updt_slverr_set(I)     ,
        updt_decerr_set             => mm2s_ch_updt_decerr_set(I)     ,
        updt_error_addr             => updt_error_addr          ,
        irqthresh_wren              => mm2s_ch_irqthresh_wren(I)      ,
        irqdelay_wren               => mm2s_ch_irqdelay_wren(I)       ,
        dlyirq_dsble                => mm2s_ch_dlyirq_dsble(I)        , -- CR605888
        error_in                    => mm2s_error_out           ,
        error_out                   => mm2s_ch_error_out(I)           ,
        introut                     => mm2s_ch_introut_i_cdc_from(I)  ,
        soft_reset_in               => mm2s_dmacr_i(MCDMACR_RESET_BIT),
        soft_reset_clr              => soft_reset_clr           ,
        error_in_other              => error_or, --mm2s_ch_error_or,
        introut_to_cmn              => mm2s_ch_introut_to_cmn(I),

        -- CURDESC Update
        update_curdesc              => mm2s_ch_new_curdesc_wren(I)    ,
        new_curdesc                 => mm2s_ch_new_curdesc         ,

        -- TAILDESC Update
        tailpntr_updated            => mm2s_ch_tailpntr_updated(I)     ,

        -- Channel Registers
        dmacr                       => mm2s_ch_dmacr_i (32*I+31 downto 32*I)            ,
        dmasr                       => mm2s_ch_dmasr_i (32*I+31 downto 32*I)            ,
        curdesc_lsb                 => mm2s_ch_curdesc_lsb_i(32*I+31 downto 32*I)       ,
        curdesc_msb                 => mm2s_ch_curdesc_msb_i(32*I+31 downto 32*I)       ,
        taildesc_lsb                => mm2s_ch_taildesc_lsb_i(32*I+31 downto 32*I)      ,
        taildesc_lsb_rd             => mm2s_ch_taildesc_lsb_i_rd(32*I+31 downto 32*I)      ,
        taildesc_msb                => mm2s_ch_taildesc_msb_i(32*I+31 downto 32*I)      
    );

    -- If async clocks then cross interrupt out to AXI Lite clock domain
    GEN_INTROUT_ASYNC : if C_AXI_LITE_IS_ASYNC = 1 generate
    begin
        -- Cross interrupt out to AXI Lite clock domain

PROC_REG_INTR2LITE : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => mm2s_ch_introut_i_cdc_from(I),
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => s_axi_lite_aclk,
        scndry_resetn              => '0',
        scndry_out                 => mm2s_ch_introut_to(I),
        scndry_vect_out            => open
    );



              mm2s_ch_introut(I) <= mm2s_ch_introut_to(I);

    end generate GEN_INTROUT_ASYNC;

    -- If sync then simply pass out
    GEN_INTROUT_SYNC : if C_AXI_LITE_IS_ASYNC = 0 generate
    begin
        mm2s_ch_introut(I)    <= mm2s_ch_introut_i_cdc_from(I);
    end generate GEN_INTROUT_SYNC;

end generate CHANNEL_USED;

UNUSED_CHANNELS : if C_MAX_CHANNELS > C_NUM_MM2S_CHANNELS generate
begin

CHANNEL_UNUSED : for I in C_NUM_MM2S_CHANNELS to C_MAX_CHANNELS-1 generate
begin
mm2s_ch_introut(I) <= '0';
--mm2s_ch_new_curdesc_wren(I) <= '0';
--mm2s_ch_new_curdesc(C_M_AXI_SG_ADDR_WIDTH*I+C_M_AXI_SG_ADDR_WIDTH-1 downto C_M_AXI_SG_ADDR_WIDTH*I) <= (others => '0');
mm2s_ch_tailpntr_updated(I) <= '0';
mm2s_ch_dmacr_i (32*I+31 downto 32*I) <= (others => '0');
mm2s_ch_dmasr_i (32*I+31 downto 32*I) <= (others => '0');
mm2s_ch_curdesc_lsb_i(32*I+31 downto 32*I)  <= (others => '0');
mm2s_ch_curdesc_msb_i(32*I+31 downto 32*I)  <= (others => '0');
mm2s_ch_taildesc_lsb_i(32*I+31 downto 32*I)  <= (others => '0');
mm2s_ch_taildesc_lsb_i_rd(32*I+31 downto 32*I)  <= (others => '0');
mm2s_ch_taildesc_msb_i(32*I+31 downto 32*I)  <= (others => '0');
mm2s_ch_irqthresh_wren(I) <= '0';
mm2s_ch_irqdelay_wren(I)  <= '0';
mm2s_ch_dlyirq_dsble(I)   <= '0';
mm2s_ch_error_out(I) <= '0';
mm2s_ch_introut_to_cmn(I) <= '0';
--mm2s_ch_pktirqthresh_wren(I)  <= '0';


end generate CHANNEL_UNUSED;
end generate UNUSED_CHANNELS;


end generate GEN_MM2S_REGISTERS;

-------------------------------------------------------------------------------
-- Tie MM2S Register outputs to zero if excluded
-------------------------------------------------------------------------------
GEN_NO_MM2S_REGISTERS : if C_INCLUDE_MM2S = 0 generate
begin
    mm2s_dmacr_i            <= (others => '0');
    mm2s_dmasr_i            <= (others => '0');
    mm2s_curdesc_lsb_i      <= (others => '0');
    mm2s_curdesc_msb_i      <= (others => '0');
    mm2s_taildesc_lsb_i     <= (others => '0');
    mm2s_taildesc_msb_i     <= (others => '0');
    mm2s_tailpntr_updated   <= '0';

    mm2s_irqthresh_wren         <= '0';
    mm2s_irqdelay_wren          <= '0';
    mm2s_tailpntr_updated       <= '0';
    mm2s_introut                <= '0';
    mm2s_ch_error_or            <= '0';
    ip2axi_rddata_mm2s_obs_ch (31 downto 0) <= (others => '0');

end generate GEN_NO_MM2S_REGISTERS;



-------------------------------------------------------------------------------
-- Generate S2MM Registers if included
-------------------------------------------------------------------------------
GEN_S2MM_REGISTERS : if C_INCLUDE_S2MM = 1 generate
signal s2mm_run_stop_common : std_logic; 
signal s2mm_halted_common : std_logic; 
begin


    I_S2MM_COMMON_REGISTER : entity axi_mcdma_v1_1_8.axi_mcdma_s2mm_common_register
    generic map (
        C_NUM_REGISTERS             => NUM_REG_PER_CHANNEL      ,
        C_INCLUDE_SG                => C_INCLUDE_SG             ,
        C_ENABLE_SINGLE_INTR        => C_ENABLE_SINGLE_INTR     ,
        C_MAX_CHANNELS              => C_MAX_CHANNELS           ,
        C_SG_LENGTH_WIDTH           => C_SG_LENGTH_WIDTH        ,
        C_S_AXI_LITE_DATA_WIDTH     => C_S_AXI_LITE_DATA_WIDTH  ,
        C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH    ,
        C_NUM_S2MM_CHANNELS         => C_NUM_S2MM_CHANNELS
    )
    port map(
        -- Secondary Clock / Reset
        m_axi_sg_aclk               => m_axi_sg_aclk            ,
        m_axi_sg_aresetn            => m_axi_sg_aresetn         ,

        -- CPU Write Control (via AXI Lite)
        axi2ip_wrdata               => axi2ip_wrdata            ,
        axi2ip_wrce                 => axi2ip_wrce
                                        (S2MM_COMMON_UP_INDEX
                                        downto S2MM_COMMON_LOW_INDEX),

        -- Channel id under service
        channel_in                  => s2mm_channel_id          ,
        pktdrp_count_in             => pktdrp_count_in          ,
        s2mm_ch_serviced            => s2mm_ch_serviced         ,
        s2mm_ch_ser_reset           => s2mm_ch_ser_reset        ,
        ch_s2mm_ftch_channel_id     => ch_s2mm_ftch_channel_id  ,
        ch_s2mm_updt_channel_id     => ch_s2mm_updt_channel_id  , 
 
        all_idle                    => '0',

        -- DMASR Register bit control/status
        stop_dma                    => s2mm_stop                ,
        halted_clr                  => s2mm_halted_clr          ,
        halted_set                  => s2mm_halted_set          ,
        idle_set                    => s2mm_idle_set            ,
        idle_clr                    => s2mm_idle_clr            ,
        ioc_irq_set                 => s2mm_ioc_irq_set         ,
        dly_irq_set                 => s2mm_dly_irq_set         ,
        irqdelay_status             => s2mm_irqdelay_status     ,
        irqthresh_status            => s2mm_irqthresh_status    ,
        pktdrp_irq_set              => s2mm_pktdrp_irq_set         ,
        pktdrp_irqthresh_wren       => s2mm_pktirqthresh_wren      ,
        pktirqthresh_status         => s2mm_pktirqthresh_status    ,
        intr_status                 => s2mm_ch_introut_to_cmn,

        -- SG Error Control
        dma_interr_set              => s2mm_dma_interr_set      ,
        dma_slverr_set              => s2mm_dma_slverr_set      ,
        dma_decerr_set              => s2mm_dma_decerr_set      ,
        ftch_interr_set             => s2mm_ftch_interr_set     ,
        ftch_slverr_set             => s2mm_ftch_slverr_set     ,
        ftch_decerr_set             => s2mm_ftch_decerr_set     ,
        ftch_error_addr             => ftch_error_addr          ,
        updt_interr_set             => s2mm_updt_interr_set     ,
        updt_slverr_set             => s2mm_updt_slverr_set     ,
        updt_decerr_set             => s2mm_updt_decerr_set     ,
        updt_error_addr             => updt_error_addr          ,
        irqthresh_wren              => s2mm_irqthresh_wren      ,
        irqdelay_wren               => s2mm_irqdelay_wren       ,
        dlyirq_dsble                => s2mm_dlyirq_dsble        , -- CR605888
        error_in                    => mm2s_error_out           ,
        error_out                   => s2mm_error_out           ,
        introut                     => s2mm_introut_i_cdc_from  ,
        soft_reset_in               => mm2s_dmacr_i(MCDMACR_RESET_BIT),
        soft_reset_clr              => soft_reset_clr           ,

        -- Channel Registers
        dmacr                       => s2mm_dmacr_i             ,
        dmasr                       => s2mm_dmasr_i             ,
        enable_channels             => enable_channels          ,
        dma_ch_ser                  => dma_ch_under_service     ,
        dma_pktdrp                  => dma_pkt_drp_count        ,
        dma_err                     => dma_errors               ,
        dma_ch_serviced             => dma_ch_serviced          ,
        s2mm_user_cache             => s2mm_user_cache_int      ,
        dma_ch_intr_status          => s2mm_ch_intr_status
    );

s2mm_user_cache <= s2mm_user_cache_int (15 downto 0);
s2mm_channel_enable <= enable_channels(C_MAX_CHANNELS-1 downto 0);
s2mm_run_stop_common <= s2mm_dmacr_i(MCDMACR_RS_BIT);
s2mm_halted_common <= s2mm_dmasr_i(MCDMASR_HALTED_BIT);


    GEN_INTROUT_ASYNCCMN : if C_AXI_LITE_IS_ASYNC = 1 generate
    begin
        -- Cross interrupt out to AXI Lite clock domain

PROC_REG_INTR2LITE : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => s2mm_introut_i_cdc_from,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => s_axi_lite_aclk,
        scndry_resetn              => '0',
        scndry_out                 => s2mm_introut_to,
        scndry_vect_out            => open
    );


              s2mm_introut <= s2mm_introut_to;

    end generate GEN_INTROUT_ASYNCCMN;

    -- If sync then simply pass out
    GEN_INTROUT_SYNCCMN : if C_AXI_LITE_IS_ASYNC = 0 generate
    begin
        s2mm_introut    <= s2mm_introut_i_cdc_from;
    end generate GEN_INTROUT_SYNCCMN;

s2mm_ch_error_or <= or_reduce (s2mm_ch_error_out);

CHANNEL_USED : for I in 0 to C_NUM_S2MM_CHANNELS-1 generate
begin


    I_S2MM_DMA_REGISTER : entity axi_mcdma_v1_1_8.axi_mcdma_register
    generic map (
        C_NUM_REGISTERS             => NUM_REG_PER_CHANNEL      ,
        C_INCLUDE_SG                => C_INCLUDE_SG             ,
        C_ENABLE_SINGLE_INTR        => C_ENABLE_SINGLE_INTR     ,
        C_SG_LENGTH_WIDTH           => C_SG_LENGTH_WIDTH        ,
        C_S_AXI_LITE_DATA_WIDTH     => C_S_AXI_LITE_DATA_WIDTH  ,
        C_ACTUAL_ADDR_WIDTH         => C_ACTUAL_ADDR_WIDTH      , 
        C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH
    )
    port map(
        -- Secondary Clock / Reset
        m_axi_sg_aclk               => m_axi_sg_aclk            ,
        m_axi_sg_aresetn            => m_axi_sg_aresetn         ,

        -- CPU Write Control (via AXI Lite)
        axi2ip_wrdata               => axi2ip_wrdata            ,
        axi2ip_wrce                 => axi2ip_wrce
                                        (S2MM_CH1_UP_INDEX+16*I
                                        downto S2MM_CH1_LOW_INDEX+16*I),

        -- DMASR Register bit control/status
        stop_dma                    => s2mm_ch_stop(I)                ,
        sg_idle                     => s2mm_ch_sg_idle(I)             ,
        ch_service                  => s2mm_channel_id(I)             ,
        channel_service_run         => s2mm_channel_id_run(I)          ,
        dma_run_stop                => s2mm_run_stop_common     ,
        dma_halted                  => s2mm_halted_common       ,
        halted_clr                  => s2mm_ch_halted_clr(I)          ,
        halted_set                  => s2mm_ch_halted_set(I)          ,
        idle_set                    => s2mm_ch_idle_set(I)            ,
        idle_clr                    => s2mm_ch_idle_clr(I)            ,
        ioc_irq_set                 => s2mm_ch_ioc_irq_set(I)         ,
        pktdrp_irq_set              => s2mm_ch_pktdrp_irq_set(I)         ,
        pktdrp_irqthresh_wren       => s2mm_ch_pktirqthresh_wren(I)      ,
        pktirqthresh_status         => s2mm_ch_pktirqthresh_status(8*I+7 downto 8*I)    ,
        dly_irq_set                 => s2mm_ch_dly_irq_set(I)         ,
        irqdelay_status             => s2mm_ch_irqdelay_status(8*I+7 downto 8*I)     ,
        irqthresh_status            => s2mm_ch_irqthresh_status(8*I+7 downto 8*I)    ,

        -- SG Error Control
        dma_interr_set              => s2mm_ch_dma_interr_set(I)      ,
        dma_slverr_set              => s2mm_ch_dma_slverr_set(I)      ,
        dma_decerr_set              => s2mm_ch_dma_decerr_set(I)      ,
        ftch_interr_set             => s2mm_ch_ftch_interr_set(I)     ,
        ftch_slverr_set             => s2mm_ch_ftch_slverr_set(I)     ,
        ftch_decerr_set             => s2mm_ch_ftch_decerr_set(I)     ,
        ftch_error_addr             => ftch_error_addr          ,
        updt_interr_set             => s2mm_ch_updt_interr_set(I)     ,
        updt_slverr_set             => s2mm_ch_updt_slverr_set(I)     ,
        updt_decerr_set             => s2mm_ch_updt_decerr_set(I)     ,
        updt_error_addr             => updt_error_addr          ,
        irqthresh_wren              => s2mm_ch_irqthresh_wren(I)      ,
        irqdelay_wren               => s2mm_ch_irqdelay_wren(I)       ,
        dlyirq_dsble                => s2mm_ch_dlyirq_dsble(I)        , -- CR605888
        error_in                    => mm2s_error_out           ,
        error_out                   => s2mm_ch_error_out(I)           ,
        introut                     => s2mm_ch_introut_i_cdc_from(I)  ,
        soft_reset_in               => mm2s_dmacr_i(MCDMACR_RESET_BIT),
        soft_reset_clr              => soft_reset_clr           ,

        error_in_other              => error_or, --s2mm_ch_error_or,
        introut_to_cmn              => s2mm_ch_introut_to_cmn(I),
        -- CURDESC Update
        update_curdesc              => s2mm_ch_new_curdesc_wren(I)    ,
        new_curdesc                 => s2mm_ch_new_curdesc         ,

        -- TAILDESC Update
        tailpntr_updated            => s2mm_ch_tailpntr_updated(I)     ,

        -- Channel Registers
        dmacr                       => s2mm_ch_dmacr_i (32*I+31 downto 32*I)            ,
        dmasr                       => s2mm_ch_dmasr_i (32*I+31 downto 32*I)            ,
        curdesc_lsb                 => s2mm_ch_curdesc_lsb_i(32*I+31 downto 32*I)       ,
        curdesc_msb                 => s2mm_ch_curdesc_msb_i(32*I+31 downto 32*I)       ,
        taildesc_lsb                => s2mm_ch_taildesc_lsb_i(32*I+31 downto 32*I)      ,
        taildesc_lsb_rd             => s2mm_ch_taildesc_lsb_i_rd(32*I+31 downto 32*I)      ,
        taildesc_msb                => s2mm_ch_taildesc_msb_i(32*I+31 downto 32*I)      
    );

    -- If async clocks then cross interrupt out to AXI Lite clock domain
    GEN_INTROUT_ASYNC : if C_AXI_LITE_IS_ASYNC = 1 generate
    begin
        -- Cross interrupt out to AXI Lite clock domain

PROC_REG_INTR2LITE : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => s2mm_ch_introut_i_cdc_from(I),
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => s_axi_lite_aclk,
        scndry_resetn              => '0',
        scndry_out                 => s2mm_ch_introut_to(I),
        scndry_vect_out            => open
    );



              s2mm_ch_introut(I) <= s2mm_ch_introut_to(I);

    end generate GEN_INTROUT_ASYNC;

    -- If sync then simply pass out
    GEN_INTROUT_SYNC : if C_AXI_LITE_IS_ASYNC = 0 generate
    begin
        s2mm_ch_introut(I)    <= s2mm_ch_introut_i_cdc_from(I);
    end generate GEN_INTROUT_SYNC;

end generate CHANNEL_USED;

UNUSED_CHANNELS : if C_MAX_CHANNELS > C_NUM_S2MM_CHANNELS generate
begin

CHANNEL_UNUSED : for I in C_NUM_S2MM_CHANNELS to C_MAX_CHANNELS-1 generate
begin
s2mm_ch_introut(I) <= '0';
--s2mm_ch_new_curdesc_wren(I) <= '0';
--s2mm_ch_new_curdesc(C_M_AXI_SG_ADDR_WIDTH*I+C_M_AXI_SG_ADDR_WIDTH-1 downto C_M_AXI_SG_ADDR_WIDTH*I) <= (others => '0');
s2mm_ch_tailpntr_updated(I) <= '0';
s2mm_ch_dmacr_i (32*I+31 downto 32*I) <= (others => '0');
s2mm_ch_dmasr_i (32*I+31 downto 32*I) <= (others => '0');
s2mm_ch_curdesc_lsb_i(32*I+31 downto 32*I)  <= (others => '0');
s2mm_ch_curdesc_msb_i(32*I+31 downto 32*I)  <= (others => '0');
s2mm_ch_taildesc_lsb_i(32*I+31 downto 32*I)  <= (others => '0');
s2mm_ch_taildesc_lsb_i_rd(32*I+31 downto 32*I)  <= (others => '0');
s2mm_ch_taildesc_msb_i(32*I+31 downto 32*I)  <= (others => '0');
s2mm_ch_irqthresh_wren(I) <= '0';
s2mm_ch_irqdelay_wren(I)  <= '0';
s2mm_ch_dlyirq_dsble(I)   <= '1';
s2mm_ch_pktirqthresh_wren(I)  <= '0';
s2mm_ch_error_out(I) <= '0';
s2mm_ch_introut_to_cmn(I) <= '0';

end generate CHANNEL_UNUSED;
end generate UNUSED_CHANNELS;




end generate GEN_S2MM_REGISTERS;

-------------------------------------------------------------------------------
-- Tie S2MM Register outputs to zero if excluded
-------------------------------------------------------------------------------
GEN_NO_S2MM_REGISTERS : if C_INCLUDE_S2MM = 0 generate
begin

s2mm_ch_introut <= (others => '0');
--s2mm_ch_new_curdesc_wren <= (others => '0');
--s2mm_ch_new_curdesc <= (others => '0');
s2mm_ch_tailpntr_updated <= (others => '0');
s2mm_ch_dmacr_i  <= (others => '0');
s2mm_ch_dmasr_i  <= (others => '0');
s2mm_ch_curdesc_lsb_i  <= (others => '0');
s2mm_ch_curdesc_msb_i  <= (others => '0');
s2mm_ch_taildesc_lsb_i <= (others => '0');
s2mm_ch_taildesc_lsb_i_rd <= (others => '0');
s2mm_ch_taildesc_msb_i <= (others => '0');
s2mm_ch_irqthresh_wren <= (others => '0');
s2mm_ch_irqdelay_wren  <= (others => '0');
s2mm_ch_dlyirq_dsble   <= (others => '0');
s2mm_ch_pktirqthresh_wren  <= (others => '0');
s2mm_ch_error_or            <= '0';
ip2axi_rddata_s2mm_obs_ch (31 downto 0) <= (others => '0');
s2mm_dmacr_i <= (others => '0');
s2mm_error_out <= '0';
ip2axi_rddata_s2mm_ch1 <= (others => '0');
ip2axi_rddata_s2mm_ch2 <= (others => '0');
ip2axi_rddata_s2mm_ch3 <= (others => '0');
ip2axi_rddata_s2mm_ch4 <= (others => '0');
ip2axi_rddata_s2mm_ch5 <= (others => '0');

end generate GEN_NO_S2MM_REGISTERS;


-------------------------------------------------------------------------------
-- AXI LITE READ MUX
-------------------------------------------------------------------------------
read_addr <= axi2ip_rdaddr(11 downto 0);

-- Generate read mux for Scatter Gather Mode
GEN_READ_MUX_FOR_SG : if C_INCLUDE_SG = 1 generate
begin

GEN_MM2S_REGISTERS : if C_INCLUDE_MM2S = 1 generate
begin


    AXI_LITE_READ_MUX_CMN : process(read_addr(5 downto 0)            ,
                                mm2s_dmacr_i             ,
                                mm2s_dmasr_i             ,
                                enable_channels_mm2s          ,
                                dma_ch_under_service_mm2s     ,
                                dma_errors_mm2s               ,
                                mm2s_sch_int,
                                channel_weight_int,
                                channel_weight_2_int,
                                dma_ch_serviced_mm2s,
                                mm2s_user_cache_int,
                                mm2s_ch_intr_status
)
        begin
            case read_addr(5 downto 0) is
                when MM2S_CMN_CTRL_OFFSET =>
                    ip2axi_rddata_mm2s_cmn <= mm2s_dmacr_i;

                when MM2S_CMN_STS_OFFSET  =>
                    ip2axi_rddata_mm2s_cmn <= mm2s_dmasr_i;

                when MM2S_CMN_EN_DIS_OFFSET =>
                    ip2axi_rddata_mm2s_cmn <=  enable_channels_mm2s;

                when MM2S_CMN_SER_OFFSET =>
                    ip2axi_rddata_mm2s_cmn <= dma_ch_under_service_mm2s; 

                when MM2S_CMN_ERROR_OFFSET =>
                    ip2axi_rddata_mm2s_cmn <= dma_errors_mm2s;

                when MM2S_CMN_CH_SCHD_TYPE =>
                    ip2axi_rddata_mm2s_cmn <= mm2s_sch_int;

                when MM2S_CMN_WRR_REG1_OFFSET =>
                    ip2axi_rddata_mm2s_cmn <=  channel_weight_int;

                when MM2S_CMN_WRR_REG2_OFFSET =>
                    ip2axi_rddata_mm2s_cmn <= channel_weight_2_int;

                when MM2S_CMN_SER_STS_OFFSET =>
                    ip2axi_rddata_mm2s_cmn <= dma_ch_serviced_mm2s;

                when MM2S_CMN_CACHE_OFFSET =>
                    ip2axi_rddata_mm2s_cmn <= mm2s_user_cache_int;

                when MM2S_CMN_INTR_OFFSET =>
                    ip2axi_rddata_mm2s_cmn <= mm2s_ch_intr_status;
          -- coverage off
                when others =>
                    ip2axi_rddata_mm2s_cmn <= (others => '0');
          -- coverage on
            end case;
        end process AXI_LITE_READ_MUX_CMN;

ip2axi_rddata_mm2s_ch(31 downto 0) <= ip2axi_rddata_mm2s_cmn;


CHANNEL_USED : for I in 0 to C_NUM_MM2S_CHANNELS-1 generate
begin

    I_MM2S_REG_READ : entity axi_mcdma_v1_1_8.axi_mcdma_read_mux
    port map(
           m_axi_sg_aclk                 => m_axi_sg_aclk,
           m_axi_sg_aresetn              => m_axi_sg_aresetn,
           read_addr                     => read_addr (4 downto 0),
           channel_dmacr                 => mm2s_ch_dmacr_i (32-1+32*I  downto 32*I),
           channel_dmasr                 => mm2s_ch_dmasr_i (32-1+32*I  downto 32*I),
           channel_cd_lsb                => mm2s_ch_curdesc_lsb_i (32-1+32*I  downto 32*I),
           channel_cd_msb                => mm2s_ch_curdesc_msb_i (32-1+32*I  downto 32*I),
           channel_td_lsb                => mm2s_ch_taildesc_lsb_i_rd (32-1+32*I  downto 32*I),
           channel_td_msb                => mm2s_ch_taildesc_msb_i (32-1+32*I  downto 32*I),
           channel_pktdrp_count          => mm2s_ch_pktcount (16-1+16*I downto 16*I),
           channel_pktproc_count         => (others => '0'), --mm2s_ch_pktdrp_count (16-1+16*I downto 16*I),
           reg_out                       => ip2axi_rddata_mm2s_ch (32-1+32*(I+1)  downto 32*(I+1))
     );


end generate CHANNEL_USED;

UNUSED_CHANNELS : if (C_NUM_MM2S_CHANNELS < 16) generate
begin

CHANNEL_UNUSED : for I in C_NUM_MM2S_CHANNELS to 15 generate
begin

ip2axi_rddata_mm2s_ch (32-1+32*(I+1)  downto 32*(I+1)) <= (others => '0');

end generate CHANNEL_UNUSED;
end generate UNUSED_CHANNELS;


CHANNELS_1 : if (C_NUM_MM2S_CHANNELS >= 1) generate
begin
    AXI_LITE_READ_MUX_CH1 : process(read_addr(8 downto 6)            ,
                                ip2axi_rddata_mm2s_ch(127 downto 0)             
)
        begin
            case read_addr(8 downto 6) is
                when "000" =>
                    ip2axi_rddata_mm2s_ch1 <= ip2axi_rddata_mm2s_ch (31 downto 0);
                when "001"  =>
                    ip2axi_rddata_mm2s_ch1 <= ip2axi_rddata_mm2s_ch (63 downto 32);
                when "010" =>
                    ip2axi_rddata_mm2s_ch1 <= ip2axi_rddata_mm2s_ch (95 downto 64);
                when "011" =>
                    ip2axi_rddata_mm2s_ch1 <= ip2axi_rddata_mm2s_ch (127 downto 96);
          -- coverage off
                when others =>
                    ip2axi_rddata_mm2s_ch1 <= (others => '0');
          -- coverage on
            end case;
        end process AXI_LITE_READ_MUX_CH1;

end generate CHANNELS_1;

CHANNELS_2 : if (C_NUM_MM2S_CHANNELS > 3) generate
begin
    AXI_LITE_READ_MUX_CH1 : process(read_addr(8 downto 6)            ,
                                ip2axi_rddata_mm2s_ch(255 downto 128)             
)
        begin
            case read_addr(8 downto 6) is
                when "100" =>
                    ip2axi_rddata_mm2s_ch2 <= ip2axi_rddata_mm2s_ch (159 downto 128);
                when "101"  =>
                    ip2axi_rddata_mm2s_ch2 <= ip2axi_rddata_mm2s_ch (191 downto 160);
                when "110" =>
                    ip2axi_rddata_mm2s_ch2 <= ip2axi_rddata_mm2s_ch (223 downto 192);
                when "111" =>
                    ip2axi_rddata_mm2s_ch2 <= ip2axi_rddata_mm2s_ch (255 downto 224);
          -- coverage off
                when others =>
                    ip2axi_rddata_mm2s_ch2 <= (others => '0');
          -- coverage on
            end case;
        end process AXI_LITE_READ_MUX_CH1;

end generate CHANNELS_2;


CHANNELS_2_NOT : if (C_NUM_MM2S_CHANNELS < 3) generate
begin
                    ip2axi_rddata_mm2s_ch2 <= (others => '0');

end generate CHANNELS_2_NOT;


CHANNELS_3 : if (C_NUM_MM2S_CHANNELS > 7) generate
begin
    AXI_LITE_READ_MUX_CH1 : process(read_addr(8 downto 6)            ,
                                ip2axi_rddata_mm2s_ch(383 downto 256)             
)
        begin
            case read_addr(8 downto 6) is
                when "000" =>
                    ip2axi_rddata_mm2s_ch3 <= ip2axi_rddata_mm2s_ch (287 downto 256);
                when "001"  =>
                    ip2axi_rddata_mm2s_ch3 <= ip2axi_rddata_mm2s_ch (319 downto 288);
                when "010" =>
                    ip2axi_rddata_mm2s_ch3 <= ip2axi_rddata_mm2s_ch (351 downto 320);
                when "011" =>
                    ip2axi_rddata_mm2s_ch3 <= ip2axi_rddata_mm2s_ch (383 downto 352);
          -- coverage off
                when others =>
                    ip2axi_rddata_mm2s_ch3 <= (others => '0');
          -- coverage on
            end case;
        end process AXI_LITE_READ_MUX_CH1;

end generate CHANNELS_3;


CHANNELS_3_NOT : if (C_NUM_MM2S_CHANNELS < 7) generate
begin
                    ip2axi_rddata_mm2s_ch3 <= (others => '0');

end generate CHANNELS_3_NOT;


CHANNELS_4 : if (C_NUM_MM2S_CHANNELS > 11) generate
begin
    AXI_LITE_READ_MUX_CH1 : process(read_addr(8 downto 6)            ,
                                ip2axi_rddata_mm2s_ch(511 downto 384)             
)
        begin
            case read_addr(8 downto 6) is
                when "100" =>
                    ip2axi_rddata_mm2s_ch4 <= ip2axi_rddata_mm2s_ch (415 downto 384);
                when "101"  =>
                    ip2axi_rddata_mm2s_ch4 <= ip2axi_rddata_mm2s_ch (447 downto 416);
                when "110" =>
                    ip2axi_rddata_mm2s_ch4 <= ip2axi_rddata_mm2s_ch (479 downto 448);
                when "111" =>
                    ip2axi_rddata_mm2s_ch4 <= ip2axi_rddata_mm2s_ch (511 downto 480);
          -- coverage off
                when others =>
                    ip2axi_rddata_mm2s_ch4 <= (others => '0');
          -- coverage on
            end case;
        end process AXI_LITE_READ_MUX_CH1;

end generate CHANNELS_4;


CHANNELS_4_NOT : if (C_NUM_MM2S_CHANNELS < 11) generate
begin
                    ip2axi_rddata_mm2s_ch4 <= (others => '0');

end generate CHANNELS_4_NOT;


end generate GEN_MM2S_REGISTERS;

    AXI_LITE_READ_CMN_MUX : process(read_addr(8 downto 6)            ,
                                ip2axi_rddata_mm2s_ch(543 downto 512),
                                sg_user_cache_int            ,
                                ip2axi_rddata_mm2s_obs_ch 
)
        begin
            case read_addr(8 downto 6) is
                when "000" =>
                    ip2axi_rddata_mm2s_ch5 <= ip2axi_rddata_mm2s_ch (543 downto 512);
                when "001" =>
                    ip2axi_rddata_mm2s_ch5 <= ip2axi_rddata_mm2s_obs_ch;
                when "010" =>
                    ip2axi_rddata_mm2s_ch5 <= sg_user_cache_int; --ip2axi_rddata_mm2s_ch (543 downto 512);
          -- coverage off
                when others =>
                    ip2axi_rddata_mm2s_ch5 <= (others => '0');
          -- coverage on
            end case;
        end process AXI_LITE_READ_CMN_MUX;






GEN_S2MM_REGISTERS : if C_INCLUDE_S2MM = 1 generate
begin

-- one mux is for common register
-- other muxes replicated for each channel

    AXI_LITE_READ_MUX_CMN : process(read_addr(5 downto 0)            ,
                                s2mm_dmacr_i             ,
                                s2mm_dmasr_i             ,
                                enable_channels          ,
                                dma_ch_under_service     ,
                                dma_pkt_drp_count,       --s2mm_pktdrp_count        ,
                                dma_errors               ,
                                dma_ch_serviced          ,
                                s2mm_user_cache_int      ,
                                s2mm_ch_intr_status
)
        begin
            case read_addr(5 downto 0) is
                when S2MM_CMN_CTRL_OFFSET =>
                    ip2axi_rddata_s2mm_cmn <= s2mm_dmacr_i;
                when S2MM_CMN_STS_OFFSET  =>
                    ip2axi_rddata_s2mm_cmn <= s2mm_dmasr_i;
                when S2MM_CMN_EN_DIS_OFFSET =>
                    ip2axi_rddata_s2mm_cmn <= enable_channels;
                when S2MM_CMN_SER_OFFSET =>
                    ip2axi_rddata_s2mm_cmn <= dma_ch_under_service;
                when S2MM_CMN_ERROR_OFFSET =>
                    ip2axi_rddata_s2mm_cmn <= dma_errors;
                when S2MM_CMN_PKTDRP_STS_OFFSET =>
                    ip2axi_rddata_s2mm_cmn <= dma_pkt_drp_count; --s2mm_pktdrp_count;
                when S2MM_CMN_SER_STS_OFFSET =>
                    ip2axi_rddata_s2mm_cmn <= dma_ch_serviced;
                when S2MM_CMN_CACHE_OFFSET =>
                    ip2axi_rddata_s2mm_cmn <= s2mm_user_cache_int;
                when S2MM_CMN_INTR_OFFSET =>
                    ip2axi_rddata_s2mm_cmn <= s2mm_ch_intr_status;
          -- coverage off
                when others =>
                    ip2axi_rddata_s2mm_cmn <= (others => '0');
          -- coverage on
            end case;
        end process AXI_LITE_READ_MUX_CMN;

ip2axi_rddata_s2mm_ch(31 downto 0) <= ip2axi_rddata_s2mm_cmn;


CHANNEL_USED : for I in 0 to C_NUM_S2MM_CHANNELS-1 generate
begin

    I_S2MM_REG_READ : entity axi_mcdma_v1_1_8.axi_mcdma_read_mux
    port map(
           m_axi_sg_aclk                 => m_axi_sg_aclk,
           m_axi_sg_aresetn              => m_axi_sg_aresetn,
           read_addr                     => read_addr (4 downto 0),
           channel_dmacr                 => s2mm_ch_dmacr_i (32-1+32*I  downto 32*I),
           channel_dmasr                 => s2mm_ch_dmasr_i (32-1+32*I  downto 32*I),
           channel_cd_lsb                => s2mm_ch_curdesc_lsb_i (32-1+32*I  downto 32*I),
           channel_cd_msb                => s2mm_ch_curdesc_msb_i (32-1+32*I  downto 32*I),
           channel_td_lsb                => s2mm_ch_taildesc_lsb_i_rd (32-1+32*I  downto 32*I),
           channel_td_msb                => s2mm_ch_taildesc_msb_i (32-1+32*I  downto 32*I),
           channel_pktdrp_count          => s2mm_ch_pktdrp_count (16-1+16*I downto 16*I),
           channel_pktproc_count         => s2mm_ch_pktcount (16-1+16*I downto 16*I),
           reg_out                       => ip2axi_rddata_s2mm_ch (32-1+32*(I+1)  downto 32*(I+1))
     );


end generate CHANNEL_USED;

UNUSED_CHANNELS : if (C_NUM_S2MM_CHANNELS < 16) generate
begin

CHANNEL_UNUSED : for I in C_NUM_S2MM_CHANNELS to 15 generate
begin

ip2axi_rddata_s2mm_ch (32-1+32*(I+1)  downto 32*(I+1)) <= (others => '0');

end generate CHANNEL_UNUSED;
end generate UNUSED_CHANNELS;


CHANNELS_1 : if (C_NUM_S2MM_CHANNELS >= 1) generate
begin
    AXI_LITE_READ_MUX_CH1 : process(read_addr(8 downto 6)            ,
                                ip2axi_rddata_s2mm_ch(127 downto 0)             
)
        begin
            case read_addr(8 downto 6) is
                when "100" =>
                    ip2axi_rddata_s2mm_ch1 <= ip2axi_rddata_s2mm_ch (31 downto 0);
                when "101"  =>
                    ip2axi_rddata_s2mm_ch1 <= ip2axi_rddata_s2mm_ch (63 downto 32);
                when "110" =>
                    ip2axi_rddata_s2mm_ch1 <= ip2axi_rddata_s2mm_ch (95 downto 64);
                when "111" =>
                    ip2axi_rddata_s2mm_ch1 <= ip2axi_rddata_s2mm_ch (127 downto 96);
          -- coverage off
                when others =>
                    ip2axi_rddata_s2mm_ch1 <= (others => '0');
          -- coverage on
            end case;
        end process AXI_LITE_READ_MUX_CH1;

end generate CHANNELS_1;
NO_CHANNELS_1 : if (C_NUM_S2MM_CHANNELS < 1) generate
begin
          ip2axi_rddata_s2mm_ch1 <= (others => '0');
end generate NO_CHANNELS_1;

CHANNELS_2 : if (C_NUM_S2MM_CHANNELS > 3) generate
begin
    AXI_LITE_READ_MUX_CH1 : process(read_addr(8 downto 6)            ,
                                ip2axi_rddata_s2mm_ch(255 downto 128)             
)
        begin
            case read_addr(8 downto 6) is
                when "000" =>
                    ip2axi_rddata_s2mm_ch2 <= ip2axi_rddata_s2mm_ch (159 downto 128);
                when "001"  =>
                    ip2axi_rddata_s2mm_ch2 <= ip2axi_rddata_s2mm_ch (191 downto 160);
                when "010" =>
                    ip2axi_rddata_s2mm_ch2 <= ip2axi_rddata_s2mm_ch (223 downto 192);
                when "011" =>
                    ip2axi_rddata_s2mm_ch2 <= ip2axi_rddata_s2mm_ch (255 downto 224);
          -- coverage off
                when others =>
                    ip2axi_rddata_s2mm_ch2 <= (others => '0');
          -- coverage on
            end case;
        end process AXI_LITE_READ_MUX_CH1;

end generate CHANNELS_2;


CHANNELS_2_NOT : if (C_NUM_S2MM_CHANNELS < 3) generate
begin
                    ip2axi_rddata_s2mm_ch2 <= (others => '0');

end generate CHANNELS_2_NOT;


CHANNELS_3 : if (C_NUM_S2MM_CHANNELS > 7) generate
begin
    AXI_LITE_READ_MUX_CH1 : process(read_addr(8 downto 6)            ,
                                ip2axi_rddata_s2mm_ch(383 downto 256)             
)
        begin
            case read_addr(8 downto 6) is
                when "100" =>
                    ip2axi_rddata_s2mm_ch3 <= ip2axi_rddata_s2mm_ch (287 downto 256);
                when "101"  =>
                    ip2axi_rddata_s2mm_ch3 <= ip2axi_rddata_s2mm_ch (319 downto 288);
                when "110" =>
                    ip2axi_rddata_s2mm_ch3 <= ip2axi_rddata_s2mm_ch (351 downto 320);
                when "111" =>
                    ip2axi_rddata_s2mm_ch3 <= ip2axi_rddata_s2mm_ch (383 downto 352);
          -- coverage off
                when others =>
                    ip2axi_rddata_s2mm_ch3 <= (others => '0');
          -- coverage on
            end case;
        end process AXI_LITE_READ_MUX_CH1;

end generate CHANNELS_3;


CHANNELS_3_NOT : if (C_NUM_S2MM_CHANNELS < 7) generate
begin
                    ip2axi_rddata_s2mm_ch3 <= (others => '0');

end generate CHANNELS_3_NOT;


CHANNELS_4 : if (C_NUM_S2MM_CHANNELS > 11) generate
begin
    AXI_LITE_READ_MUX_CH1 : process(read_addr(8 downto 6)            ,
                                ip2axi_rddata_s2mm_ch(511 downto 384)             
)
        begin
            case read_addr(8 downto 6) is
                when "000" =>
                    ip2axi_rddata_s2mm_ch4 <= ip2axi_rddata_s2mm_ch (415 downto 384);
                when "001"  =>
                    ip2axi_rddata_s2mm_ch4 <= ip2axi_rddata_s2mm_ch (447 downto 416);
                when "010" =>
                    ip2axi_rddata_s2mm_ch4 <= ip2axi_rddata_s2mm_ch (479 downto 448);
                when "011" =>
                    ip2axi_rddata_s2mm_ch4 <= ip2axi_rddata_s2mm_ch (511 downto 480);
          -- coverage off
                when others =>
                    ip2axi_rddata_s2mm_ch4 <= (others => '0');
          -- coverage on
            end case;
        end process AXI_LITE_READ_MUX_CH1;

end generate CHANNELS_4;


CHANNELS_4_NOT : if (C_NUM_S2MM_CHANNELS < 11) generate
begin
                    ip2axi_rddata_s2mm_ch4 <= (others => '0');

end generate CHANNELS_4_NOT;



    AXI_LITE_READ_MUX_CH1 : process(read_addr(8 downto 6)            ,
                                ip2axi_rddata_s2mm_ch(543 downto 512)             ,
                                ip2axi_rddata_s2mm_obs_ch 
)
        begin
            case read_addr(8 downto 6) is
                when "100" =>
                    ip2axi_rddata_s2mm_ch5 <= ip2axi_rddata_s2mm_ch (543 downto 512);
                when "101" =>
                    ip2axi_rddata_s2mm_ch5 <= ip2axi_rddata_s2mm_obs_ch;
          -- coverage off
                when others =>
                    ip2axi_rddata_s2mm_ch5 <= (others => '0');
          -- coverage on
            end case;
        end process AXI_LITE_READ_MUX_CH1;




end generate GEN_S2MM_REGISTERS;


process (m_axi_sg_aclk)
begin
   if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then

         case (axi2ip_rdaddr(11 downto 8)) is
             when "0000" =>
                ip2axi_rddata <= ip2axi_rddata_mm2s_ch1; 

             when "0001" =>
                ip2axi_rddata <= ip2axi_rddata_mm2s_ch2; 

             when "0010" =>
                ip2axi_rddata <= ip2axi_rddata_mm2s_ch3; 

             when "0011" =>
                ip2axi_rddata <= ip2axi_rddata_mm2s_ch4; 

             when "0100" =>
                ip2axi_rddata <= ip2axi_rddata_mm2s_ch5; 

             when "0101" =>
                ip2axi_rddata <= ip2axi_rddata_s2mm_ch1; 

             when "0110" =>
                ip2axi_rddata <= ip2axi_rddata_s2mm_ch2; 

             when "0111" =>
                ip2axi_rddata <= ip2axi_rddata_s2mm_ch3; 

             when "1000" =>
                ip2axi_rddata <= ip2axi_rddata_s2mm_ch4; 

             when "1001" =>
                ip2axi_rddata <= ip2axi_rddata_s2mm_ch5; 
          -- coverage off
             when others =>
                ip2axi_rddata <= (others => '0');
          -- coverage on
         end case;

   end if;
end process;
        

end generate GEN_READ_MUX_FOR_SG;

GEN_READ_MUX_FOR_NOSG : if C_INCLUDE_SG = 0 generate
begin
     ip2axi_rddata <= (others => '0');
end generate GEN_READ_MUX_FOR_NOSG;


end implementation;



--  (c) Copyright 2012 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
------------------------------------------------------------
-------------------------------------------------------------------------------
-- Filename:        axi_mcdma_skid_buf.vhd
--
-- Description:
--  Implements the AXi Skid Buffer in the Option 2 (Registerd outputs) mode.
--
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-------------------------------------------------------------------------------

entity axi_mcdma_skid_buf is
  generic (
    C_WDATA_WIDTH : INTEGER range 8 to 256 := 32
       --  Width of the Stream Data bus (in bits)

    );
  port (
  -- System Ports
     ACLK         : In  std_logic ;                                         --
     ARST         : In  std_logic ;                                         --
                                                                            --
   -- Shutdown control (assert for 1 clk pulse)                             --
     skid_stop    : In std_logic  ;                                         --
   -- Slave Side (Stream Data Input)                                        --
     S_VALID      : In  std_logic ;                                         --
     S_READY      : Out std_logic ;                                         --
     S_Data       : In  std_logic_vector(C_WDATA_WIDTH-1 downto 0);         --
     S_STRB       : In  std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0);     --
     S_Last       : In  std_logic ;                                         --
                                                                            --
   -- Master Side (Stream Data Output                                       --
     M_VALID      : Out std_logic ;                                         --
     M_READY      : In  std_logic ;                                         --
     M_Data       : Out std_logic_vector(C_WDATA_WIDTH-1 downto 0);         --
     M_STRB       : Out std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0);     --
     M_Last       : Out std_logic                                           --
    );

end entity axi_mcdma_skid_buf;


architecture implementation of axi_mcdma_skid_buf is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";



-- Signals decalrations -------------------------

  Signal sig_reset_reg         : std_logic := '0';
  signal sig_spcl_s_ready_set  : std_logic := '0';

  signal sig_data_skid_reg     : std_logic_vector(C_WDATA_WIDTH-1 downto 0) := (others => '0');
  signal sig_strb_skid_reg     : std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0) := (others => '0');
  signal sig_last_skid_reg     : std_logic := '0';
  signal sig_skid_reg_en       : std_logic := '0';

  signal sig_data_skid_mux_out : std_logic_vector(C_WDATA_WIDTH-1 downto 0) := (others => '0');
  signal sig_strb_skid_mux_out : std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0) := (others => '0');
  signal sig_last_skid_mux_out : std_logic := '0';
  signal sig_skid_mux_sel      : std_logic := '0';

  signal sig_data_reg_out      : std_logic_vector(C_WDATA_WIDTH-1 downto 0) := (others => '0');
  signal sig_strb_reg_out      : std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0) := (others => '0');
  signal sig_last_reg_out      : std_logic := '0';
  signal sig_data_reg_out_en   : std_logic := '0';

  signal sig_m_valid_out       : std_logic := '0';
  signal sig_m_valid_dup       : std_logic := '0';
  signal sig_m_valid_comb      : std_logic := '0';

  signal sig_s_ready_out       : std_logic := '0';
  signal sig_s_ready_dup       : std_logic := '0';
  signal sig_s_ready_comb      : std_logic := '0';

  signal sig_stop_request      : std_logic := '0';
  signal sig_stopped           : std_logic := '0';
  signal sig_sready_stop       : std_logic := '0';
  signal sig_sready_stop_reg   : std_logic := '0';
  signal sig_s_last_xfered     : std_logic := '0';

  signal sig_m_last_xfered     : std_logic := '0';
  signal sig_mvalid_stop_reg   : std_logic := '0';
  signal sig_mvalid_stop       : std_logic := '0';

  signal sig_slast_with_stop   : std_logic := '0';
  signal sig_sstrb_stop_mask   : std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0) := (others => '0');
  signal sig_sstrb_with_stop   : std_logic_vector((C_WDATA_WIDTH/8)-1 downto 0) := (others => '0');


-- Register duplication attribute assignments to control fanout
-- on handshake output signals

  Attribute KEEP : string; -- declaration
  Attribute EQUIVALENT_REGISTER_REMOVAL : string; -- declaration

  Attribute KEEP of sig_m_valid_out : signal is "TRUE"; -- definition
  Attribute KEEP of sig_m_valid_dup : signal is "TRUE"; -- definition
  Attribute KEEP of sig_s_ready_out : signal is "TRUE"; -- definition
  Attribute KEEP of sig_s_ready_dup : signal is "TRUE"; -- definition

  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_m_valid_out : signal is "no";
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_m_valid_dup : signal is "no";
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_s_ready_out : signal is "no";
  Attribute EQUIVALENT_REGISTER_REMOVAL of sig_s_ready_dup : signal is "no";




begin --(architecture implementation)

   M_VALID <= sig_m_valid_out;
   S_READY <= sig_s_ready_out;

   M_STRB  <= sig_strb_reg_out;
   M_Last  <= sig_last_reg_out;
   M_Data  <= sig_data_reg_out;

  -- Special shutdown logic version od Slast.
  -- A halt request forces a tlast through the skig buffer
  sig_slast_with_stop <= s_last or sig_stop_request;
  sig_sstrb_with_stop <= s_strb or sig_sstrb_stop_mask;
  -- Assign the special S_READY FLOP set signal
  sig_spcl_s_ready_set <= sig_reset_reg;


  -- Generate the ouput register load enable control
   sig_data_reg_out_en <= M_READY or not(sig_m_valid_dup);

  -- Generate the skid input register load enable control
   sig_skid_reg_en     <= sig_s_ready_dup;

  -- Generate the skid mux select control
   sig_skid_mux_sel    <= not(sig_s_ready_dup);


 -- Skid Mux
   sig_data_skid_mux_out <=  sig_data_skid_reg
     When (sig_skid_mux_sel = '1')
     Else  S_Data;

   sig_strb_skid_mux_out <=  sig_strb_skid_reg
     When (sig_skid_mux_sel = '1')
     Else  sig_sstrb_with_stop;

   sig_last_skid_mux_out <=  sig_last_skid_reg
     When (sig_skid_mux_sel = '1')
     Else  sig_slast_with_stop;


   -- m_valid combinational logic
   sig_m_valid_comb <= S_VALID or
                      (sig_m_valid_dup and
                      (not(sig_s_ready_dup) or
                       not(M_READY)));



   -- s_ready combinational logic
   sig_s_ready_comb <= M_READY or
                      (sig_s_ready_dup and
                      (not(sig_m_valid_dup) or
                       not(S_VALID)));



   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: REG_THE_RST
   --
   -- Process Description:
   -- Register input reset
   --
   -------------------------------------------------------------
   REG_THE_RST : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then

            sig_reset_reg <= ARST;

        end if;
      end process REG_THE_RST;




   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: S_READY_FLOP
   --
   -- Process Description:
   -- Registers S_READY handshake signals per Skid Buffer
   -- Option 2 scheme
   --
   -------------------------------------------------------------
   S_READY_FLOP : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST            = '1' or
               sig_sready_stop = '1') then  -- Special stop condition

             sig_s_ready_out  <= '0';
             sig_s_ready_dup  <= '0';

           Elsif (sig_spcl_s_ready_set = '1') Then

             sig_s_ready_out  <= '1';
             sig_s_ready_dup  <= '1';

           else

             sig_s_ready_out  <= sig_s_ready_comb;
             sig_s_ready_dup  <= sig_s_ready_comb;

           end if;
        end if;
      end process S_READY_FLOP;






   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: M_VALID_FLOP
   --
   -- Process Description:
   -- Registers M_VALID handshake signals per Skid Buffer
   -- Option 2 scheme
   --
   -------------------------------------------------------------
   M_VALID_FLOP : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST                 = '1' or
               sig_spcl_s_ready_set = '1' or    -- Fix from AXI DMA
               sig_mvalid_stop      = '1') then -- Special stop condition
             sig_m_valid_out  <= '0';
             sig_m_valid_dup  <= '0';

           else

             sig_m_valid_out  <= sig_m_valid_comb;
             sig_m_valid_dup  <= sig_m_valid_comb;

           end if;
        end if;
      end process M_VALID_FLOP;






   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: SKID_REG
   --
   -- Process Description:
   -- This process implements the output registers for the
   -- Skid Buffer Data signals
   --
   -------------------------------------------------------------
   SKID_REG : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST = '1') then

             sig_data_skid_reg <= (others => '0');
             sig_strb_skid_reg <= (others => '0');
             sig_last_skid_reg <= '0';

           elsif (sig_skid_reg_en = '1') then

             sig_data_skid_reg <= S_Data;
             sig_strb_skid_reg <= sig_sstrb_with_stop;
             sig_last_skid_reg <= sig_slast_with_stop;

           else
             null;  -- hold current state
           end if;
        end if;
      end process SKID_REG;





   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: OUTPUT_REG
   --
   -- Process Description:
   -- This process implements the output registers for the
   -- Skid Buffer Data signals
   --
   -------------------------------------------------------------
   OUTPUT_REG : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST                = '1' or
               sig_mvalid_stop_reg = '1') then

             --sig_data_reg_out <= (others => '0');         -- CR585409
             sig_strb_reg_out <= (others => '0');
             sig_last_reg_out <= '0';

           elsif (sig_data_reg_out_en = '1') then

             --sig_data_reg_out <= sig_data_skid_mux_out;   -- CR585409
             sig_strb_reg_out <= sig_strb_skid_mux_out;
             sig_last_reg_out <= sig_last_skid_mux_out;

           else
             null;  -- hold current state
           end if;
        end if;
      end process OUTPUT_REG;

   -- CR585409 - To lower reset fanout and improve FPGA fmax timing
   -- resets have been removed from AXI Stream data buses
   DATA_OUTPUT_REG : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (sig_data_reg_out_en = '1') then
             sig_data_reg_out <= sig_data_skid_mux_out;
           else
             null;  -- hold current state
           end if;
        end if;
      end process DATA_OUTPUT_REG;



   -------- Special Stop Logic --------------------------------------


   sig_s_last_xfered  <=  sig_s_ready_dup and
                          s_valid         and
                          sig_slast_with_stop;


   sig_sready_stop    <=  (sig_s_last_xfered and
                          sig_stop_request) or
                          sig_sready_stop_reg;






   sig_m_last_xfered  <=  sig_m_valid_dup and
                          m_ready         and
                          sig_last_reg_out;


   sig_mvalid_stop    <=  (sig_m_last_xfered and
                          sig_stop_request)  or
                          sig_mvalid_stop_reg;




   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: IMP_STOP_REQ_FLOP
   --
   -- Process Description:
   -- This process implements the Stop request flop. It is a
   -- sample and hold register that can only be cleared by reset.
   --
   -------------------------------------------------------------
   IMP_STOP_REQ_FLOP : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST = '1') then

             sig_stop_request <= '0';
             sig_sstrb_stop_mask <= (others => '0');

           elsif (skid_stop = '1') then

             sig_stop_request <= '1';
             sig_sstrb_stop_mask <= (others => '1');

           else
             null;  -- hold current state
           end if;
        end if;
      end process IMP_STOP_REQ_FLOP;









   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: IMP_CLR_SREADY_FLOP
   --
   -- Process Description:
   -- This process implements the flag to clear the s_ready
   -- flop at a stop condition.
   --
   -------------------------------------------------------------
   IMP_CLR_SREADY_FLOP : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST = '1') then

             sig_sready_stop_reg <= '0';

           elsif (sig_s_last_xfered = '1' and
                  sig_stop_request  = '1') then

             sig_sready_stop_reg <= '1';

           else
             null;  -- hold current state
           end if;
        end if;
      end process IMP_CLR_SREADY_FLOP;





   -------------------------------------------------------------
   -- Synchronous Process with Sync Reset
   --
   -- Label: IMP_CLR_MREADY_FLOP
   --
   -- Process Description:
   -- This process implements the flag to clear the m_ready
   -- flop at a stop condition.
   --
   -------------------------------------------------------------
   IMP_CLR_MVALID_FLOP : process (ACLK)
      begin
        if (ACLK'event and ACLK = '1') then
           if (ARST = '1') then

             sig_mvalid_stop_reg <= '0';

           elsif (sig_m_last_xfered = '1' and
                  sig_stop_request  = '1') then

             sig_mvalid_stop_reg <= '1';

           else
             null;  -- hold current state
           end if;
        end if;
      end process IMP_CLR_MVALID_FLOP;



end implementation;


--  (c) Copyright 2012 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
------------------------------------------------------------
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:        axi_mcdma_afifo_autord.vhd
-- Version:         initial
-- Description:
--    This file contains the logic to generate a CoreGen call to create a
-- asynchronous FIFO as part of the synthesis process of XST. This eliminates
-- the need for multiple fixed netlists for various sizes and widths of FIFOs.
--
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;

library lib_cdc_v1_0_2;
library lib_fifo_v1_0_16;
use lib_fifo_v1_0_16.async_fifo_fg;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;


-----------------------------------------------------------------------------
-- Entity section
-----------------------------------------------------------------------------

entity axi_mcdma_afifo_autord is
  generic (
     C_DWIDTH        : integer := 32;
     C_DEPTH         : integer := 16;
     C_CNT_WIDTH     : Integer := 5;
     C_USE_BLKMEM    : Integer := 0 ;
     C_USE_AUTORD    : Integer := 1;
     C_PRMRY_IS_ACLK_ASYNC : integer := 1;
     C_FAMILY        : String  := "virtex7"
    );
  port (
    -- Inputs
     AFIFO_Ainit                : In  std_logic;                                 --
     AFIFO_Wr_clk               : In  std_logic;                                 --
     AFIFO_Wr_en                : In  std_logic;                                 --
     AFIFO_Din                  : In  std_logic_vector(C_DWIDTH-1 downto 0);     --
     AFIFO_Rd_clk               : In  std_logic;                                 --
     AFIFO_Rd_en                : In  std_logic;                                 --
     AFIFO_Clr_Rd_Data_Valid    : In  std_logic;                                 --
                                                                                 --
    -- Outputs                                                                   --
     AFIFO_DValid               : Out std_logic;                                 --
     AFIFO_Dout                 : Out std_logic_vector(C_DWIDTH-1 downto 0);     --
     AFIFO_Full                 : Out std_logic;                                 --
     AFIFO_Empty                : Out std_logic;                                 --
     AFIFO_Almost_full          : Out std_logic;                                 --
     AFIFO_Almost_empty         : Out std_logic;                                 --
     AFIFO_Wr_count             : Out std_logic_vector(C_CNT_WIDTH-1 downto 0);  --
     AFIFO_Rd_count             : Out std_logic_vector(C_CNT_WIDTH-1 downto 0);  --
     AFIFO_Corr_Rd_count        : Out std_logic_vector(C_CNT_WIDTH downto 0);    --
     AFIFO_Corr_Rd_count_minus1 : Out std_logic_vector(C_CNT_WIDTH downto 0);    --
     AFIFO_Rd_ack               : Out std_logic                                  --
    );
end entity axi_mcdma_afifo_autord;


-----------------------------------------------------------------------------
-- Architecture section
-----------------------------------------------------------------------------

architecture imp of axi_mcdma_afifo_autord is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of imp : architecture is "yes";

-- Constant declarations
  ATTRIBUTE async_reg                      : STRING;


-- Signal declarations
   signal write_data_lil_end       : std_logic_vector(C_DWIDTH-1 downto 0) := (others => '0');
   signal read_data_lil_end        : std_logic_vector(C_DWIDTH-1 downto 0) := (others => '0');

   signal wr_count_lil_end         : std_logic_vector(C_CNT_WIDTH-1 downto 0) := (others => '0');
   signal rd_count_lil_end         : std_logic_vector(C_CNT_WIDTH-1 downto 0) := (others => '0');
   signal rd_count_int             : integer range 0 to C_DEPTH+1 := 0;
   signal rd_count_int_corr        : integer range 0 to C_DEPTH+1 := 0;
   signal rd_count_int_corr_minus1 : integer range 0 to C_DEPTH+1 := 0;


   Signal corrected_empty          : std_logic := '0';
   Signal corrected_almost_empty   : std_logic := '0';
   Signal sig_afifo_empty          : std_logic := '0';
   Signal sig_afifo_almost_empty   : std_logic := '0';


 -- backend fifo read ack sample and hold
   Signal sig_rddata_valid         : std_logic := '0';
   Signal hold_ff_q                : std_logic := '0';
   Signal ored_ack_ff_reset        : std_logic := '0';
   Signal autoread                 : std_logic := '0';
   Signal sig_wrfifo_rdack         : std_logic := '0';
   Signal fifo_read_enable         : std_logic := '0';

   Signal first_write              : std_logic := '0';
   Signal first_read_cdc_tig               : std_logic := '0';
   Signal first_read1              : std_logic := '0';
   Signal first_read2              : std_logic := '0';
   signal AFIFO_Ainit_d1_cdc_tig   : std_logic;
   signal AFIFO_Ainit_d2   : std_logic;

  --ATTRIBUTE async_reg OF AFIFO_Ainit_d1_cdc_tig  : SIGNAL IS "true";
  --ATTRIBUTE async_reg OF AFIFO_Ainit_d2 : SIGNAL IS "true";

  --ATTRIBUTE async_reg OF first_read_cdc_tig  : SIGNAL IS "true";
  --ATTRIBUTE async_reg OF first_read1 : SIGNAL IS "true";

-- Component declarations



-----------------------------------------------------------------------------
-- Begin architecture
-----------------------------------------------------------------------------
begin

 -- Bit ordering translations

    write_data_lil_end   <=  AFIFO_Din;  -- translate from Big Endian to little
                                         -- endian.
    AFIFO_Rd_ack         <= sig_wrfifo_rdack;

    AFIFO_Dout           <= read_data_lil_end;  -- translate from Little Endian to
                                                -- Big endian.

    AFIFO_Almost_empty   <= corrected_almost_empty;
GEN_EMPTY : if (C_USE_AUTORD = 1) generate
begin
  --  AFIFO_Empty          <= corrected_empty;
    AFIFO_Empty          <= sig_afifo_empty;
end generate GEN_EMPTY;
GEN_EMPTY1 : if (C_USE_AUTORD = 0) generate
begin
    AFIFO_Empty          <= sig_afifo_empty;
end generate GEN_EMPTY1;

    AFIFO_Wr_count       <= wr_count_lil_end;

    AFIFO_Rd_count       <= rd_count_lil_end;

    AFIFO_Corr_Rd_count  <= CONV_STD_LOGIC_VECTOR(rd_count_int_corr,
                                                  C_CNT_WIDTH+1);

    AFIFO_Corr_Rd_count_minus1 <= CONV_STD_LOGIC_VECTOR(rd_count_int_corr_minus1,
                                                        C_CNT_WIDTH+1);

    AFIFO_DValid         <= sig_rddata_valid; -- Output data valid indicator


    fifo_read_enable     <= AFIFO_Rd_en;-- or autoread;



   -------------------------------------------------------------------------------
   -- Instantiate the CoreGen FIFO
   --
   -- NOTE:
   -- This instance refers to a wrapper file that interm will use the
   -- CoreGen FIFO Generator Async FIFO utility.
   --
   -------------------------------------------------------------------------------
    I_ASYNC_FIFOGEN_FIFO : entity lib_fifo_v1_0_16.async_fifo_fg
       generic map (
--          C_ALLOW_2N_DEPTH      =>  1,
          C_ALLOW_2N_DEPTH      =>  0,
          C_FAMILY              =>  C_FAMILY,
          C_DATA_WIDTH          =>  C_DWIDTH,
          C_ENABLE_RLOCS        =>  0,
          C_FIFO_DEPTH          =>  C_DEPTH,
          C_HAS_ALMOST_EMPTY    =>  1,
          C_HAS_ALMOST_FULL     =>  1,
          C_HAS_RD_ACK          =>  1,
          C_HAS_RD_COUNT        =>  1,
          C_EN_SAFETY_CKT       =>  1,
          C_HAS_RD_ERR          =>  0,
          C_HAS_WR_ACK          =>  0,
          C_HAS_WR_COUNT        =>  1,
          C_HAS_WR_ERR          =>  0,
          C_RD_ACK_LOW          =>  0,
          C_RD_COUNT_WIDTH      =>  C_CNT_WIDTH,
          C_RD_ERR_LOW          =>  0,
          C_USE_BLOCKMEM        =>  C_USE_BLKMEM,
          C_WR_ACK_LOW          =>  0,
          C_WR_COUNT_WIDTH      =>  C_CNT_WIDTH,
          C_WR_ERR_LOW          =>  0,
          C_SYNCHRONIZER_STAGE  =>  C_FIFO_MTBF,
          C_USE_EMBEDDED_REG    =>  0, -- 0 ;
          C_PRELOAD_REGS        =>  1, -- 0 ;
          C_PRELOAD_LATENCY     =>  0,  -- 1 ;
          C_XPM_FIFO            =>  1
         )
      port Map (
         Din                 =>  write_data_lil_end,
         Wr_en               =>  AFIFO_Wr_en,
         Wr_clk              =>  AFIFO_Wr_clk,
         Rd_en               =>  fifo_read_enable,
         Rd_clk              =>  AFIFO_Rd_clk,
         Ainit               =>  AFIFO_Ainit,
         Dout                =>  read_data_lil_end,
         Full                =>  AFIFO_Full,
         Empty               =>  sig_afifo_empty,
         Almost_full         =>  AFIFO_Almost_full,
         Almost_empty        =>  sig_afifo_almost_empty,
         Wr_count            =>  wr_count_lil_end,
         Rd_count            =>  rd_count_lil_end,
         Rd_ack              =>  sig_wrfifo_rdack,
         Rd_err              =>  open,              -- Not used by axi_mcdma
         Wr_ack              =>  open,              -- Not used by axi_mcdma
         Wr_err              =>  open               -- Not used by axi_mcdma
        );


   ----------------------------------------------------------------------------
   -- Read Ack assert & hold logic (needed because:
   --     1) The Async FIFO has to be read once to get valid
   --        data to the read data port (data is discarded).
   --     2) The Read ack from the fifo is only asserted for 1 clock.
   --     3) A signal is needed that indicates valid data is at the read
   --        port of the FIFO and has not yet been read. This signal needs
   --        to be held until the next read operation occurs or a clear
   --        signal is received.


    ored_ack_ff_reset  <=  fifo_read_enable or
                           AFIFO_Ainit_d2 or
                           AFIFO_Clr_Rd_Data_Valid;

    sig_rddata_valid   <=  hold_ff_q or
                           sig_wrfifo_rdack;




    -------------------------------------------------------------
    -- Synchronous Process with Sync Reset
    --
    -- Label: IMP_ACK_HOLD_FLOP
    --
    -- Process Description:
    --  Flop for registering the hold flag
    --
    -------------------------------------------------------------
ASYNC_CDC_SYNC : if C_PRMRY_IS_ACLK_ASYNC = 1 generate

IMP_SYNC_FLOP : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_FLOP_INPUT               => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => AFIFO_Ainit,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => AFIFO_Rd_clk,
        scndry_resetn              => '0',
        scndry_out                 => AFIFO_Ainit_d2,
        scndry_vect_out            => open
    );
end generate ASYNC_CDC_SYNC;

SYNC_CDC_SYNC : if C_PRMRY_IS_ACLK_ASYNC = 0 generate

        AFIFO_Ainit_d2 <= AFIFO_Ainit;

end generate SYNC_CDC_SYNC;

--    IMP_SYNC_FLOP : process (AFIFO_Rd_clk)
--       begin
--         if (AFIFO_Rd_clk'event and AFIFO_Rd_clk = '1') then
--             AFIFO_Ainit_d1_cdc_tig <= AFIFO_Ainit;
--             AFIFO_Ainit_d2 <= AFIFO_Ainit_d1_cdc_tig;
--         end if;
--       end process IMP_SYNC_FLOP;

    IMP_ACK_HOLD_FLOP : process (AFIFO_Rd_clk)
       begin
         if (AFIFO_Rd_clk'event and AFIFO_Rd_clk = '1') then
           if (ored_ack_ff_reset = '1') then
             hold_ff_q  <= '0';
           else
             hold_ff_q  <= sig_rddata_valid;
           end if;
         end if;
       end process IMP_ACK_HOLD_FLOP;



   --  I_ACK_HOLD_FF : FDRE
   --    port map(
   --      Q  =>  hold_ff_q,
   --      C  =>  AFIFO_Rd_clk,
   --      CE =>  '1',
   --      D  =>  sig_rddata_valid,
   --      R  =>  ored_ack_ff_reset
   --    );



  -- generate auto-read enable. This keeps fresh data at the output
  -- of the FIFO whenever it is available.

GEN_AUTORD1 : if C_USE_AUTORD = 1 generate
    autoread <= '1'                     -- create a read strobe when the
      when (sig_rddata_valid = '0' and  -- output data is NOT valid
            sig_afifo_empty = '0')      -- and the FIFO is not empty
      Else '0';
end generate GEN_AUTORD1;


GEN_AUTORD2 : if C_USE_AUTORD = 0 generate
    process (AFIFO_Wr_clk)
    begin
       if (AFIFO_Wr_clk'event and AFIFO_Wr_clk = '1') then
          if (AFIFO_Ainit = '0') then
              first_write <= '0';
          elsif (AFIFO_Wr_en = '1') then
                 first_write <= '1';
          end if;
       end if; 
    end process;



IMP_SYNC_FLOP1 : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => first_write,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => AFIFO_Rd_clk,
        scndry_resetn              => '0',
        scndry_out                 => first_read1,
        scndry_vect_out            => open
    );

    process (AFIFO_Rd_clk)
    begin
           if (AFIFO_Rd_clk'event and AFIFO_Rd_clk = '1') then
              if (AFIFO_Ainit_d2 = '0') then 
                first_read2 <= '0';
              elsif (sig_afifo_empty = '0') then
                 first_read2 <= first_read1;
              end if;
           end if; 
    end process;
    autoread <= first_read1 xor first_read2;             

end generate GEN_AUTORD2;


    rd_count_int <=  CONV_INTEGER(rd_count_lil_end);


    -------------------------------------------------------------
    -- Combinational Process
    --
    -- Label: CORRECT_RD_CNT
    --
    -- Process Description:
    --  This process corrects the FIFO Read Count output for the
    -- auto read function.
    --
    -------------------------------------------------------------
    CORRECT_RD_CNT : process (sig_rddata_valid,
                              sig_afifo_empty,
                              sig_afifo_almost_empty,
                              rd_count_int)
       begin

          if (sig_rddata_valid = '0') then

             rd_count_int_corr        <= 0;
             rd_count_int_corr_minus1 <= 0;
             corrected_empty          <= '1';
             corrected_almost_empty   <= '0';

          elsif (sig_afifo_empty = '1') then         -- rddata valid and fifo empty

             rd_count_int_corr        <= 1;
             rd_count_int_corr_minus1 <= 0;
             corrected_empty          <= '0';
             corrected_almost_empty   <= '1';

          Elsif (sig_afifo_almost_empty = '1') Then  -- rddata valid and fifo almost empty

             rd_count_int_corr        <= 2;
             rd_count_int_corr_minus1 <= 1;
             corrected_empty          <= '0';
             corrected_almost_empty   <= '0';

          else                                   -- rddata valid and modify rd count from FIFO

             rd_count_int_corr        <= rd_count_int+1;
             rd_count_int_corr_minus1 <= rd_count_int;
             corrected_empty          <= '0';
             corrected_almost_empty   <= '0';

          end if;

       end process CORRECT_RD_CNT;



end imp;


--  (c) Copyright 2012 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

entity axi_mcdma_pkt_drop is
     generic (
             C_FAMILY : string := "virtex7";
             C_COMMON : integer range 0 to 1 := 0;
             C_CHANNEL_ID : integer range 0 to 16 := 1; -- 0 for common, 1 and above for channels
             C_ENABLE_DROP_CNT : integer range 0 to 1 := 1;
             C_ENABLE_SINGLE_INTR : integer range 0 to 1 := 1
             );
     port (
           m_axi_sg_aclk        : in std_logic;
           m_axi_sg_aresetn     : in std_logic;
           packet_dropped       : in std_logic;   -- packet drop trigger
           dropped_ch_id        : in std_logic_vector (3 downto 0);   -- dropped channel id

           packet_thresh        : in std_logic_vector (7 downto 0); -- threshold from register
           packet_thresh_wren   : in std_logic;
           packet_thresh_sts    : out std_logic_vector (7 downto 0); --to register
           packet_irq           : out std_logic;
  
           reset_pkt_drp_count : in std_logic;      
           channel_packet_drop_cnt : out std_logic_vector (15 downto 0);
           total_packet_drop_cnt : out std_logic_vector (31 downto 0) 
           
          );
end entity axi_mcdma_pkt_drop;

architecture implementation of axi_mcdma_pkt_drop is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

constant MATCH_ID  : std_logic_vector(3 downto 0) := std_logic_vector(to_unsigned(C_CHANNEL_ID,4));


signal packet_thresh_int : std_logic_vector (7 downto 0);
signal packet_irq_i : std_logic;
signal decrement : std_logic;
signal matchid : std_logic;

signal increment : std_logic;
signal channel_drp_cnt : std_logic_vector (15 downto 0);
signal total_drp_cnt : std_logic_vector (31 downto 0);

begin

COMMON: if C_COMMON = 0 generate
begin

decrement <= packet_dropped;


--NOSEPARATE_INTR : if C_ENABLE_SINGLE_INTR = 1 generate
--begin

--process (m_axi_sg_aclk)
--begin
--    if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
--       if (m_axi_sg_aresetn = '0') then
--          packet_thresh_int <= x"01";
--          packet_irq_i <= '0';
--       elsif (packet_thresh_wren = '1') then
--          packet_thresh_int <= packet_thresh;
--       elsif (decrement = '1') then
--          if (packet_thresh_int = x"01") then
--             packet_thresh_int <= packet_thresh;
--             packet_irq_i <= '1'; 
--          else 
--             packet_thresh_int <= std_logic_vector(unsigned(packet_thresh_int(7 downto 0)) - 1);
--             packet_irq_i <= '0'; 
--          end if;
--       else
--             packet_thresh_int <= packet_thresh_int;
--             packet_irq_i <= '0'; 
--       end if;
--    end if;
--end process;

--packet_thresh_sts <= packet_thresh_int;
--packet_irq <= packet_irq_i;
         
--end generate NOSEPARATE_INTR;                  

SEPARATE_INTR: if C_ENABLE_SINGLE_INTR = 0 generate
begin

packet_thresh_sts <= x"00";
packet_irq <= '0';

end generate SEPARATE_INTR;


end generate COMMON;


CCHANNEL: if C_COMMON > 0 generate
begin

matchid <= '1' when (dropped_ch_id = MATCH_ID) else '0';
decrement <= packet_dropped when (matchid = '1') else '0';



SEPARATE_INTR : if C_ENABLE_SINGLE_INTR = 0 generate
begin

process (m_axi_sg_aclk)
begin
    if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
       if (m_axi_sg_aresetn = '0') then
          packet_thresh_int <= x"01";
          packet_irq_i <= '0';
       elsif (packet_thresh_wren = '1') then
          packet_thresh_int <= packet_thresh;
       elsif (decrement = '1') then
          if (packet_thresh_int = x"01") then
             packet_thresh_int <= packet_thresh;
             packet_irq_i <= '1'; 
          else 
             packet_thresh_int <= std_logic_vector(unsigned(packet_thresh_int(7 downto 0)) - 1);
             packet_irq_i <= '0'; 
          end if;
       else
             packet_thresh_int <= packet_thresh_int;
             packet_irq_i <= '0'; 
       end if;
    end if;
end process;

packet_thresh_sts <= packet_thresh_int;
packet_irq <= packet_irq_i;
         
end generate SEPARATE_INTR;                  

--SINGLE_INTR: if C_ENABLE_SINGLE_INTR = 1 generate
--begin

--packet_thresh_sts <= x"01";
--packet_irq <= '0';

--end generate SINGLE_INTR;
end generate CCHANNEL;


DROP_COUNT: if C_ENABLE_DROP_CNT = 1 generate
begin

COMMON: if C_COMMON = 0 generate
begin

increment <= packet_dropped;


process (m_axi_sg_aclk)
begin
    if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
       if (m_axi_sg_aresetn = '0') then
           total_drp_cnt <= (others => '0');
       elsif (increment = '1') then
           total_drp_cnt <= std_logic_vector(unsigned(total_drp_cnt(31 downto 0)) + 1);
       end if;
    end if;
end process;

total_packet_drop_cnt <= total_drp_cnt;
             
channel_packet_drop_cnt <= (others => '0');

end generate COMMON;


CCHANNEL: if C_COMMON > 0 generate
begin


--matchid <= '1' when (dropped_ch_id = MATCH_ID) else '0';
increment <= packet_dropped when (matchid = '1') else '0';


process (m_axi_sg_aclk)
begin
    if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
       if (m_axi_sg_aresetn = '0') then
           channel_drp_cnt <= (others => '0');
       elsif (reset_pkt_drp_count = '1') then
           channel_drp_cnt <= (others => '0');
       elsif (increment = '1') then
           channel_drp_cnt <= std_logic_vector(unsigned(channel_drp_cnt(15 downto 0)) + 1);
       end if;
    end if;
end process;


     total_packet_drop_cnt   <= (others => '0');
channel_packet_drop_cnt <= channel_drp_cnt;


end generate CCHANNEL;

end generate DROP_COUNT; 


NODROP_COUNT: if C_ENABLE_DROP_CNT = 0 generate
begin


     channel_packet_drop_cnt <= (others => '0');
     total_packet_drop_cnt   <= (others => '0');


end generate NODROP_COUNT; 

end implementation;


--  (c) Copyright 2012 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;
library lib_fifo_v1_0_16;

library lib_cdc_v1_0_2;

entity axi_mcdma_s2mm_tdest is
     generic (
             C_FAMILY : string := "virtex7";
             C_MAX_CHANNELS : integer range 1 to 16 := 1;
             C_NUM_S2MM_CHANNELS : integer range 1 to 16 := 1;
             C_ENABLE_SINGLE_INTR : integer range 0 to 1 := 1;
             C_ENABLE_DROP_CNT : integer range 0 to 1 := 1;
             C_ASYNC : integer range 0 to 1 := 0
             );
     port (
           m_axi_s2mm_aclk               : in std_logic;
           m_axi_sg_aclk                 : in std_logic;
           m_axi_sg_aresetn              : in std_logic;
           m_axi_s2mm_aresetn            : in std_logic;
           eof_detected                  : in std_logic; -- in sg_clk domain
           fetch_more                    : in std_logic;
           channel_idle                  : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
           channel_enable                : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
           sts_busy                      : in std_logic;
           s2mm_run_stop                 : in std_logic;
           s_axis_tvalid                 : in std_logic; --from outside
           s_axis_tlast                  : in std_logic; --from outside
           s_axis_tdest                  : in std_logic_vector (3 downto 0); --from outside
           s_axis_tuser                  : in std_logic_vector (15 downto 0); --from outside
           s_axis_tid                    : in std_logic_vector (7 downto 0); --from outside
           s_axis_tready                 : out std_logic; --to outside

           m_axis_tvalid                 : out std_logic; --to datamover
           m_axis_tready                 : in std_logic;  -- from Datamover

           sg_channel_id                 : out std_logic_vector (C_MAX_CHANNELS-1 downto 0);
           sg_channel_id_reg             : out std_logic_vector (C_MAX_CHANNELS-1 downto 0);
           bd_fetch_trig                 : out std_logic;
           accept_sts                    : out std_logic; 
           reject_sts                    : out std_logic; 
           s2mm_pktdrp_irq_set           : out std_logic;  
           s2mm_pktirqthresh_status      : out std_logic_vector (7 downto 0);
           s2mm_pktirqthresh_wren        : in std_logic;
           s2mm_pktirqthresh             : in std_logic_vector (7 downto 0);
           s2mm_pktdrp_count             : out std_logic_vector (31 downto 0);
           ch_s2mm_pktdrp_irq_set       : out std_logic_vector (C_MAX_CHANNELS-1 downto 0);                     
           ch_s2mm_pktirqthresh_status  : out std_logic_vector (8*C_MAX_CHANNELS-1 downto 0);
           ch_s2mm_pktirqthresh_wren    : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
           ch_s2mm_pktirqthresh         : in std_logic_vector (8*C_MAX_CHANNELS-1 downto 0);
           ch_s2mm_pktdrp_count         : out std_logic_vector (16*C_MAX_CHANNELS-1 downto 0);
           ch_s2mm_pktdrp_reset         : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);

           sg_side_band                  : out std_logic_vector (31 downto 0);
           sg_side_band_s2mm_tuser       : out std_logic_vector (15 downto 0);
           sg_side_band_s2mm             : out std_logic_vector (11 downto 0);
           sg_side_band_tuser_valid            : out std_logic;
           sg_side_band_valid            : out std_logic
          );
end entity axi_mcdma_s2mm_tdest;

architecture implementation of axi_mcdma_s2mm_tdest is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";



signal wait_for_new_pkt      : std_logic;
signal tdest_captured_cdc_to : std_logic;
signal tdest_captured_cdc_1  : std_logic;
signal tdest_captured_cdc_2  : std_logic;
signal tdest_captured_cdc_3  : std_logic;
signal tlast_captured_cdc_to : std_logic;
signal tlast_captured_cdc_1  : std_logic;
signal tlast_captured_cdc_2  : std_logic;
signal tlast_captured_cdc_3  : std_logic;
signal tdest_available       : std_logic;
signal tlast_available       : std_logic;
signal tlast_available1       : std_logic;
signal tlast_available2       : std_logic;
signal tdest_capture         : std_logic_vector (3 downto 0);
signal tdest_capture2         : std_logic_vector (4 downto 0);
signal tdest_int_capture     : std_logic_vector (3 downto 0);
signal tid_capture           : std_logic_vector (7 downto 0);
signal tuser_capture         : std_logic_vector (15 downto 0);
signal tdest_captured        : std_logic;
signal tlast_captured        : std_logic;

signal sg_tdest_cdc_to       : std_logic_vector (4 downto 0);
signal sg_tdest_int_cdc_to       : std_logic_vector (3 downto 0);
signal sg_tuser_cdc_to       : std_logic_vector (15 downto 0);
signal sg_tid_cdc_to       : std_logic_vector (7 downto 0);
signal channel_enable2            : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal channel_id            : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal channel_id_drop            : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal drop_pkt : std_logic;
signal drop_trigger : std_logic;
signal nodrop_trigger : std_logic;
signal channel_id_i            : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal channel_id_i_hold            : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal channel_id_i2            : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal sg_tdest : std_logic_vector (3 downto 0);
signal sg_tuser : std_logic_vector (15 downto 0);
signal sg_tid   : std_logic_vector (7 downto 0);
signal capture : std_logic;
signal s_axis_tready_int : std_logic;
signal tvalid_int : std_logic;
signal incoming_tlast : std_logic;
signal incoming_first : std_logic;
signal first_beat : std_logic;
signal to_drop_the_pkt : std_logic;
signal packet_dropped_tlast : std_logic;
signal drop_tready : std_logic;
signal capture_del : std_logic;
signal captured : std_logic;
signal channel_idle_cdc_to : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal channel_idle_cdc_1 : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal channel_idle_cdc_2 : std_logic_vector (C_MAX_CHANNELS-1 downto 0);

signal channel_enable_cdc_to : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal channel_enable_cdc_1 : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal channel_enable_cdc_2 : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_run_stop_cdc_2 : std_logic;

signal to_be_serviced : std_logic;
signal not_to_be_serviced : std_logic;

signal to_be_serviced_cdc_to : std_logic;
signal to_be_serviced_cdc_1 : std_logic;
signal to_be_serviced_cdc_2 : std_logic;
signal to_be_serviced_cdc_3 : std_logic;
signal not_to_be_serviced_cdc_to : std_logic;
signal not_to_be_serviced_cdc_1 : std_logic;
signal not_to_be_serviced_cdc_2 : std_logic;
signal not_to_be_serviced_cdc_3 : std_logic;

signal to_be_serviced_trig : std_logic;
signal not_to_be_serviced_trig : std_logic;

signal packet_dropped : std_logic;
signal dropped_id : std_logic_vector (3 downto 0);


signal packet_dropped_s2mm_cdc_to : std_logic;
signal packet_dropped_s2mm : std_logic;
signal packet_dropped_s2mm_cdc_1 : std_logic;
signal packet_dropped_s2mm_cdc_2 : std_logic;
signal packet_dropped_s2mm_cdc_3 : std_logic;


signal dropped_id_s2mm_cdc_to : std_logic_vector (3 downto 0);
signal dropped_id_s2mm : std_logic_vector (3 downto 0);

signal drop_pkt_i : std_logic_vector (C_MAX_CHANNELS-1 downto 0);

signal window : std_logic;
signal hold : std_logic;
signal sg_channel_id_int : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal eof_detected_s2mm : std_logic;
signal eof_int : std_logic;
signal eof_int_cdc_2 : std_logic;
signal eof_int_cdc_3 : std_logic;

signal eof_hold : std_logic_vector (3 downto 0);
signal eof_stretch_del : std_logic;
signal eof_stretch_del1 : std_logic;
signal eof_stretch : std_logic;

begin

sg_channel_id <= sg_channel_id_int;

sg_side_band <= sg_tid & "0000" & sg_tdest & sg_tuser;



-- its safe to transfer wait_for_new_pkt into sg_clock as that packet will not be completed
-- unless the id goes to SG. so also the tdest_capture will remain stable
-- can be directly once wait_for_new_pkt is taken in

ASYNC_CLOCKS : if C_ASYNC = 1 generate
begin

-- from sg clk to s2mm clk

--process (m_axi_s2mm_aclk)
--begin
--   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
--        channel_idle_cdc_to <= channel_idle;
--        channel_idle_cdc_1 <= channel_idle_cdc_to;
--        channel_idle_cdc_2 <= channel_idle_cdc_1;
--   end if;
--end process;


process (m_axi_sg_aclk)
begin
   if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
      if (m_axi_sg_aresetn = '0') then
          eof_int <= '0';
      elsif (eof_detected = '1') then
          eof_int <= not eof_int;
      end if;
   end if;
end process;


EOF_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => eof_int, 
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => m_axi_s2mm_aclk, 
        scndry_resetn              => '0',
        scndry_out                 => eof_int_cdc_2,
        scndry_vect_out            => open
    );


process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      eof_int_cdc_3 <= eof_int_cdc_2;
   end if;
end process;

eof_detected_s2mm <= eof_int_cdc_2 xor eof_int_cdc_3;


IDLE_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 0,
        C_VECTOR_WIDTH             => C_MAX_CHANNELS,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => '0',
        prmry_vect_in              => channel_idle,

        scndry_aclk                => m_axi_s2mm_aclk,
        scndry_resetn              => '0',
        scndry_out                 => open,
        scndry_vect_out            => channel_idle_cdc_2
    );




-- from sg clk to s2mm clk
--process (m_axi_s2mm_aclk)
--begin
--   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
--        channel_enable_cdc_to <= channel_enable;
--        channel_enable_cdc_1 <= channel_enable_cdc_to;
--        channel_enable_cdc_2 <= channel_enable_cdc_1;
--   end if;
--end process;

ENABLE_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 0,
        C_VECTOR_WIDTH             => C_MAX_CHANNELS,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => '0',
        prmry_vect_in              => channel_enable,

        scndry_aclk                => m_axi_s2mm_aclk,
        scndry_resetn              => '0',
        scndry_out                 => open,
        scndry_vect_out            => channel_enable_cdc_2
    );

START_STOP_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => s2mm_run_stop, 
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => m_axi_s2mm_aclk, 
        scndry_resetn              => '0',
        scndry_out                 => s2mm_run_stop_cdc_2,
        scndry_vect_out            => open
    );

process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
         tvalid_int <= '0';
      else
         tvalid_int <= s_axis_tvalid; 
      end if;
   end if;
end process; 

process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
        capture <= '1';
--      elsif (s_axis_tvalid = '1' and s_axis_tlast = '1' and s_axis_tready_int = '1') then -- drop then this, else eof_detected ??
      elsif (eof_detected_s2mm = '1' or packet_dropped_tlast = '1') then --s_axis_tvalid = '1' and s_axis_tlast = '1' and s_axis_tready_int = '1') then -- drop then this, else eof_detected ??
        capture <= '1';
      elsif (s_axis_tvalid = '1' and sts_busy = '0') then
        capture <= '0';
      end if;
   end if;
end process;

process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
        capture_del <= '1';
      else
        capture_del <= capture;
      end if;
   end if;
end process;

captured <= capture_del and (not capture);


process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
         tdest_capture2 <= "10000";
         channel_enable2 <= (others => '0');
--      elsif (s_axis_tvalid = '1' and s_axis_tlast = '1' and s_axis_tready_int = '1') then -- eof_detected ??
      elsif (eof_detected_s2mm = '1' or packet_dropped_tlast = '1') then --s_axis_tvalid = '1' and s_axis_tlast = '1' and s_axis_tready_int = '1') then -- eof_detected ??
         tdest_capture2 <= "10000";

      elsif (capture = '1' and s_axis_tvalid = '1' and sts_busy = '0') then           -- will capture tdest for non b2b packets
         tdest_capture2 <= '0' & s_axis_tdest;
         channel_enable2 <= channel_enable_cdc_2;
      end if;
   end if;
end process;

DROP_GEN: for I in 0 to C_MAX_CHANNELS-1 generate
begin

process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
          drop_pkt_i(I) <= '0';
      elsif (capture = '1' and s_axis_tvalid = '1' and sts_busy = '0') then
        if (channel_enable_cdc_2(I) = '1' and channel_idle_cdc_2(I) = '0' and s2mm_run_stop_cdc_2 = '1') then
          drop_pkt_i(I) <= '0';
        else
          drop_pkt_i(I) <= '1';
        end if;
      else
          drop_pkt_i(I) <= drop_pkt_i(I);
      end if;
   end if;
end process;

end generate DROP_GEN;


process (tdest_capture2, drop_pkt_i)
begin
          channel_id <= (others => '0');
    case (tdest_capture2) is
      when "10000" =>
          drop_pkt <= '0';
      when "00000" =>
          drop_pkt <= drop_pkt_i(0);
          channel_id (0) <= '1';
       --   channel_id <= "00000001";
      when "00001" =>
          drop_pkt <= drop_pkt_i(1);
          channel_id (1) <= '1';
       --   channel_id <= "00000010";
      when "00010" =>
          drop_pkt <= drop_pkt_i(2);
          channel_id (2) <= '1';
       --   channel_id <= "00000100";
      when "00011" =>
          drop_pkt <= drop_pkt_i(3);
          channel_id (3) <= '1';
       --   channel_id <= "00001000";
      when "00100" =>
          drop_pkt <= drop_pkt_i(4);
          channel_id (4) <= '1';
       --   channel_id <= "00010000";
      when "00101" =>
          drop_pkt <= drop_pkt_i(5);
          channel_id (5) <= '1';
       --   channel_id <= "00100000";
      when "00110" =>
          drop_pkt <= drop_pkt_i(6);
          channel_id (6) <= '1';
       --   channel_id <= "01000000";
      when "00111" =>
          drop_pkt <= drop_pkt_i(7);
          channel_id (7) <= '1';
      when "01000" =>
          drop_pkt <= drop_pkt_i(8);
          channel_id (8) <= '1';
      when "01001" =>
          drop_pkt <= drop_pkt_i(9);
          channel_id (9) <= '1';
      when "01010" =>
          drop_pkt <= drop_pkt_i(10);
          channel_id (10) <= '1';
      when "01011" =>
          drop_pkt <= drop_pkt_i(11);
          channel_id (11) <= '1';
      when "01100" =>
          drop_pkt <= drop_pkt_i(12);
          channel_id (12) <= '1';
      when "01101" =>
          drop_pkt <= drop_pkt_i(13);
          channel_id (13) <= '1';
      when "01110" =>
          drop_pkt <= drop_pkt_i(14);
          channel_id (14) <= '1';
      when "01111" =>
          drop_pkt <= drop_pkt_i(15);
          channel_id (15) <= '1';
       --   channel_id <= "10000000";
          -- coverage off
      when others =>
          drop_pkt <= '1';
          -- coverage on;
       --   channel_id <= (others => '0');
    end case;
end process;


--process (tdest_capture2, channel_enable2, channel_idle_cdc_2)
--begin
--    case (tdest_capture2) is
--      when "10000" =>
--          drop_pkt <= '0';
--          channel_id <= "00000000";
--      when "00000" =>
--          channel_id <= "00000001";
--          if (channel_enable2(0) = '1' and channel_idle_cdc_2(0) = '0') then
--             drop_pkt <= '0';
--          else
--             drop_pkt <= '1';
--          end if; 
--      when "00001" =>
--          channel_id <= "00000010";
--          if (channel_enable2(1) = '1' and channel_idle_cdc_2(1) = '0') then
--             drop_pkt <= '0';
--          else
--             drop_pkt <= '1';
--          end if; 
--      when "00010" =>
--          channel_id <= "00000100";
--          if (channel_enable2(2) = '1' and channel_idle_cdc_2(2) = '0') then
--             drop_pkt <= '0';
--          else
--             drop_pkt <= '1';
--          end if; 
--      when "00011" =>
--          channel_id <= "00001000";
--          if (channel_enable2(3) = '1' and channel_idle_cdc_2(3) = '0') then
--             drop_pkt <= '0';
--          else
--             drop_pkt <= '1';
--          end if; 
--      when "00100" =>
--          channel_id <= "00010000";
--          if (channel_enable2(4) = '1' and channel_idle_cdc_2(4) = '0') then
--             drop_pkt <= '0';
--          else
--             drop_pkt <= '1';
--          end if; 
--      when "00101" =>
--          channel_id <= "00100000";
--          if (channel_enable2(5) = '1' and channel_idle_cdc_2(5) = '0') then
--             drop_pkt <= '0';
--          else
--             drop_pkt <= '1';
--          end if; 
--      when "00110" =>
--          channel_id <= "01000000";
--          if (channel_enable2(6) = '1' and channel_idle_cdc_2(6) = '0') then
--             drop_pkt <= '0';
--          else
--             drop_pkt <= '1';
--          end if; 
--      when "00111" =>
--          channel_id <= "10000000";
--          if (channel_enable2(7) = '1' and channel_idle_cdc_2(7) = '0') then
--             drop_pkt <= '0';
--          else
--             drop_pkt <= '1';
--          end if; 
--      when others =>
--          channel_id <= "00000000";
--          drop_pkt <= '1';
--    end case;
--end process;


process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
          accept_sts <= '0';
          reject_sts <= '0';
      elsif (captured = '1' and drop_pkt = '0') then
          accept_sts <= '1';
          reject_sts <= '0';
      elsif (captured = '1' and drop_pkt = '1') then
          accept_sts <= '0';
          reject_sts <= '1';
      else
          accept_sts <= '0';
          reject_sts <= '0';
      end if;
    end if;
end process; 

incoming_tlast <= s_axis_tvalid and s_axis_tlast and s_axis_tready_int;

process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
          sg_side_band_tuser_valid <= '0';
          sg_side_band_s2mm_tuser <= (others => '0');
      elsif (drop_pkt = '0' and incoming_tlast = '1') then
          sg_side_band_tuser_valid <= '1';
          sg_side_band_s2mm_tuser <= s_axis_tuser;
      else
          sg_side_band_tuser_valid <= '0';
          sg_side_band_s2mm_tuser <= (others => '0');
      end if;
   end if;
end process;


process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
         first_beat <= '1';
      elsif (s_axis_tvalid = '1' and s_axis_tlast = '1' and s_axis_tready_int = '1') then
         first_beat <= '1';
      elsif (s_axis_tvalid = '1' and s_axis_tready_int = '1') then
         first_beat <= '0';
      end if;
   end if;
end process;


incoming_first <= s_axis_tvalid and s_axis_tready_int and first_beat;

process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
          sg_side_band_valid <= '0';
          sg_side_band_s2mm <= (others => '0');
      elsif (drop_pkt = '0' and incoming_first = '1') then
          sg_side_band_valid <= '1';
          sg_side_band_s2mm <= s_axis_tid & s_axis_tdest;
      else
          sg_side_band_valid <= '0';
          sg_side_band_s2mm <= (others => '0');
      end if;
   end if;
end process;
 

process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0' or incoming_tlast = '1') then
         to_drop_the_pkt <= '1';
      elsif (captured = '1' and drop_pkt = '0') then
         to_drop_the_pkt <= '0';
      elsif (captured = '1' and drop_pkt = '1') then
         to_drop_the_pkt <= '1';
      else
         to_drop_the_pkt <= to_drop_the_pkt;
      end if;
   end if;
end process;


process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0' or incoming_tlast = '1') then
         drop_tready <= '0';
      elsif (drop_pkt = '1' and tvalid_int = '1') then
         drop_tready <= '1';
      end if;
   end if;
end process; 

s_axis_tready <= drop_tready when (to_drop_the_pkt = '1') else m_axis_tready;
s_axis_tready_int <= drop_tready when (to_drop_the_pkt = '1') else m_axis_tready;

m_axis_tvalid <= '0' when (to_drop_the_pkt = '1') else s_axis_tvalid;


packet_dropped_tlast <= to_drop_the_pkt and s_axis_tvalid and s_axis_tlast and drop_tready;

-- assuming the packets are not tiny and tdest value captured on drop remains constant

process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
         packet_dropped <= '0';
         dropped_id_s2mm <= (others => '0');
         packet_dropped_s2mm <= '0';
      elsif (packet_dropped_tlast = '1' and s2mm_run_stop_cdc_2 = '1') then
         packet_dropped <= '1';
         dropped_id_s2mm <= s_axis_tdest;
         packet_dropped_s2mm <= not packet_dropped_s2mm;
      else
         packet_dropped <= '0';
         packet_dropped_s2mm <= packet_dropped_s2mm;
      end if;
   end if;
end process;


PKT_DROPPED_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => packet_dropped_s2mm,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => packet_dropped_s2mm_cdc_2,
        scndry_vect_out            => open
    );

process (m_axi_sg_aclk)
begin
   if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
--      packet_dropped_s2mm_cdc_to <= packet_dropped_s2mm;
--      packet_dropped_s2mm_cdc_1 <= packet_dropped_s2mm_cdc_to;
--      packet_dropped_s2mm_cdc_2 <= packet_dropped_s2mm_cdc_1;
      packet_dropped_s2mm_cdc_3 <= packet_dropped_s2mm_cdc_2;
   end if;
end process;

--packet_dropped <= (packet_dropped_s2mm_cdc_3 xor packet_dropped_s2mm_cdc_2) and s2mm_run_stop;

--process (m_axi_sg_aclk)
--begin
--   if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
--      dropped_id_s2mm_cdc_to <= dropped_id_s2mm;
--      dropped_id <= dropped_id_s2mm_cdc_to;
--   end if;
--end process;

DROPPED_ID_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 0,
        C_VECTOR_WIDTH             => 4,
        C_MTBF_STAGES              => 2 --MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => '0',
        prmry_vect_in              => dropped_id_s2mm,

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => open,
        scndry_vect_out            => dropped_id
    );


process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
         to_be_serviced <= '0';
         not_to_be_serviced <= '0';
      elsif (drop_pkt = '0' and captured = '1') then
         to_be_serviced <= not to_be_serviced; -- this signal does not change unless the packet is serviced
      elsif (drop_pkt = '1' and captured = '1') then
         not_to_be_serviced <= not not_to_be_serviced; -- this signal does not change unless the packet is serviced
      end if;
   end if;
end process;




RESIDUE: if C_NUM_S2MM_CHANNELS /= C_MAX_CHANNELS generate
begin
  channel_id_i (C_NUM_S2MM_CHANNELS-1 downto 0)<= channel_id (C_NUM_S2MM_CHANNELS-1 downto 0);
  channel_id_i (C_MAX_CHANNELS-1 downto C_NUM_S2MM_CHANNELS) <= (others => '0');


end generate RESIDUE;

NORESIDUE: if C_NUM_S2MM_CHANNELS = C_MAX_CHANNELS generate
begin
  channel_id_i <= channel_id;

end generate NORESIDUE;


process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
           channel_id_i_hold <= (others => '0');
      elsif (captured = '1' and drop_pkt = '0') then
           channel_id_i_hold <= channel_id_i;
      end if;
   end if;
end process;

-- outputs in sg_aclk domain


process (m_axi_sg_aclk)
begin
   if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
--      to_be_serviced_cdc_to <= to_be_serviced;
--      to_be_serviced_cdc_1 <= to_be_serviced_cdc_to;
--      to_be_serviced_cdc_2 <= to_be_serviced_cdc_1;
      to_be_serviced_cdc_3 <= to_be_serviced_cdc_2;
   end if;
end process;

TO_BE_SER_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => to_be_serviced,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => to_be_serviced_cdc_2,
        scndry_vect_out            => open
    );


process (m_axi_sg_aclk)
begin
   if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
--      not_to_be_serviced_cdc_to <= not_to_be_serviced;
--      not_to_be_serviced_cdc_1 <= not_to_be_serviced_cdc_to;
--      not_to_be_serviced_cdc_2 <= not_to_be_serviced_cdc_1;
      not_to_be_serviced_cdc_3 <= not_to_be_serviced_cdc_2;
   end if;
end process;


NOT_TO_BE_SER_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => not_to_be_serviced,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => not_to_be_serviced_cdc_2,
        scndry_vect_out            => open
    );

to_be_serviced_trig <= to_be_serviced_cdc_3 xor to_be_serviced_cdc_2;
not_to_be_serviced_trig <= not_to_be_serviced_cdc_3 xor not_to_be_serviced_cdc_2;


SG_CHANNEL_ID_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_FLOP_INPUT               => 1,
        C_SINGLE_BIT               => 0,
        C_VECTOR_WIDTH             => C_MAX_CHANNELS,
        C_MTBF_STAGES              => 2 --MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axi_s2mm_aclk,
        prmry_resetn               => '0',
        prmry_in                   => '0',
        prmry_vect_in              => channel_id_i,

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => open,
        scndry_vect_out            => channel_id_i2
    );

process (m_axi_sg_aclk)
begin
   if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
      if (m_axi_sg_aresetn = '0') then
         sg_channel_id_int <= (others => '0');
         window <= '0';
      elsif (to_be_serviced_trig = '1') then
         sg_channel_id_int <= channel_id_i2;
         window <= '1';
      elsif (eof_detected = '1' and hold = '0') then 
         sg_channel_id_int <= (others => '0');
         window <= '0';
      elsif (eof_detected = '1' and hold = '1') then
         sg_channel_id_int <= channel_id_i2;
         window <= '1';
      end if;
   end if;
end process; 


process (m_axi_sg_aclk)
begin
   if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
      if (m_axi_sg_aresetn = '0') then
          hold <= '0';
      elsif (window = '1' and to_be_serviced_trig = '1' and eof_detected = '0') then
          hold <= '1';
      elsif (eof_detected = '1') then
          hold <= '0';
      end if;
   end if;
end process;



-- if window = 1 and serviced_trig = 1 and eof_detected = 0, means i am getting a valid pkt very early


SG_CHANNEL_ID_HOLD_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 0,
        C_VECTOR_WIDTH             => C_MAX_CHANNELS,
        C_MTBF_STAGES              => 2 --MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => '0',
        prmry_vect_in              => channel_id_i_hold,

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => open,
        scndry_vect_out            => sg_channel_id_reg
    );

process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
         tuser_capture <= (others => '0');
         tid_capture <= (others => '0');
         tdest_capture <= (others => '0');
         tlast_captured <= '0';
      elsif (s_axis_tvalid = '1' and s_axis_tlast = '1' and s_axis_tready_int = '1') then
         tlast_captured <= not tlast_captured;
         tuser_capture <= s_axis_tuser;
         tid_capture   <= s_axis_tid;
         tdest_capture <= s_axis_tdest;
      end if;
   end if;
end process;

process (m_axi_sg_aclk)
begin
   if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
--      tlast_captured_cdc_to    <= tlast_captured;
--      tlast_captured_cdc_1    <= tlast_captured_cdc_to;
--      tlast_captured_cdc_2    <= tlast_captured_cdc_1;
      tlast_captured_cdc_3    <= tlast_captured_cdc_2;
   end if;
end process;

TLAST_AVAIL_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => tlast_captured,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => tlast_captured_cdc_2,
        scndry_vect_out            => open
    );

tlast_available <= tlast_captured_cdc_3 xor tlast_captured_cdc_2;


process (m_axi_sg_aclk)
begin
   if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
      if (m_axi_sg_aresetn = '0') then
         tlast_available1 <= '0';
         tlast_available2 <= '0';
      else
         tlast_available1 <= tlast_available;
         tlast_available2 <= tlast_available1;
      end if;
   end if;
end process; 

process (m_axi_sg_aclk)
begin
   if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
      if (m_axi_sg_aresetn = '0') then
         sg_tdest_int_cdc_to <= (others => '0');  -- invalid, default value
      elsif (tlast_available = '1') then
         sg_tdest_int_cdc_to <= tdest_capture;
      end if;
   end if;
end process; 

process (m_axi_sg_aclk)
begin
   if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
      if (m_axi_sg_aresetn = '0') then
         sg_tdest <= (others => '0');
      else
         sg_tdest <= sg_tdest_int_cdc_to;
      end if;
   end if;
end process; 

process (m_axi_sg_aclk)
begin
   if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
      if (m_axi_sg_aresetn = '0') then
         sg_tuser_cdc_to <= (others => '0');  -- invalid, default value
      elsif (tlast_available = '1') then
         sg_tuser_cdc_to <= tuser_capture;
      end if;
   end if;
end process; 

process (m_axi_sg_aclk)
begin
   if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
      if (m_axi_sg_aresetn = '0') then
         sg_tuser <= (others => '0');
      else
         sg_tuser <= sg_tuser_cdc_to;
      end if;
   end if;
end process; 

process (m_axi_sg_aclk)
begin
   if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
      if (m_axi_sg_aresetn = '0') then
         sg_tid_cdc_to <= (others => '0');  -- invalid, default value
      elsif (tlast_available = '1') then
         sg_tid_cdc_to <= tid_capture;
      end if;
   end if;
end process; 

process (m_axi_sg_aclk)
begin
   if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
      if (m_axi_sg_aresetn = '0') then
         sg_tid <= (others => '0');
      else
         sg_tid <= sg_tid_cdc_to;
      end if;
   end if;
end process; 


process (m_axi_sg_aclk)
begin
   if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
      if (m_axi_sg_aresetn = '0') then
         eof_stretch <= '0';
      elsif (to_be_serviced_trig = '1' or not_to_be_serviced_trig = '1') then
         eof_stretch <= '0';
      elsif (eof_detected = '1') then
         eof_stretch <= '1';
      end if;
   end if;
end process; 


process (m_axi_sg_aclk)
begin
   if (m_axi_sg_aclk'event and m_axi_sg_aclk = '1') then
      if (m_axi_sg_aresetn = '0') then
         eof_stretch_del <= '0';
         eof_stretch_del1 <= '0';
      else
         eof_stretch_del <= eof_stretch;
         eof_stretch_del1 <= eof_stretch_del;
      end if;
   end if;
end process;

bd_fetch_trig <= (eof_stretch_del1 and not (eof_stretch_del)) or fetch_more;         


end generate ASYNC_CLOCKS;


SYNC_CLOCKS : if C_ASYNC = 0 generate
begin


process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
         eof_hold <= "0000";
      else
         eof_hold(0) <= eof_detected;
         eof_hold(3 downto 1) <= eof_hold(2 downto 0);
      end if;
   end if;
end process; 


bd_fetch_trig <= eof_hold(3) or fetch_more;

process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
         tvalid_int <= '0';
      else
         tvalid_int <= s_axis_tvalid; 
      end if;
   end if;
end process; 


process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
        capture <= '1';
--      elsif (s_axis_tvalid = '1' and s_axis_tlast = '1' and s_axis_tready_int = '1') then -- drop then this, else eof_detected ??
      elsif (eof_detected = '1' or packet_dropped_tlast = '1') then --s_axis_tvalid = '1' and s_axis_tlast = '1' and s_axis_tready_int = '1') then -- drop then this, else eof_detected ??
        capture <= '1';
      elsif (s_axis_tvalid = '1' and sts_busy = '0') then
        capture <= '0';
      end if;
   end if;
end process;

process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
        capture_del <= '1';
      else
        capture_del <= capture;
      end if;
   end if;
end process;

captured <= capture_del and (not capture);


process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
         tdest_capture2 <= "10000";
         channel_enable2 <= (others => '0');
--      elsif (eof_detected = '1') then      -- will take care of b2b packets
--         tdest_capture2 <= tdest_capture;
--         channel_enable2 <= channel_enable;
--      elsif (s_axis_tvalid = '1' and s_axis_tlast = '1' and s_axis_tready_int = '1') then -- eof_detceted ??
      elsif (eof_detected = '1' or packet_dropped_tlast = '1') then --s_axis_tvalid = '1' and s_axis_tlast = '1' and s_axis_tready_int = '1') then -- eof_detceted ??
         tdest_capture2 <= "10000";

      elsif (capture = '1' and s_axis_tvalid = '1' and sts_busy = '0') then           -- will capture tdest for non b2b packets
         tdest_capture2 <= '0' & s_axis_tdest;
         channel_enable2 <= channel_enable;
      end if;
   end if;
end process;


DROP_GEN: for I in 0 to C_MAX_CHANNELS-1 generate
begin

process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
          drop_pkt_i(I) <= '0';
      elsif (capture = '1' and s_axis_tvalid = '1' and sts_busy = '0') then
         if (channel_enable(I) = '1' and channel_idle(I) = '0' and s2mm_run_stop = '1') then
            drop_pkt_i(I) <= '0';
         else
            drop_pkt_i(I) <= '1';
         end if;
      else
            drop_pkt_i(I) <= drop_pkt_i(I);
      end if;
   end if;
end process;

end generate DROP_GEN;


process (tdest_capture2, drop_pkt_i)
begin
          channel_id <= (others => '0');
    case (tdest_capture2) is
      when "10000" =>
        --  channel_id <= "00000000";
          drop_pkt <= '0';
      when "00000" =>
           channel_id(0) <= '1';
        --     channel_id <= "00000001";
          drop_pkt <= drop_pkt_i(0);
      when "00001" =>
           channel_id(1) <= '1';
        --     channel_id <= "00000010";
          drop_pkt <= drop_pkt_i(1);
      when "00010" =>
           channel_id(2) <= '1';
        --     channel_id <= "00000100";
          drop_pkt <= drop_pkt_i(2);
      when "00011" =>
           channel_id(3) <= '1';
        --     channel_id <= "00001000";
          drop_pkt <= drop_pkt_i(3);
      when "00100" =>
           channel_id(4) <= '1';
        --     channel_id <= "00010000";
          drop_pkt <= drop_pkt_i(4);
      when "00101" =>
           channel_id(5) <= '1';
        --     channel_id <= "00100000";
          drop_pkt <= drop_pkt_i(5);
      when "00110" =>
           channel_id(6) <= '1';
        --     channel_id <= "01000000";
          drop_pkt <= drop_pkt_i(6);
      when "00111" =>
           channel_id(7) <= '1';
        --     channel_id <= "10000000";
          drop_pkt <= drop_pkt_i(7);
      when "01000" =>
           channel_id(8) <= '1';
        --     channel_id <= "10000000";
          drop_pkt <= drop_pkt_i(8);
      when "01001" =>
           channel_id(9) <= '1';
        --     channel_id <= "10000000";
          drop_pkt <= drop_pkt_i(9);
      when "01010" =>
           channel_id(10) <= '1';
        --     channel_id <= "10000000";
          drop_pkt <= drop_pkt_i(10);
      when "01011" =>
           channel_id(11) <= '1';
        --     channel_id <= "10000000";
          drop_pkt <= drop_pkt_i(11);
      when "01100" =>
           channel_id(12) <= '1';
        --     channel_id <= "10000000";
          drop_pkt <= drop_pkt_i(12);
      when "01101" =>
           channel_id(13) <= '1';
        --     channel_id <= "10000000";
          drop_pkt <= drop_pkt_i(13);
      when "01110" =>
           channel_id(14) <= '1';
        --     channel_id <= "10000000";
          drop_pkt <= drop_pkt_i(14);
      when "01111" =>
           channel_id(15) <= '1';
        --     channel_id <= "10000000";
          drop_pkt <= drop_pkt_i(15);
          -- coverage off
      when others =>
        --  channel_id <= "00000000";
          drop_pkt <= '1';
          -- coverage on
    end case;
end process;


--process (tdest_capture2, channel_enable2)
--begin
--    case (tdest_capture2) is
--      when "10000" =>
--          channel_id <= "00000000";
--          drop_pkt <= '0';
--      when "00000" =>
--             channel_id <= "00000001";
--          if (channel_enable2(0) = '1' and channel_idle(0) = '0') then
--             drop_pkt <= '0';
--          else
--             drop_pkt <= '1';
--          end if; 
--      when "00001" =>
--             channel_id <= "00000010";
--          if (channel_enable2(1) = '1' and channel_idle(1) = '0') then
--             drop_pkt <= '0';
--          else
--             drop_pkt <= '1';
--          end if; 
--      when "00010" =>
--             channel_id <= "00000100";
--          if (channel_enable2(2) = '1' and channel_idle(2) = '0') then
--             drop_pkt <= '0';
--          else
--             drop_pkt <= '1';
--          end if; 
--      when "00011" =>
--             channel_id <= "00001000";
--          if (channel_enable2(3) = '1' and channel_idle(3) = '0') then
--             drop_pkt <= '0';
--          else
--             drop_pkt <= '1';
--          end if; 
--      when "00100" =>
--             channel_id <= "00010000";
--          if (channel_enable2(4) = '1' and channel_idle(4) = '0') then
--             drop_pkt <= '0';
--          else
--             drop_pkt <= '1';
--          end if; 
--      when "00101" =>
--             channel_id <= "00100000";
--          if (channel_enable2(5) = '1' and channel_idle(5) = '0') then
--             drop_pkt <= '0';
--          else
--             drop_pkt <= '1';
--          end if; 
--      when "00110" =>
--             channel_id <= "01000000";
--          if (channel_enable2(6) = '1' and channel_idle(6) = '0') then
--             drop_pkt <= '0';
--          else
--             drop_pkt <= '1';
--          end if; 
--      when "00111" =>
--             channel_id <= "10000000";
--          if (channel_enable2(7) = '1' and channel_idle(7) = '0') then
--             drop_pkt <= '0';
--          else
--             drop_pkt <= '1';
--          end if; 
--      when others =>
--          channel_id <= "00000000";
--          drop_pkt <= '1';
--    end case;
--end process;


process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
          accept_sts <= '0';
          reject_sts <= '0';
      elsif (captured = '1' and drop_pkt = '0') then
          accept_sts <= '1';
          reject_sts <= '0';
      elsif (captured = '1' and drop_pkt = '1') then
          accept_sts <= '0';
          reject_sts <= '1';
      else
          accept_sts <= '0';
          reject_sts <= '0';
      end if;
    end if;
end process; 


RESIDUE: if C_NUM_S2MM_CHANNELS /= C_MAX_CHANNELS generate
begin
  channel_id_i (C_NUM_S2MM_CHANNELS-1 downto 0)<= channel_id (C_NUM_S2MM_CHANNELS-1 downto 0);
  channel_id_i (C_MAX_CHANNELS-1 downto C_NUM_S2MM_CHANNELS) <= (others => '0');


end generate RESIDUE;

NORESIDUE: if C_NUM_S2MM_CHANNELS = C_MAX_CHANNELS generate
begin
  channel_id_i <= channel_id;

end generate NORESIDUE;

process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
         sg_channel_id_int <= (others => '0');
      elsif (drop_pkt = '0') then
         sg_channel_id_int <= channel_id_i;
      else
         sg_channel_id_int <= (others => '0');
      end if;
   end if;
end process; 

process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
          sg_side_band_tuser_valid <= '0';
          sg_side_band_s2mm_tuser <= (others => '0');
      elsif (drop_pkt = '0' and incoming_tlast = '1') then
          sg_side_band_tuser_valid <= '1';
          sg_side_band_s2mm_tuser <= s_axis_tuser;
      else
          sg_side_band_tuser_valid <= '0';
          sg_side_band_s2mm_tuser <= (others => '0');
      end if;
   end if;
end process;

process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
         first_beat <= '1';
      elsif (s_axis_tvalid = '1' and s_axis_tlast = '1' and s_axis_tready_int = '1') then
         first_beat <= '1';
      elsif (s_axis_tvalid = '1' and s_axis_tready_int = '1') then
         first_beat <= '0';
      end if;
   end if;
end process;


incoming_first <= s_axis_tvalid and s_axis_tready_int and first_beat;

process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
          sg_side_band_valid <= '0';
          sg_side_band_s2mm <= (others => '0');
      elsif (drop_pkt = '0' and incoming_first = '1') then
          sg_side_band_valid <= '1';
          sg_side_band_s2mm <= s_axis_tid & s_axis_tdest;
      else
          sg_side_band_valid <= '0';
          sg_side_band_s2mm <= (others => '0');
      end if;
   end if;
end process;


process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
         sg_channel_id_reg <= (others => '0');
      elsif (captured = '1' and drop_pkt = '0') then
         sg_channel_id_reg <= channel_id_i;
      else
      end if;
   end if;
end process; 


-- sideband signals captured on tlast to be updated in BD

process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
         sg_tuser <= (others => '0');
         sg_tid <= (others => '0');
         sg_tdest <= (others => '0');
      elsif (s_axis_tvalid = '1' and s_axis_tlast = '1' and s_axis_tready_int = '1') then
         sg_tuser <= s_axis_tuser;
         sg_tid   <= s_axis_tid;
         sg_tdest <= s_axis_tdest;
      end if;
   end if;
end process; 

incoming_tlast <= s_axis_tvalid and s_axis_tlast and s_axis_tready_int;

process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0' or incoming_tlast = '1') then
         to_drop_the_pkt <= '1';
--      elsif (drop_pkt = '1' and tvalid_int = '1') then
--         to_drop_the_pkt <= '1';
--      elsif (drop_pkt = '0' and tvalid_int = '1') then
--         to_drop_the_pkt <= '0';
      elsif (captured = '1' and drop_pkt = '0') then
         to_drop_the_pkt <= '0';
      elsif (captured = '1' and drop_pkt = '1') then
         to_drop_the_pkt <= '1';
      else
         to_drop_the_pkt <= to_drop_the_pkt;
      end if;
   end if;
end process;


process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0' or incoming_tlast = '1') then
         drop_tready <= '0';
      elsif (drop_pkt = '1' and tvalid_int = '1') then
         drop_tready <= '1';
--      elsif (drop_pkt = '0' and tvalid_int = '1') then
--         drop_tready <= '0';
--      elsif (drop_trigger = '1') then
--           drop_tready <= '1';
--      else
--           drop_tready <= drop_tready;
      end if;
   end if;
end process; 

s_axis_tready <= drop_tready when (to_drop_the_pkt = '1') else m_axis_tready;
s_axis_tready_int <= drop_tready when (to_drop_the_pkt = '1') else m_axis_tready;

m_axis_tvalid <= '0' when (to_drop_the_pkt = '1') else s_axis_tvalid;


packet_dropped_tlast <= to_drop_the_pkt and s_axis_tvalid and s_axis_tlast and drop_tready;

process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
         packet_dropped <= '0';
         dropped_id <= (others => '0');
      elsif (packet_dropped_tlast = '1' and s2mm_run_stop = '1') then
         packet_dropped <= '1';
         dropped_id <= s_axis_tdest;
      else
         packet_dropped <= '0';
      end if;
   end if;
end process;

  

end generate SYNC_CLOCKS;



SYNC_CLOCKS_INTR : if C_ASYNC = 0 generate
begin

-- packet drop stats are always in sg clk domain

    COMMON_STAT : entity axi_mcdma_v1_1_8.axi_mcdma_pkt_drop
     generic map (
             C_CHANNEL_ID      => 0,
             C_COMMON          => 0,
             C_ENABLE_DROP_CNT => C_ENABLE_DROP_CNT,
             C_ENABLE_SINGLE_INTR => C_ENABLE_SINGLE_INTR
             )
     port map (
           m_axi_sg_aclk           => m_axi_sg_aclk,
           m_axi_sg_aresetn        => m_axi_sg_aresetn, 
           packet_dropped          => packet_dropped,
           dropped_ch_id           => dropped_id,

           packet_thresh           => s2mm_pktirqthresh,
           packet_thresh_wren      => s2mm_pktirqthresh_wren,
           packet_thresh_sts       => s2mm_pktirqthresh_status,
           packet_irq              => s2mm_pktdrp_irq_set,

           reset_pkt_drp_count     => '0',
           channel_packet_drop_cnt => open,
           total_packet_drop_cnt   => s2mm_pktdrp_count
          );


CHANNEL_STAT : for I in 0 to C_NUM_S2MM_CHANNELS-1 generate
begin

    CH_STAT : entity axi_mcdma_v1_1_8.axi_mcdma_pkt_drop
     generic map (
             C_CHANNEL_ID      => I,
             C_COMMON          => 1,
             C_ENABLE_DROP_CNT => C_ENABLE_DROP_CNT,
             C_ENABLE_SINGLE_INTR => C_ENABLE_SINGLE_INTR
             )
     port map (
           m_axi_sg_aclk           => m_axi_sg_aclk,
           m_axi_sg_aresetn        => m_axi_sg_aresetn, 
           packet_dropped          => packet_dropped,
           dropped_ch_id           => dropped_id,

           packet_thresh           => ch_s2mm_pktirqthresh(8+8*I-1 downto 8*I),  
           packet_thresh_wren      => ch_s2mm_pktirqthresh_wren(I),
           packet_thresh_sts       => ch_s2mm_pktirqthresh_status(8+8*I-1 downto 8*I),
           packet_irq              => ch_s2mm_pktdrp_irq_set(I),

           reset_pkt_drp_count     => ch_s2mm_pktdrp_reset(I), 
           channel_packet_drop_cnt => ch_s2mm_pktdrp_count(16+16*I-1 downto 16*I),
           total_packet_drop_cnt   => open
          );

end generate CHANNEL_STAT;

UNUSED_CHANNELS: if C_MAX_CHANNELS > C_NUM_S2MM_CHANNELS generate
begin


CHANNEL_STAT : for I in C_NUM_S2MM_CHANNELS to C_MAX_CHANNELS-1 generate
begin

ch_s2mm_pktirqthresh_status(8+8*I-1 downto 8*I) <= (others => '0');
ch_s2mm_pktdrp_irq_set(I) <= '0';
ch_s2mm_pktdrp_count(16+16*I-1 downto 16*I) <= (others => '0');

end generate CHANNEL_STAT;
end generate UNUSED_CHANNELS;

end generate SYNC_CLOCKS_INTR;


ASYNC_CLOCKS_INTR : if C_ASYNC = 1 generate
signal s2mm_pktirqthresh_s2mm : std_logic_vector (7 downto 0);
signal s2mm_pktirqthresh_wren_s2mm : std_logic;
signal s2mm_pktdrp_count_s2mm : std_logic_vector (31 downto 0);
signal s2mm_pktirqthresh_status_s2mm : std_logic_vector (7 downto 0);
signal s2mm_pktdrp_irq_set_s2mm : std_logic;
signal s2mm_pktdrp_irq_set_s2mm_del : std_logic;
signal s2mm_pktdrp_irq_set_s2mm_pulse : std_logic;
signal ch_s2mm_pktirqthresh_s2mm : std_logic_vector(8*C_MAX_CHANNELS-1 downto 0);
signal ch_s2mm_pktirqthresh_wren_s2mm : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal ch_s2mm_pktdrp_count_s2mm : std_logic_vector (16*C_MAX_CHANNELS-1 downto 0);
signal ch_s2mm_pktirqthresh_status_s2mm : std_logic_vector (8*C_MAX_CHANNELS-1 downto 0);
signal ch_s2mm_pktdrp_irq_set_s2mm : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal ch_s2mm_pktdrp_irq_set_s2mm_del : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal ch_s2mm_pktdrp_irq_set_s2mm_pulse : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal ch_s2mm_pktdrp_reset_s2mm : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
begin

-- packet drop stats are always in sg clk domain

PKTDRP_THRESH_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 0,
        C_VECTOR_WIDTH             => 8,
        C_MTBF_STAGES              => 2 --MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => '0',
        prmry_vect_in              => s2mm_pktirqthresh,

        scndry_aclk                => m_axi_s2mm_aclk,
        scndry_resetn              => '0',
        scndry_out                 => open,
        scndry_vect_out            => s2mm_pktirqthresh_s2mm
    );


PKTDRP_THRESH_WREN_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 1,
        C_MTBF_STAGES              => 4 --MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axi_sg_aclk,
        prmry_resetn               => m_axi_sg_aresetn,
        prmry_in                   => s2mm_pktirqthresh_wren,
        prmry_vect_in              => "0",

        scndry_aclk                => m_axi_s2mm_aclk,
        scndry_resetn              => m_axi_s2mm_aresetn,--'1',
        scndry_out                 => s2mm_pktirqthresh_wren_s2mm,
        scndry_vect_out            => open
    );


    COMMON_STAT : entity axi_mcdma_v1_1_8.axi_mcdma_pkt_drop
     generic map (
             C_CHANNEL_ID      => 0,
             C_COMMON          => 0,
             C_ENABLE_DROP_CNT => C_ENABLE_DROP_CNT,
             C_ENABLE_SINGLE_INTR => C_ENABLE_SINGLE_INTR
             )
     port map (
           m_axi_sg_aclk           => m_axi_s2mm_aclk,
           m_axi_sg_aresetn        => m_axi_s2mm_aresetn, 
           packet_dropped          => packet_dropped, -- s2mm clk domain
           dropped_ch_id           => dropped_id_s2mm,      -- s2mm clk domain

           packet_thresh           => s2mm_pktirqthresh_s2mm,  -- from sg_clk
           packet_thresh_wren      => s2mm_pktirqthresh_wren_s2mm,  -- from sg_clk
           packet_thresh_sts       => s2mm_pktirqthresh_status_s2mm, -- to sg_clk
           packet_irq              => s2mm_pktdrp_irq_set_s2mm,  -- to sg_clk

           reset_pkt_drp_count     => '0',
           channel_packet_drop_cnt => open,
           total_packet_drop_cnt   => s2mm_pktdrp_count_s2mm -- to sg_clk
          );


PKTDRP_COUNT_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 0,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => 3 --MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => '0',
        prmry_vect_in              => s2mm_pktdrp_count_s2mm,

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => open,
        scndry_vect_out            => s2mm_pktdrp_count
    );


PKTDRP_THRESH_STS_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 0,
        C_VECTOR_WIDTH             => 8,
        C_MTBF_STAGES              => 3 --MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => '0',
        prmry_vect_in              => s2mm_pktirqthresh_status_s2mm,

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => open,
        scndry_vect_out            => s2mm_pktirqthresh_status
    );

process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
         s2mm_pktdrp_irq_set_s2mm_del <= '0';
      else
         s2mm_pktdrp_irq_set_s2mm_del <= s2mm_pktdrp_irq_set_s2mm;
      end if;
   end if;
end process;

s2mm_pktdrp_irq_set_s2mm_pulse <= s2mm_pktdrp_irq_set_s2mm and (not s2mm_pktdrp_irq_set_s2mm_del);


PKTDRP_IRQ_SET_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 1,
        C_MTBF_STAGES              => 4 --MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axi_s2mm_aclk,
        prmry_resetn               => m_axi_s2mm_aresetn,
        prmry_in                   => s2mm_pktdrp_irq_set_s2mm_pulse,
        prmry_vect_in              => "0",

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => m_axi_sg_aresetn, --'1',
        scndry_out                 => s2mm_pktdrp_irq_set,
        scndry_vect_out            => open
    );


CHANNEL_STAT : for I in 0 to C_NUM_S2MM_CHANNELS-1 generate



begin


PKTDRP_THRESH_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 0,
        C_VECTOR_WIDTH             => 8,
        C_MTBF_STAGES              => 2 --MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => '0',
        prmry_vect_in              => ch_s2mm_pktirqthresh (8+8*I-1 downto 8*I),

        scndry_aclk                => m_axi_s2mm_aclk,
        scndry_resetn              => '0',
        scndry_out                 => open,
        scndry_vect_out            => ch_s2mm_pktirqthresh_s2mm (8+8*I-1 downto 8*I)
    );


PKTDRP_THRESH_WREN_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 1,
        C_MTBF_STAGES              => 4 --MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axi_sg_aclk,
        prmry_resetn               => m_axi_sg_aresetn,
        prmry_in                   => ch_s2mm_pktirqthresh_wren(I),
        prmry_vect_in              => "0",

        scndry_aclk                => m_axi_s2mm_aclk,
        scndry_resetn              => m_axi_s2mm_aresetn, --'1',
        scndry_out                 => ch_s2mm_pktirqthresh_wren_s2mm(I),
        scndry_vect_out            => open
    );

PKTDRP_RST_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 1,
        C_MTBF_STAGES              => 4 --MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axi_sg_aclk,
        prmry_resetn               => m_axi_sg_aresetn,
        prmry_in                   => ch_s2mm_pktdrp_reset(I),
        prmry_vect_in              => "0",

        scndry_aclk                => m_axi_s2mm_aclk,
        scndry_resetn              => m_axi_s2mm_aresetn, --'1',
        scndry_out                 => ch_s2mm_pktdrp_reset_s2mm(I),
        scndry_vect_out            => open
    );

    CH_STAT : entity axi_mcdma_v1_1_8.axi_mcdma_pkt_drop
     generic map (
             C_CHANNEL_ID      => I,
             C_COMMON          => 1,
             C_ENABLE_DROP_CNT => C_ENABLE_DROP_CNT,
             C_ENABLE_SINGLE_INTR => C_ENABLE_SINGLE_INTR
             )
     port map (
           m_axi_sg_aclk           => m_axi_s2mm_aclk,
           m_axi_sg_aresetn        => m_axi_s2mm_aresetn, 
           packet_dropped          => packet_dropped,
           dropped_ch_id           => dropped_id_s2mm,

           packet_thresh           => ch_s2mm_pktirqthresh_s2mm(8+8*I-1 downto 8*I),  
           packet_thresh_wren      => ch_s2mm_pktirqthresh_wren_s2mm(I),
           packet_thresh_sts       => ch_s2mm_pktirqthresh_status_s2mm(8+8*I-1 downto 8*I),
           packet_irq              => ch_s2mm_pktdrp_irq_set_s2mm(I),

           reset_pkt_drp_count     => ch_s2mm_pktdrp_reset_s2mm(I), 
           channel_packet_drop_cnt => ch_s2mm_pktdrp_count_s2mm(16+16*I-1 downto 16*I),
           total_packet_drop_cnt   => open
          );



PKTDRP_COUNT_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 0,
        C_VECTOR_WIDTH             => 16,
        C_MTBF_STAGES              => 3 --MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => '0',
        prmry_vect_in              => ch_s2mm_pktdrp_count_s2mm (16+16*I-1 downto 16*I),

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => open,
        scndry_vect_out            => ch_s2mm_pktdrp_count (16+16*I-1 downto 16*I)
    );


PKTDRP_THRESH_STS_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 0,
        C_VECTOR_WIDTH             => 8,
        C_MTBF_STAGES              => 3 --MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => '0',
        prmry_vect_in              => ch_s2mm_pktirqthresh_status_s2mm (8+8*I-1 downto 8*I),

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => open,
        scndry_vect_out            => ch_s2mm_pktirqthresh_status (8+8*I-1 downto 8*I)
    );

process (m_axi_s2mm_aclk)
begin
   if (m_axi_s2mm_aclk'event and m_axi_s2mm_aclk = '1') then
      if (m_axi_s2mm_aresetn = '0') then
         ch_s2mm_pktdrp_irq_set_s2mm_del(I) <= '0';
      else
         ch_s2mm_pktdrp_irq_set_s2mm_del(I) <= ch_s2mm_pktdrp_irq_set_s2mm(I);
      end if;
   end if;
end process;

ch_s2mm_pktdrp_irq_set_s2mm_pulse (I) <= ch_s2mm_pktdrp_irq_set_s2mm (I) and (not ch_s2mm_pktdrp_irq_set_s2mm_del (I));


PKTDRP_IRQ_SET_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 0,
        C_RESET_STATE              => 1,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 1,
        C_MTBF_STAGES              => 4 --MTBF_STAGES
    )
    port map (
        prmry_aclk                 => m_axi_s2mm_aclk,
        prmry_resetn               => m_axi_s2mm_aresetn,
        prmry_in                   => ch_s2mm_pktdrp_irq_set_s2mm_pulse (I),
        prmry_vect_in              => "0",

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => m_axi_sg_aresetn, --'1',
        scndry_out                 => ch_s2mm_pktdrp_irq_set (I),
        scndry_vect_out            => open
    );

end generate CHANNEL_STAT;

UNUSED_CHANNELS: if C_MAX_CHANNELS > C_NUM_S2MM_CHANNELS generate
begin


CHANNEL_STAT : for I in C_NUM_S2MM_CHANNELS to C_MAX_CHANNELS-1 generate
begin

ch_s2mm_pktirqthresh_status(8+8*I-1 downto 8*I) <= (others => '0');
ch_s2mm_pktdrp_irq_set(I) <= '0';
ch_s2mm_pktdrp_count(16+16*I-1 downto 16*I) <= (others => '0');

end generate CHANNEL_STAT;
end generate UNUSED_CHANNELS;

end generate ASYNC_CLOCKS_INTR;

end implementation;


--  (c) Copyright 2012 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
------------------------------------------------------------
-------------------------------------------------------------------------------
-- Filename:    axi_mcdma_sofeof_gen.vhd
-- Description: This entity manages
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library lib_cdc_v1_0_2;
library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_mcdma_sofeof_gen is
    generic (
        C_PRMRY_IS_ACLK_ASYNC           : integer range 0 to 1         := 0;
     
            -- Primary MM2S/S2MM sync/async mode
            -- 0 = synchronous mode     - all clocks are synchronous
            -- 1 = asynchronous mode    - Primary data path channels (MM2S and S2MM)
            --                            run asynchronous to AXI Lite, DMA Control,
            --                            and SG.
        C_ENABLE_SINGLE_INTR            : integer range 0 to 1         := 0;
        C_MAX_CHANNELS                  : integer range 1 to 16        := 8;
        C_FAMILY                        : string                    := "virtex6"

    );
    port (
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        axi_prmry_aclk              : in  std_logic                         ;           --
        p_reset_n                   : in  std_logic                         ;           --
                                                                                        --
        m_axi_sg_aclk               : in  std_logic                         ;           --
        m_axi_sg_aresetn            : in  std_logic                         ;           --
                                                                                        --
        axis_tready                 : in  std_logic                         ;           --
        axis_tvalid                 : in  std_logic                         ;           --
        axis_tlast                  : in  std_logic                         ;           --
        axis_tdest                  : in  std_logic_vector (3 downto 0)                         ;           --
                                                                                        --
        packet_sof_ch                  : out std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;           --
        packet_eof_ch                  : out std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;            --
                                                                                        --
        packet_sof                  : out std_logic                         ;           --
        packet_eof                  : out std_logic                                     --

    );

end axi_mcdma_sofeof_gen;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_sofeof_gen is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";


  ATTRIBUTE async_reg                      : STRING;

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal p_ready          : std_logic := '0';
signal p_valid          : std_logic := '0';
signal p_valid_d1       : std_logic := '0';
signal p_valid_re       : std_logic := '0';
signal p_last           : std_logic := '0';
signal p_last_d1        : std_logic := '0';
signal p_last_re        : std_logic := '0';
signal p_tdest          : std_logic_vector (3 downto 0);
signal p_sof_tdest          : std_logic_vector (3 downto 0);
signal s_sof_tdest          : std_logic_vector (3 downto 0);


signal s_ready          : std_logic := '0';
signal s_valid          : std_logic := '0';
signal s_valid_d1       : std_logic := '0';
signal s_valid_re       : std_logic := '0';
signal s_last           : std_logic := '0';
signal s_last_d1        : std_logic := '0';
signal s_last_re        : std_logic := '0';



signal s_sof_d1_cdc_tig         : std_logic := '0';
signal s_sof_d2         : std_logic := '0';
  --ATTRIBUTE async_reg OF s_sof_d1_cdc_tig  : SIGNAL IS "true";
  --ATTRIBUTE async_reg OF s_sof_d2  : SIGNAL IS "true";

signal s_sof_d3         : std_logic := '0';
signal s_sof_re         : std_logic := '0';

signal s_sof            : std_logic := '0';
signal p_sof            : std_logic := '0';

signal s_eof_d1_cdc_tig         : std_logic := '0';
signal s_eof_d2         : std_logic := '0';

  --ATTRIBUTE async_reg OF s_eof_d1_cdc_tig  : SIGNAL IS "true";
  --ATTRIBUTE async_reg OF s_eof_d2 : SIGNAL IS "true";
signal s_eof_d3         : std_logic := '0';
signal s_eof_re         : std_logic := '0';

signal p_eof            : std_logic := '0';
signal p_eof_d1_cdc_tig         : std_logic := '0';
signal p_eof_d2         : std_logic := '0';
  --ATTRIBUTE async_reg OF p_eof_d1_cdc_tig  : SIGNAL IS "true";
  --ATTRIBUTE async_reg OF p_eof_d2 : SIGNAL IS "true";

signal p_eof_d3         : std_logic := '0';
signal p_eof_clr        : std_logic := '0';

signal s_sof_generated  : std_logic := '0';
signal sof_generated_fe : std_logic := '0';
signal s_eof_re_latch   : std_logic := '0';

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin


--SINGLE_INTERRUPT : if C_ENABLE_SINGLE_INTR = 1 generate
--begin

--           packet_sof <= s_sof_re;
--           packet_eof <= s_eof_re;

--           packet_sof_ch <= (others => '0');
--           packet_eof_ch <= (others => '0');

--end generate SINGLE_INTERRUPT;

MULTI_INTERRUPT : if C_ENABLE_SINGLE_INTR = 0 generate
begin
-- pass internal version out

           packet_sof <= '0';
           packet_eof <= '0';

process (s_sof_tdest, s_sof_re, s_eof_re)
begin

           packet_sof_ch <= (others => '0');
           packet_eof_ch <= (others => '0');

      case (s_sof_tdest) is
        when "0000" =>
           packet_sof_ch(0) <= s_sof_re;
           packet_eof_ch(0) <= s_eof_re;
        when "0001" =>
           packet_sof_ch(1) <= s_sof_re;
           packet_eof_ch(1) <= s_eof_re;
        when "0010" =>
           packet_sof_ch(2) <= s_sof_re;
           packet_eof_ch(2) <= s_eof_re;
        when "0011" =>
           packet_sof_ch(3) <= s_sof_re;
           packet_eof_ch(3) <= s_eof_re;
        when "0100" =>
           packet_sof_ch(4) <= s_sof_re;
           packet_eof_ch(4) <= s_eof_re;
        when "0101" =>
           packet_sof_ch(5) <= s_sof_re;
           packet_eof_ch(5) <= s_eof_re;
        when "0110" =>
           packet_sof_ch(6) <= s_sof_re;
           packet_eof_ch(6) <= s_eof_re;
        when "0111" =>
           packet_sof_ch(7) <= s_sof_re;
           packet_eof_ch(7) <= s_eof_re;
        when "1000" =>
           packet_sof_ch(8) <= s_sof_re;
           packet_eof_ch(8) <= s_eof_re;
        when "1001" =>
           packet_sof_ch(9) <= s_sof_re;
           packet_eof_ch(9) <= s_eof_re;
        when "1010" =>
           packet_sof_ch(10) <= s_sof_re;
           packet_eof_ch(10) <= s_eof_re;
        when "1011" =>
           packet_sof_ch(11) <= s_sof_re;
           packet_eof_ch(11) <= s_eof_re;
        when "1100" =>
           packet_sof_ch(12) <= s_sof_re;
           packet_eof_ch(12) <= s_eof_re;
        when "1101" =>
           packet_sof_ch(13) <= s_sof_re;
           packet_eof_ch(13) <= s_eof_re;
        when "1110" =>
           packet_sof_ch(14) <= s_sof_re;
           packet_eof_ch(14) <= s_eof_re;
        when "1111" =>
           packet_sof_ch(15) <= s_sof_re;
           packet_eof_ch(15) <= s_eof_re;

--        when "1000" =>
--           packet_sof_ch9 <= s_sof_re;
--           packet_eof_ch9 <= s_eof_re;
          -- coverage off
        when others => 
           packet_sof_ch <= (others => '0');
           packet_eof_ch <= (others => '0');
          -- coverage on

      end case;
end process;
end generate MULTI_INTERRUPT;

-- Generate for when primary clock is asynchronous
GEN_FOR_ASYNC : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
signal sinit : std_logic;
signal s_sof_re_mm2s : std_logic;
signal s_eof_re_mm2s : std_logic;
signal fifo_write_data : std_logic_vector (5 downto 0);
signal fifo_read_data : std_logic_vector (5 downto 0);
signal s_sof_tdest_mm2s : std_logic_vector (3 downto 0);
signal fifo_write : std_logic;
signal fifo_read : std_logic;
signal fifo_empty: std_logic;

begin


    REG_STRM_IN : process(axi_prmry_aclk)
        begin
            if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
                if(p_reset_n = '0')then
                    s_valid <= '0';
                    s_last  <= '0';
                    s_ready <= '0';
                    s_sof_tdest_mm2s <= (others => '0');
                else
                    s_valid <= axis_tvalid;
                    s_last  <= axis_tlast ;
                    s_ready <= axis_tready;
                    s_sof_tdest_mm2s <= axis_tdest;
                end if;
            end if;
        end process REG_STRM_IN;

    process(axi_prmry_aclk)
        begin
            if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
                if(p_reset_n = '0')then
                    s_valid_d1  <= '0';
                elsif (s_last = '1' and s_valid = '1' and s_ready = '1') then
                    s_valid_d1  <= '0';
                elsif (s_valid = '1') then
                    s_valid_d1  <= '1';
                end if;
            end if;
    end process;

    process(axi_prmry_aclk)
        begin
            if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
                if(p_reset_n = '0')then
                    s_last_d1  <= '0';
                elsif (s_last = '1' and s_valid = '1' and s_ready = '1') then
                    s_last_d1  <= '1';
                elsif (s_valid = '1') then
                    s_last_d1  <= '0';
                end if;
            end if;
    end process;

s_sof_re_mm2s <= s_valid and (not s_valid_d1);
s_eof_re_mm2s <= (s_valid and s_last and s_ready); -- and (not (s_last_d1));

fifo_write_data <= s_sof_tdest_mm2s & s_sof_re_mm2s & s_eof_re_mm2s;
fifo_write <= s_sof_re_mm2s or s_eof_re_mm2s;

    sinit <= not p_reset_n; 

    -- Generate Asynchronous FIFO
    I_SOF_EOF_FIFO : entity axi_mcdma_v1_1_8.axi_mcdma_afifo_autord
      generic map(
         C_DWIDTH        => 6  ,
         C_DEPTH         => 16                                  ,
         C_CNT_WIDTH     => 5                                   ,
         C_USE_BLKMEM    => 0                     ,
         C_FAMILY        => C_FAMILY
        )
      port map(
        -- Inputs
         AFIFO_Ainit                => sinit                    ,
         AFIFO_Wr_clk               => axi_prmry_aclk            ,
         AFIFO_Wr_en                => fifo_write      ,
         AFIFO_Din                  => fifo_write_data,
         AFIFO_Rd_clk               => m_axi_sg_aclk,
         AFIFO_Rd_en                => fifo_read,
         AFIFO_Clr_Rd_Data_Valid    => '0'                      ,

        -- Outputs
         AFIFO_DValid               => open        ,
         AFIFO_Dout                 => fifo_read_data,
         AFIFO_Full                 => open      ,
         AFIFO_Empty                => fifo_empty,
         AFIFO_Almost_full          => open                     ,
         AFIFO_Almost_empty         => open                     ,
         AFIFO_Wr_count             => open                     ,
         AFIFO_Rd_count             => open                     ,
         AFIFO_Corr_Rd_count        => open                     ,
         AFIFO_Corr_Rd_count_minus1 => open                     ,
         AFIFO_Rd_ack               => open
        );

fifo_read <= not (fifo_empty);
s_sof_tdest <= fifo_read_data (5 downto 2);
s_sof_re <= fifo_read_data (1) and (not fifo_empty);
s_eof_re <= fifo_read_data (0) and (not fifo_empty);




end generate GEN_FOR_ASYNC;

-- Generate for when primary clock is synchronous
GEN_FOR_SYNC : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
begin

    ---------------------------------------------------------------------------
    -- Generate Packet EOF and SOF
    ---------------------------------------------------------------------------

    -- Register stream control in to isolate wrt clock
    -- for timing closure
    REG_STRM_IN : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    s_valid <= '0';
                    s_last  <= '0';
                    s_ready <= '0';
                    s_sof_tdest <= (others => '0');
                else
                    s_valid <= axis_tvalid;
                    s_last  <= axis_tlast ;
                    s_ready <= axis_tready;
                    s_sof_tdest <= axis_tdest;
                end if;
            end if;
        end process REG_STRM_IN;

    process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    s_valid_d1  <= '0';
                elsif (s_last = '1' and s_valid = '1' and s_ready = '1') then
                    s_valid_d1  <= '0';
                elsif (s_valid = '1') then
                    s_valid_d1  <= '1';
                end if;
            end if;
    end process;

    process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    s_last_d1  <= '0';
                elsif (s_last = '1' and s_valid = '1' and s_ready = '1') then
                    s_last_d1  <= '1';
                elsif (s_valid = '1') then
                    s_last_d1  <= '0';
                end if;
            end if;
    end process;

s_sof_re <= s_valid and (not s_valid_d1);
s_eof_re <= (s_valid and s_last and s_ready); -- and (not (s_last_d1));


end generate GEN_FOR_SYNC;



end implementation;


--  (c) Copyright 2012 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
------------------------------------------------------------
-------------------------------------------------------------------------------
-- Filename:          axi_mcdma_smple_sm.vhd
-- Description: This entity contains the DMA Controller State Machine for
--              Simple DMA mode.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.clog2;


-------------------------------------------------------------------------------
entity  axi_mcdma_smple_sm is
    generic (
        C_M_AXI_ADDR_WIDTH          : integer range 32 to 64    := 32;
            -- Master AXI Memory Map Address Width for MM2S Read Port

        C_SG_LENGTH_WIDTH           : integer range 8 to 23     := 14;
            -- Width of Buffer Length, Transferred Bytes, and BTT fields

        C_MICRO_DMA                 : integer range 0 to 1      := 0
    );
    port (
        m_axi_sg_aclk               : in  std_logic                         ;                      --
        m_axi_sg_aresetn            : in  std_logic                         ;                      --
                                                                                                   --
        -- Channel 1 Control and Status                                                            --
        run_stop                    : in  std_logic                         ;                      --
        keyhole                     : in  std_logic                         ;
        stop                        : in  std_logic                         ;                      --
        cmnd_idle                   : out std_logic                         ;                      --
        sts_idle                    : out std_logic                         ;                      --
                                                                                                   --
        -- DataMover Status                                                                        --
        sts_received                : in  std_logic                         ;                      --
        sts_received_clr            : out std_logic                         ;                      --
                                                                                                   --
        -- DataMover Command                                                                       --
        cmnd_wr                     : out std_logic                         ;                      --
        cmnd_data                   : out std_logic_vector                                         --
                                           ((C_M_AXI_ADDR_WIDTH-32+2*32+CMD_BASE_WIDTH+46)-1 downto 0);       --
        cmnd_pending                : in std_logic                          ;                      --
                                                                                                   --
        -- Trasnfer Qualifiers                                                                     --
        xfer_length_wren            : in  std_logic                         ;                      --
        xfer_address                : in  std_logic_vector                                         --
                                        (C_M_AXI_ADDR_WIDTH-1 downto 0)     ;                      --
        xfer_length                 : in  std_logic_vector                                         --
                                        (C_SG_LENGTH_WIDTH - 1 downto 0)                           --
    );

end axi_mcdma_smple_sm;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_smple_sm is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";


-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
-- DataMover Command Destination Stream Offset
constant CMD_DSA            : std_logic_vector(5 downto 0)  := (others => '0');
-- DataMover Cmnd Reserved Bits
constant CMD_RSVD           : std_logic_vector(
                                DATAMOVER_CMD_RSVMSB_BOFST + C_M_AXI_ADDR_WIDTH downto
                                DATAMOVER_CMD_RSVLSB_BOFST + C_M_AXI_ADDR_WIDTH)
                                := (others => '0');


-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
type SMPL_STATE_TYPE        is (
                                IDLE,
                                EXECUTE_XFER,
                                WAIT_STATUS
                                );

signal smpl_cs                  : SMPL_STATE_TYPE;
signal smpl_ns                  : SMPL_STATE_TYPE;



-- State Machine Signals
signal write_cmnd_cmb           : std_logic := '0';
signal cmnd_wr_i                : std_logic := '0';
signal sts_received_clr_cmb     : std_logic := '0';

signal cmnds_queued             : std_logic := '0';
signal cmd_dumb                 : std_logic_vector (31 downto 0) := (others => '0');
signal zeros                    : std_logic_vector (45 downto 0) := (others => '0');

signal burst_type               : std_logic;
-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin
-- Pass command write control out
cmnd_wr    <= cmnd_wr_i;

burst_type <= '1' and (not keyhole);
-- 0 means fixed burst
-- 1 means increment burst

-------------------------------------------------------------------------------
-- MM2S Transfer State Machine
-------------------------------------------------------------------------------
MM2S_MACHINE : process(smpl_cs,
                       run_stop,
                       xfer_length_wren,
                       sts_received,
                       cmnd_pending,
                       cmnds_queued,
                       stop
                       )
    begin

        -- Default signal assignment
        write_cmnd_cmb          <= '0';
        sts_received_clr_cmb    <= '0';
        cmnd_idle               <= '0';
        smpl_ns                 <= smpl_cs;

        case smpl_cs is

            -------------------------------------------------------------------
            when IDLE =>
                -- Running, no errors, and new length written,then execute
                -- transfer
                if( run_stop = '1' and xfer_length_wren = '1' and stop = '0'
                and cmnds_queued = '0') then
                    smpl_ns <= EXECUTE_XFER;
                else
                    cmnd_idle <= '1';
                end if;


            -------------------------------------------------------------------
            when EXECUTE_XFER =>
                -- error detected
                if(stop = '1')then
                    smpl_ns     <= IDLE;
                -- Write another command if there is not one already pending
                elsif(cmnd_pending = '0')then
                    write_cmnd_cmb  <= '1';
                    smpl_ns         <= WAIT_STATUS;
                else
                    smpl_ns         <= EXECUTE_XFER;
                end if;

            -------------------------------------------------------------------
            when WAIT_STATUS =>
                -- wait until desc update complete or error occurs
                if(sts_received = '1' or stop = '1')then
                    sts_received_clr_cmb <= '1';
                    smpl_ns              <= IDLE;
                else
                    smpl_ns <= WAIT_STATUS;
                end if;

            -------------------------------------------------------------------
--          coverage off
            when others =>
                smpl_ns <= IDLE;
--          coverage on

        end case;
    end process MM2S_MACHINE;

-------------------------------------------------------------------------------
-- register state machine states
-------------------------------------------------------------------------------
REGISTER_STATE : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                smpl_cs     <= IDLE;
            else
                smpl_cs     <= smpl_ns;
            end if;
        end if;
    end process REGISTER_STATE;

-- Register state machine signals
REGISTER_STATE_SIGS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn ='0')then
                sts_received_clr    <= '0';
            else
                sts_received_clr    <= sts_received_clr_cmb;
            end if;
        end if;
    end process REGISTER_STATE_SIGS;

-------------------------------------------------------------------------------
-- Build DataMover command
-------------------------------------------------------------------------------
-- If Bytes To Transfer (BTT) width less than 23, need to add pad
GEN_CMD_BTT_LESS_23 : if C_SG_LENGTH_WIDTH < 23 generate
constant PAD_VALUE : std_logic_vector(22 - C_SG_LENGTH_WIDTH downto 0)
                        := (others => '0');
begin
    -- When command by sm, drive command to mm2s_cmdsts_if
    GEN_DATAMOVER_CMND : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    cmnd_wr_i       <= '0';
                    cmnd_data       <= (others => '0');

                -- SM issued a command write
                elsif(write_cmnd_cmb = '1')then
                    cmnd_wr_i       <= '1';
                    cmnd_data       <=  zeros
                                        & cmd_dumb 
                                        & CMD_RSVD
                                        -- Command Tag
                                        & '0'               -- Tag Not Used in Simple Mode
                                        & '0'               -- Tag Not Used in Simple Mode
                                        & '0'               -- Tag Not Used in Simple Mode
                                        & '0'               -- Tag Not Used in Simple Mode
                                        -- Command
                                        & xfer_address      -- Command Address
                                        & '1'               -- Command SOF
                                        & '1'               -- Command EOF
                                        & CMD_DSA           -- Stream Offset
                                        & burst_type  -- Key Hole Operation'1'               -- Not Used
                                        & PAD_VALUE
                                        & xfer_length;

                else
                    cmnd_wr_i       <= '0';

                end if;
            end if;
        end process GEN_DATAMOVER_CMND;

end generate GEN_CMD_BTT_LESS_23;

-- If Bytes To Transfer (BTT) width equal 23, no required pad
GEN_CMD_BTT_EQL_23 : if C_SG_LENGTH_WIDTH = 23 generate
begin
    -- When command by sm, drive command to mm2s_cmdsts_if
    GEN_DATAMOVER_CMND : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    cmnd_wr_i       <= '0';
                    cmnd_data       <= (others => '0');

                -- SM issued a command write
                elsif(write_cmnd_cmb = '1')then
                    cmnd_wr_i       <= '1';
                    cmnd_data       <=  zeros 
                                        & cmd_dumb
                                        & CMD_RSVD
                                        -- Command Tag
                                        & '0'                   -- Tag Not Used in Simple Mode
                                        & '0'                   -- Tag Not Used in Simple Mode
                                        & '0'                   -- Tag Not Used in Simple Mode
                                        & '0'                   -- Tag Not Used in Simple Mode
                                        -- Command
                                        & xfer_address          -- Command Address
                                        & '1'                   -- Command SOF
                                        & '1'                   -- Command EOF
                                        & CMD_DSA               -- Stream Offset
                                        & burst_type  -- key Hole Operation '1'                   -- Not Used
                                        & xfer_length;

                else
                    cmnd_wr_i       <= '0';

                end if;
            end if;
        end process GEN_DATAMOVER_CMND;

end generate GEN_CMD_BTT_EQL_23;


-------------------------------------------------------------------------------
-- Flag indicating command being processed by Datamover
-------------------------------------------------------------------------------

-- count number of queued commands to keep track of what datamover is still
-- working on
CMD2STS_COUNTER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0' or stop = '1')then
                cmnds_queued <= '0';
            elsif(cmnd_wr_i = '1')then
                cmnds_queued <= '1';
            elsif(sts_received = '1')then
                cmnds_queued <= '0';
            end if;
        end if;
    end process CMD2STS_COUNTER;

-- Indicate status is idle when no cmnd/sts queued
sts_idle <= '1' when  cmnds_queued = '0'
       else '0';

end implementation;


-------------------------------------------------------------------------------
-- axi_mcdma_mm2s_tdest
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_mcdma_mm2s_tdest.vhd
-- Description:       This entity is MM2S tdest tid
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.clog2;
use lib_pkg_v1_0_2.lib_pkg.max2;

library lib_fifo_v1_0_16;

-------------------------------------------------------------------------------
entity  axi_mcdma_mm2s_tdest is
    generic(
        
        C_PRMRY_IS_ACLK_ASYNC           : integer range 0 to 1      := 0;
        C_FAMILY                        : string                    := "virtex6"
    );
    port (
        -- Secondary clock / reset
        m_axi_sg_aclk               : in  std_logic                         ;           --
        m_axi_sg_aresetn            : in  std_logic                         ;           --
                                                                                        --
        -- Primary clock / reset                                                        --
        axi_prmry_aclk              : in  std_logic                         ;           --
        p_reset_n                   : in  std_logic                         ;           --
        mm2s_tlast                  : in  std_logic                         ;
        mm2s_tready                 : in  std_logic                         ;

        tuser_data                  : in std_logic_vector (15 downto 0);
        tid_data                    : in std_logic_vector (7 downto 0);
        tuser_wr_en                 : in std_logic;
        tid_wr_en                   : in std_logic;

        tdest_data                  : in std_logic_vector (3 downto 0);
        tdest_wr_en                 : in std_logic;

        tuser_out                   : out std_logic_vector (15 downto 0);
        tid_out                     : out std_logic_vector (7 downto 0);
        tdest_out                   : out std_logic_vector (3 downto 0)
    );
end axi_mcdma_mm2s_tdest;


architecture implementation of axi_mcdma_mm2s_tdest is

constant USE_LOGIC_FIFOS        : integer   := 0; -- Use Logic FIFOs
constant CNTRL_FIFO_DEPTH       : integer := 16;
constant CNTRL_FIFO_CNT_WIDTH   : integer := 5;
signal rd_en_tdest : std_logic;
signal rd_en_tuser : std_logic;
signal rd_en_tid : std_logic;
signal empty_tdest : std_logic;
signal empty_tuser : std_logic;
signal empty_tid : std_logic;
signal sinit : std_logic;
signal tuser_out_int : std_logic_vector (15 downto 0);
signal tdest_tid_out_int : std_logic_vector (11 downto 0);
signal tdest_tid : std_logic_vector (11 downto 0);
begin

tuser_out <= tuser_out_int when (mm2s_tlast = '1') else (others => '0');
tid_out <= tdest_tid_out_int (11 downto 4);
tdest_out <= tdest_tid_out_int (3 downto 0);
tdest_tid <= tid_data & tdest_data;


GEN_SYNC_FIFO : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
begin
    -- reset on hard reset or mm2s stop
    sinit   <= not m_axi_sg_aresetn;

    -- Generate Synchronous FIFO
    I_TUSER_FIFO : entity lib_fifo_v1_0_16.sync_fifo_fg
    generic map (
        C_FAMILY                =>  C_FAMILY                ,
        C_MEMORY_TYPE           =>  USE_LOGIC_FIFOS,
        C_WRITE_DATA_WIDTH      =>  16,
        C_WRITE_DEPTH           =>  CNTRL_FIFO_DEPTH       ,
        C_READ_DATA_WIDTH       =>  16,
        C_READ_DEPTH            =>  CNTRL_FIFO_DEPTH       ,
        C_PORTS_DIFFER          =>  0,
        C_HAS_DCOUNT            =>  1, --req for proper fifo operation
        C_DCOUNT_WIDTH          =>  CNTRL_FIFO_CNT_WIDTH,
        C_HAS_ALMOST_FULL       =>  0,
        C_HAS_RD_ACK            =>  0,
        C_HAS_RD_ERR            =>  0,
        C_HAS_WR_ACK            =>  0,
        C_HAS_WR_ERR            =>  0,
        C_RD_ACK_LOW            =>  0,
        C_RD_ERR_LOW            =>  0,
        C_WR_ACK_LOW            =>  0,
        C_WR_ERR_LOW            =>  0,
        C_PRELOAD_REGS          =>  1,-- 1 = first word fall through
        C_PRELOAD_LATENCY       =>  0, -- 0 = first word fall through
        C_XPM_FIFO              =>  1 

    )
    port map (

        Clk             =>  m_axi_sg_aclk       ,
        Sinit           =>  sinit               ,
        Din             =>  tuser_data  ,
        Wr_en           =>  tuser_wr_en     ,
        Rd_en           =>  rd_en_tuser, --mm2s_tlast      ,
        Dout            =>  tuser_out_int   ,
        Full            =>  open ,
        Empty           =>  empty_tuser ,
        Almost_full     =>  open                ,
        Data_count      =>  open                ,
        Rd_ack          =>  open                ,
        Rd_err          =>  open                ,
        Wr_ack          =>  open                ,
        Wr_err          =>  open

    );

rd_en_tuser <= mm2s_tlast and (not empty_tuser) and mm2s_tready;

    -- Generate Synchronous FIFO
    I_TDEST_TID_FIFO : entity lib_fifo_v1_0_16.sync_fifo_fg
    generic map (
        C_FAMILY                =>  C_FAMILY                ,
        C_MEMORY_TYPE           =>  USE_LOGIC_FIFOS,
        C_WRITE_DATA_WIDTH      =>  12,
        C_WRITE_DEPTH           =>  CNTRL_FIFO_DEPTH       ,
        C_READ_DATA_WIDTH       =>  12,
        C_READ_DEPTH            =>  CNTRL_FIFO_DEPTH       ,
        C_PORTS_DIFFER          =>  0,
        C_HAS_DCOUNT            =>  1, --req for proper fifo operation
        C_DCOUNT_WIDTH          =>  CNTRL_FIFO_CNT_WIDTH,
        C_HAS_ALMOST_FULL       =>  0,
        C_HAS_RD_ACK            =>  0,
        C_HAS_RD_ERR            =>  0,
        C_HAS_WR_ACK            =>  0,
        C_HAS_WR_ERR            =>  0,
        C_RD_ACK_LOW            =>  0,
        C_RD_ERR_LOW            =>  0,
        C_WR_ACK_LOW            =>  0,
        C_WR_ERR_LOW            =>  0,
        C_PRELOAD_REGS          =>  1,-- 1 = first word fall through
        C_PRELOAD_LATENCY       =>  0, -- 0 = first word fall through
        C_XPM_FIFO              =>  1 

    )
    port map (

        Clk             =>  m_axi_sg_aclk       ,
        Sinit           =>  sinit               ,
        Din             =>  tdest_tid, --tdest_data  ,
        Wr_en           =>  tdest_wr_en     ,
        Rd_en           =>  rd_en_tdest, --mm2s_tlast      ,
        Dout            =>  tdest_tid_out_int   ,
        Full            =>  open ,
        Empty           =>  empty_tdest ,
        Almost_full     =>  open                ,
        Data_count      =>  open                ,
        Rd_ack          =>  open                ,
        Rd_err          =>  open                ,
        Wr_ack          =>  open                ,
        Wr_err          =>  open

    );

rd_en_tdest <= mm2s_tlast and (not empty_tdest) and mm2s_tready;

end generate GEN_SYNC_FIFO;


GEN_ASYNC_FIFO : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
begin

    -- reset on hard reset, soft reset, or mm2s error
    --sinit   <= not p_reset_n;
    sinit   <= not m_axi_sg_aresetn;

    -- Generate Asynchronous FIFO
    I_TUSER_FIFO : entity axi_mcdma_v1_1_8.axi_mcdma_afifo_autord
      generic map(
         C_DWIDTH        => 16  ,
-- Temp work around for issue in async fifo model
         C_DEPTH         => CNTRL_FIFO_DEPTH                    ,
--         C_CNT_WIDTH     => CNTRL_FIFO_CNT_WIDTH                ,
--         C_DEPTH         => 31                                  ,
         C_CNT_WIDTH     => 5                                   ,
         C_USE_BLKMEM    => USE_LOGIC_FIFOS                     ,
         C_FAMILY        => C_FAMILY
        )
      port map(
        -- Inputs
         AFIFO_Ainit                => sinit                    ,
         AFIFO_Wr_clk               => m_axi_sg_aclk            ,
         AFIFO_Wr_en                => tuser_wr_en      ,
         AFIFO_Din                  => tuser_data       ,
         AFIFO_Rd_clk               => axi_prmry_aclk           ,
         AFIFO_Rd_en                => rd_en_tuser, --mm2s_tlast          ,
         AFIFO_Clr_Rd_Data_Valid    => '0'                      ,

        -- Outputs
         AFIFO_DValid               => open        ,
         AFIFO_Dout                 => tuser_out_int          ,
         AFIFO_Full                 => open      ,
         AFIFO_Empty                => empty_tuser, --open         ,
         AFIFO_Almost_full          => open                     ,
         AFIFO_Almost_empty         => open                     ,
         AFIFO_Wr_count             => open                     ,
         AFIFO_Rd_count             => open                     ,
         AFIFO_Corr_Rd_count        => open                     ,
         AFIFO_Corr_Rd_count_minus1 => open                     ,
         AFIFO_Rd_ack               => open
        );

rd_en_tuser <= mm2s_tlast and (not empty_tuser) and mm2s_tready;

    -- Generate Asynchronous FIFO
    I_TDEST_TID_FIFO : entity axi_mcdma_v1_1_8.axi_mcdma_afifo_autord
      generic map(
         C_DWIDTH        => 12  ,
-- Temp work around for issue in async fifo model
         C_DEPTH         => CNTRL_FIFO_DEPTH                    ,
--         C_CNT_WIDTH     => CNTRL_FIFO_CNT_WIDTH                ,
--         C_DEPTH         => 31                                  ,
         C_CNT_WIDTH     => 5                                   ,
         C_USE_BLKMEM    => USE_LOGIC_FIFOS                     ,
         C_FAMILY        => C_FAMILY
        )
      port map(
        -- Inputs
         AFIFO_Ainit                => sinit                    ,
         AFIFO_Wr_clk               => m_axi_sg_aclk            ,
         AFIFO_Wr_en                => tdest_wr_en      ,
         AFIFO_Din                  => tdest_tid, --tdest_data       ,
         AFIFO_Rd_clk               => axi_prmry_aclk           ,
         AFIFO_Rd_en                => rd_en_tdest, --mm2s_tlast          ,
         AFIFO_Clr_Rd_Data_Valid    => '0'                      ,

        -- Outputs
         AFIFO_DValid               => open        ,
         AFIFO_Dout                 => tdest_tid_out_int          ,
         AFIFO_Full                 => open      ,
         AFIFO_Empty                => empty_tdest, --open         ,
         AFIFO_Almost_full          => open                     ,
         AFIFO_Almost_empty         => open                     ,
         AFIFO_Wr_count             => open                     ,
         AFIFO_Rd_count             => open                     ,
         AFIFO_Corr_Rd_count        => open                     ,
         AFIFO_Corr_Rd_count_minus1 => open                     ,
         AFIFO_Rd_ack               => open
        );

rd_en_tdest <= mm2s_tlast and (not empty_tdest) and mm2s_tready;

end generate GEN_ASYNC_FIFO;


end implementation;


-------------------------------------------------------------------------------
-- axi_mcdma_mm2s_priority
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_mcdma_mm2s_priority.vhd
-- Description: This entity is the top level entity for the AXI DMA MM2S
--              manager.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_mcdma_mm2s_priority is
    generic(

        C_PRMRY_IS_ACLK_ASYNC       : integer range 0 to 1         := 0;
            -- Primary MM2S/S2MM sync/async mode
            -- 0 = synchronous mode     - all clocks are synchronous
            -- 1 = asynchronous mode    - Primary data path channels (MM2S and S2MM)
            --                            run asynchronous to AXI Lite, DMA Control,
            --                            and SG.

        C_NUM_CHANNELS              : integer range 1 to 16 := 1;
        C_MM2S_SEQUENCE             : integer range 0 to 3 := 1;
        C_MAX_CHANNELS              : integer range 1 to 16 := 16;

        C_FAMILY                        : string            := "kintex7"
            -- Target FPGA Device Family
    );
    port (
        -- Secondary Clock and Reset
        m_axi_sg_aclk               : in  std_logic                         ;                 --
        m_axi_sg_aresetn            : in  std_logic                         ;                 --
                                                                                              --
        -- Primary Clock and Reset                                                            --
        axi_prmry_aclk              : in  std_logic                         ;                 --
        p_reset_n                   : in  std_logic                         ;                 --

        start_trigger               : in std_logic                          ; -- when the mm2s is started
        channel_enable              : in std_logic_vector (C_MAX_CHANNELS-1 downto 0); -- channels enabled 

        channel_weight              : in std_logic_vector (31 downto 0); -- weight for channel 1-8
        channel_weight_2            : in std_logic_vector (31 downto 0); -- weight for channel 9-16

        mm2s_new_curdesc_wren       : in std_logic;
        channel_eof                 : in std_logic;                      -- eof as detected from bds read (from sg_if)
        channel_sof                 : in std_logic;                      -- sof as detected from bds read (from sg_if)
        tuser_tid_from_sg           : in std_logic_vector (23 downto 0);

        channel_idle                : in std_logic_vector (C_MAX_CHANNELS-1 downto 0); -- idle status of channels
        mm2s_schedule               : in std_logic_vector (3 downto 0);  -- mm2s scheduler from register
        ch_id_to_sg                 : out std_logic_vector (C_MAX_CHANNELS-1 downto 0);

        tdest_to_fifo               : out std_logic_vector (3 downto 0);
        tdest_wr_en                 : out std_logic;
        tuser_wr_en                 : out std_logic;
        tid_wr_en                   : out std_logic;
        tuser_to_fifo               : out std_logic_vector (15 downto 0);
        tid_to_fifo                 : out std_logic_vector (7 downto 0)
        
    );

end axi_mcdma_mm2s_priority;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_mm2s_priority is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";


signal channels_captured : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal start : std_logic;
signal start_delayed : std_logic;

signal shift_reg : std_logic_vector (C_MAX_CHANNELS-1 downto 0) := x"0001";
signal ch_completed : std_logic_vector (C_MAX_CHANNELS-1 downto 0) := x"0000";
signal high_pr_channel : std_logic_vector (C_MAX_CHANNELS-1 downto 0) := x"0000";
signal go_back : std_logic;
signal back_to_ch0 : std_logic;
signal move_to_next : std_logic;
signal iteration_complete : std_logic;
signal qualified : std_logic_vector (C_MAX_CHANNELS-1 downto 0);

signal ch_under_service : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal tdest : std_logic_vector (3 downto 0);
signal tdest_capture : std_logic_vector (3 downto 0);
signal tdest_capture_del : std_logic_vector (3 downto 0);
signal go_back_eof : std_logic;
-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin


process (m_axi_sg_aclk)
begin
if (m_axi_sg_aclk 'event and m_axi_sg_aclk = '1') then
if (m_axi_sg_aresetn = '0') then
    start_delayed <= '0';
else
    start_delayed <= start_trigger;
end if;
end if;
end process;

start <= start_trigger and (not start_delayed);

-- the LSB of the following register has the highest priority

process (m_axi_sg_aclk)
begin
if (m_axi_sg_aclk 'event and m_axi_sg_aclk = '1') then
    if (m_axi_sg_aresetn = '0') then
       channels_captured <= (others => '0');
    elsif (start = '1' or iteration_complete = '1' or go_back_eof = '1') then
       channels_captured <= channel_enable; -- channel enable captured at iteration complete or eof
    end if;
end if;
end process;


iteration_complete <= '1' when (shift_reg = x"0000") else '0';

process (m_axi_sg_aclk)
begin
if (m_axi_sg_aclk 'event and m_axi_sg_aclk = '1') then
if (m_axi_sg_aresetn = '0') then
    shift_reg (0) <= '1';
    shift_reg (C_MAX_CHANNELS-1 downto 1) <= (others => '0');
--elsif (iteration_complete = '1' or (move_to_next = '1' and go_back = '1')) then
elsif (iteration_complete = '1' or (go_back_eof = '1' and go_back = '1')) then
    shift_reg (0) <= '1';
    shift_reg (C_MAX_CHANNELS-1 downto 1) <= (others => '0');
elsif (move_to_next = '1') then
    shift_reg (0) <= '0';
    shift_reg (C_MAX_CHANNELS-1 downto 1) <= shift_reg (C_MAX_CHANNELS-2 downto 0);
end if;
end if;
end process; 

-- following signal will give me the channels that are qualified to run through
-- channels_captured will not change for iteration
-- channels_idle is dynamic, can change based on CD/TD programming
    
   qualified <= channels_captured and not(channel_idle);

--process (m_axi_sg_aclk)
--begin
--if (m_axi_sg_aclk 'event and m_axi_sg_aclk = '1') then
--if (m_axi_sg_aresetn = '0') then
--   qualified <= (others => '0');
--else --if (start = '1' or (go_back_eof = '1')) then
--   qualified <= channels_captured and not(channel_idle);
----   qualified <= channel_enable and not(channel_idle);
--end if;
--end if;
--end process;

-- following is the one-hot signal which tell which channel is being serviced


move_to_next <= '1' when (ch_under_service = x"0000") else '0';
go_back_eof <= channel_eof and mm2s_new_curdesc_wren;


process (m_axi_sg_aclk)
begin
if (m_axi_sg_aclk 'event and m_axi_sg_aclk = '1') then
if (m_axi_sg_aresetn = '0') then
     ch_completed <= (others => '0');
--elsif (move_to_next = '1' and go_back = '1') then
elsif (go_back_eof = '1' and go_back = '1') then
     ch_completed <= (others => '0');
elsif (move_to_next = '1') then
     ch_completed (0) <= '1';
     ch_completed (C_MAX_CHANNELS-1 downto 1) <= ch_completed (C_MAX_CHANNELS-2 downto 0);
end if;
end if;
end process;

high_pr_channel <= qualified and ch_completed;

go_back <= '0' when (high_pr_channel = x"0000") else '1';

SINGLE_CHANNEL : if C_NUM_CHANNELS = 1 generate
begin

process (m_axi_sg_aclk)
begin
    if (m_axi_sg_aclk 'event and m_axi_sg_aclk = '1') then
      if (m_axi_sg_aresetn = '0') then
          ch_id_to_sg <= (others => '0');
      else
          ch_id_to_sg <= "0000000000000001" and channels_captured;
      end if;
    end if;
end process;
ch_under_service <= "0000000000000001" and channels_captured;
            tdest <= "0000";

end generate SINGLE_CHANNEL;


process (m_axi_sg_aclk)
begin
if (m_axi_sg_aclk 'event and m_axi_sg_aclk = '1') then
if (m_axi_sg_aresetn = '0') then
   tdest_capture <= "0000";
   tdest_capture_del <= "0000";
else
   tdest_capture <= tdest;
   tdest_capture_del <= tdest_capture;
end if;
end if;
end process;


MORE_CHANNEL : if C_NUM_CHANNELS > 1 generate
begin

process (m_axi_sg_aclk)
begin
    if (m_axi_sg_aclk 'event and m_axi_sg_aclk = '1') then
      if (m_axi_sg_aresetn = '0') then
          ch_id_to_sg <= (others => '0');
      else
          ch_id_to_sg <= ch_under_service;
      end if;
    end if;
end process;


ch_under_service <= qualified and shift_reg;


process (ch_under_service)
begin
    case ch_under_service(15 downto 0) is
       when "0000000000000001" =>
            tdest <= "0000";
       when "0000000000000010" =>
            tdest <= "0001";
       when "0000000000000100" =>
            tdest <= "0010";
       when "0000000000001000" =>
            tdest <= "0011";
       when "0000000000010000" =>
            tdest <= "0100";
       when "0000000000100000" =>
            tdest <= "0101";
       when "0000000001000000" =>
            tdest <= "0110";
       when "0000000010000000" =>
            tdest <= "0111";
       when "0000000100000000" =>
            tdest <= "1000";
       when "0000001000000000" =>
            tdest <= "1001";
       when "0000010000000000" =>
            tdest <= "1010";
       when "0000100000000000" =>
            tdest <= "1011";
       when "0001000000000000" =>
            tdest <= "1100";
       when "0010000000000000" =>
            tdest <= "1101";
       when "0100000000000000" =>
            tdest <= "1110";
       when "1000000000000000" =>
            tdest <= "1111";
          -- coverage off
       when others => 
            tdest <= "0000";
          -- coverage on
     end case;
end process;

end generate MORE_CHANNEL;


tdest_to_fifo <= tdest_capture_del;
tdest_wr_en <= channel_sof and mm2s_new_curdesc_wren;

tuser_to_fifo <= tuser_tid_from_sg (15 downto 0) when (channel_eof = '1' and mm2s_new_curdesc_wren = '1') else (others => '0'); 
tuser_wr_en <= channel_eof and mm2s_new_curdesc_wren;

tid_to_fifo <= tuser_tid_from_sg (23 downto 16) when (channel_sof = '1' and mm2s_new_curdesc_wren = '1') else (others => '0'); 
tid_wr_en <= channel_sof and mm2s_new_curdesc_wren;

end implementation;




-------------------------------------------------------------------------------
-- axi_mcdma_mm2s_wrr
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_mcdma_mm2s_wrr.vhd
-- Description: This entity is the top level entity for the AXI DMA MM2S
--              manager.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_mcdma_mm2s_wrr is
    generic(

        C_PRMRY_IS_ACLK_ASYNC       : integer range 0 to 1         := 0;
            -- Primary MM2S/S2MM sync/async mode
            -- 0 = synchronous mode     - all clocks are synchronous
            -- 1 = asynchronous mode    - Primary data path channels (MM2S and S2MM)
            --                            run asynchronous to AXI Lite, DMA Control,
            --                            and SG.

        C_NUM_CHANNELS              : integer range 1 to 16 := 1;
        C_MM2S_SEQUENCE             : integer range 0 to 3 := 1;
        C_MAX_CHANNELS              : integer range 1 to 16 := 16;

        C_FAMILY                        : string            := "kintex7"
            -- Target FPGA Device Family
    );
    port (
        -- Secondary Clock and Reset
        m_axi_sg_aclk               : in  std_logic                         ;                 --
        m_axi_sg_aresetn            : in  std_logic                         ;                 --
                                                                                              --
        -- Primary Clock and Reset                                                            --
        axi_prmry_aclk              : in  std_logic                         ;                 --
        p_reset_n                   : in  std_logic                         ;                 --

        start_trigger               : in std_logic                          ; -- when the mm2s is started
        channel_enable              : in std_logic_vector (C_MAX_CHANNELS-1 downto 0); -- channels enabled 

        channel_weight              : in std_logic_vector (31 downto 0); -- weight for channel 1-8
        channel_weight_2            : in std_logic_vector (31 downto 0); -- weight for channel 9-16

        mm2s_new_curdesc_wren       : in std_logic;
        channel_eof                 : in std_logic;                      -- eof as detected from bds read (from sg_if)
        channel_sof                 : in std_logic;                      -- sof as detected from bds read (from sg_if)
        tuser_tid_from_sg           : in std_logic_vector (23 downto 0);

        channel_idle                : in std_logic_vector (C_MAX_CHANNELS-1 downto 0); -- idle status of channels
        mm2s_schedule               : in std_logic_vector (3 downto 0);  -- mm2s scheduler from register
        ch_id_to_sg                 : out std_logic_vector (C_MAX_CHANNELS-1 downto 0);

        tdest_to_fifo               : out std_logic_vector (3 downto 0);
        tdest_wr_en                 : out std_logic;
        tuser_wr_en                 : out std_logic;
        tid_wr_en                   : out std_logic;
        tuser_to_fifo               : out std_logic_vector (15 downto 0);
        tid_to_fifo                 : out std_logic_vector (7 downto 0)
        
    );

end axi_mcdma_mm2s_wrr;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_mm2s_wrr is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";


type MM2S_WRR_STATE_TYPE      is (
                                IDLE, -- trigger to start the FSM
                                CHECK_CH,
                                GET_CH,
                                START_CH, -- count the number of EOFs and compare
                                START_CH_SOF,
                                START_CH_CHECK,
                                CHECK_NEXT, -- move to next channel
                                WAIT_NEXT
                                );

signal mm2s_cs                  : MM2S_WRR_STATE_TYPE;
signal mm2s_ns                  : MM2S_WRR_STATE_TYPE;


signal channels_captured : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal weight_capture : std_logic_vector (63 downto 0);
signal weight_mod : std_logic_vector (63 downto 0);
signal ch_wt : std_logic_vector (63 downto 0);
signal start : std_logic;
signal start_delayed : std_logic;

signal shift_reg : std_logic_vector (C_MAX_CHANNELS downto 0) := "00000000000000001";
signal ch_completed : std_logic_vector (C_MAX_CHANNELS-1 downto 0) := x"0000";
signal high_pr_channel : std_logic_vector (C_MAX_CHANNELS-1 downto 0) := x"0000";
signal go_back : std_logic;
signal back_to_ch0 : std_logic;
signal move_to_next : std_logic;
signal iteration_complete : std_logic;
signal qualified : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal qualified1 : std_logic_vector (C_MAX_CHANNELS-1 downto 0);

signal ch_under_service : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal tdest : std_logic_vector (3 downto 0);
signal tdest_capture : std_logic_vector (3 downto 0);
signal weight_ok : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal weight_ok_cap : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal process_ch : std_logic;
signal at_least_one : std_logic;
signal channel_number_c : integer range 0 to 17; 
signal channel_number : integer range 0 to 17; 
signal capture_ch : std_logic;
signal mm2s_schedule_reg : std_logic_vector (2 downto 0);
signal decrement : std_logic;
signal lose_weight: std_logic;
signal valid : std_logic;
signal eof_del, eof_del1 : std_logic;
signal eof_del2 : std_logic;
signal ch_idle_int : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal sof_eof_del : std_logic := '0';
-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

process (m_axi_sg_aclk)
begin
if (m_axi_sg_aclk 'event and m_axi_sg_aclk = '1') then
if (m_axi_sg_aresetn = '0') then
    mm2s_cs <= IDLE;
else
    mm2s_cs <= mm2s_ns;
end if;
end if;
end process;

MM2S_SCH_MACHINE : process(mm2s_cs,
                           at_least_one,
                           process_ch, 
                           channel_eof,
                           channel_sof,
                           mm2s_new_curdesc_wren,
                           weight_ok ,
                           mm2s_schedule_reg,
                           channel_idle,
                           channel_number,
                           qualified
                       )
    begin

        -- Default signal assignment
                  move_to_next <= '0';
                  capture_ch <= '0';
                  decrement <= '0';
                  lose_weight <= '0';
                  valid <= '0';
                  mm2s_ns <= mm2s_cs;

        case mm2s_cs is

            -------------------------------------------------------------------
            when IDLE =>
               if (at_least_one = '1') then
                   mm2s_ns <= CHECK_CH;
               else
                   mm2s_ns <= IDLE;
               end if;

            when CHECK_CH =>
               if (process_ch = '1') then
                  mm2s_ns <= GET_CH;
               else
                  move_to_next <= '1';
                  mm2s_ns <= CHECK_CH;
               end if;

            when GET_CH => -- get the channel_number and associated weight
                  mm2s_ns <= START_CH_SOF;
                  capture_ch <= '1';

            when START_CH_SOF =>
                  valid <= '1';
                  if (qualified (channel_number) = '1') then
                  if (channel_sof = '1' and mm2s_new_curdesc_wren = '1') then
                      if (channel_idle (channel_number) = '1') then
                         lose_weight <= '1'; -- lose the iteration as channel BD queue went empty
                      elsif ((weight_ok(channel_number) = '1' and C_MM2S_SEQUENCE = 2) or (weight_ok(channel_number) = '1' and C_MM2S_SEQUENCE = 0 and mm2s_schedule_reg = "010")) then --WRR stay in same state until weight = 0
                         decrement <= '1';
                      elsif ((weight_ok(channel_number) = '1' and C_MM2S_SEQUENCE = 3) or (weight_ok(channel_number) = '1' and C_MM2S_SEQUENCE = 0 and mm2s_schedule_reg = "100"))then --WRR-FD move to next
                         decrement <= '1';
                      end if;
                  end if;

                  if (channel_sof = '1' and mm2s_new_curdesc_wren = '1') then
                     if (channel_eof = '1') then
                       mm2s_ns <= START_CH_CHECK;
                     else
                       mm2s_ns <= START_CH;
                     end if;
                  else
                       mm2s_ns <= START_CH_SOF;
                  end if;
                  else 
                       mm2s_ns <= IDLE;

                  end if;   
            when START_CH_CHECK =>
                  valid <= '0';
                      if (channel_idle (channel_number) = '1') then
                         lose_weight <= '1'; -- lose the iteration as channel BD queue went empty
                         mm2s_ns <= CHECK_NEXT;
                      elsif ((weight_ok(channel_number) = '1' and C_MM2S_SEQUENCE = 2) or (weight_ok(channel_number) = '1' and C_MM2S_SEQUENCE = 0 and mm2s_schedule_reg = "010")) then --WRR stay in same state until weight = 0
                         mm2s_ns <= START_CH_SOF;
                  capture_ch <= '1';
                      elsif ((weight_ok(channel_number) = '1' and C_MM2S_SEQUENCE = 3) or (weight_ok(channel_number) = '1' and C_MM2S_SEQUENCE = 0 and mm2s_schedule_reg = "100"))then --WRR-FD move to next
                         mm2s_ns <= CHECK_NEXT;
                      else
                         mm2s_ns <= CHECK_NEXT;
                      end if;

            when START_CH =>
                  valid <= '1';
                  if (channel_eof = '1' and mm2s_new_curdesc_wren = '1') then
                      if (channel_idle (channel_number) = '1') then
                         lose_weight <= '1'; -- lose the iteration as channel BD queue went empty
                         mm2s_ns <= CHECK_NEXT;
                      elsif ((weight_ok(channel_number) = '1' and C_MM2S_SEQUENCE = 2) or (weight_ok(channel_number) = '1' and C_MM2S_SEQUENCE = 0 and mm2s_schedule_reg = "010")) then --WRR stay in same state until weight = 0
                         mm2s_ns <= START_CH_SOF;
                  capture_ch <= '1';
                      elsif ((weight_ok(channel_number) = '1' and C_MM2S_SEQUENCE = 3) or (weight_ok(channel_number) = '1' and C_MM2S_SEQUENCE = 0 and mm2s_schedule_reg = "100"))then --WRR-FD move to next
                         mm2s_ns <= CHECK_NEXT;
                      else
                         mm2s_ns <= CHECK_NEXT;
                      end if;
                  else
                         mm2s_ns <= START_CH;
                  end if;

            when CHECK_NEXT =>
                  valid <= '0';
                  move_to_next <= at_least_one;
                  mm2s_ns <= IDLE;

            when WAIT_NEXT =>

            when others =>

        end case;
end process;


process (m_axi_sg_aclk)
begin
if (m_axi_sg_aclk 'event and m_axi_sg_aclk = '1') then
if (m_axi_sg_aresetn = '0') then
    ch_idle_int <= (others => '1');
elsif (iteration_complete = '1') then
    ch_idle_int <= channel_idle; --capture channels to service
end if;
end if;
end process;

process (m_axi_sg_aclk)
begin
if (m_axi_sg_aclk 'event and m_axi_sg_aclk = '1') then
if (m_axi_sg_aresetn = '0') then
    start_delayed <= '0';
    eof_del <= '0';
    sof_eof_del <= '0';
    eof_del1 <= '0';
    eof_del2 <= '0';
else
    start_delayed <= start_trigger;
    eof_del <= channel_eof and mm2s_new_curdesc_wren;
    sof_eof_del <= channel_eof and mm2s_new_curdesc_wren and channel_sof;
    eof_del1 <= eof_del;
    eof_del2 <= eof_del1;
end if;
end if;
end process;

start <= start_trigger and (not start_delayed);

-- the LSB of the following register has the highest priority

process (m_axi_sg_aclk)
begin
if (m_axi_sg_aclk 'event and m_axi_sg_aclk = '1') then
if (m_axi_sg_aresetn = '0') then
     channels_captured <= (others => '0');
     weight_ok_cap <= (others => '0'); 
elsif (start = '1' or iteration_complete = '1' or (channel_eof = '1' and mm2s_new_curdesc_wren = '1' and channel_sof = '0') or (sof_eof_del = '1')) then
     channels_captured <= channel_enable;
     weight_ok_cap <= weight_ok;
end if;
end if;
end process;


process (m_axi_sg_aclk)
begin
if (m_axi_sg_aclk 'event and m_axi_sg_aclk = '1') then
if (m_axi_sg_aresetn = '0') then
     mm2s_schedule_reg <= (others => '0');
elsif ((start = '1' or iteration_complete = '1') and C_MM2S_SEQUENCE = 0) then
     mm2s_schedule_reg <= mm2s_schedule (2 downto 0);
elsif (C_MM2S_SEQUENCE = 3 or C_MM2S_SEQUENCE = 2) then
     mm2s_schedule_reg <= (others => '0');
end if;
end if;
end process;

ch_wt <= channel_weight_2 & channel_weight;




WEIGHT_OK_GEN: for I in 0 to C_NUM_CHANNELS-1 generate
begin

process (m_axi_sg_aclk)
begin
if (m_axi_sg_aclk 'event and m_axi_sg_aclk = '1') then
if (m_axi_sg_aresetn = '0') then
     weight_capture(3+I*4 downto I*4) <= (others => '0');
elsif (start = '1' or iteration_complete = '1') then
     weight_capture(3+I*4 downto I*4) <= ch_wt(3+I*4 downto I*4); 
elsif (decrement = '1' and channel_number = I) then -- WRR fair distribution
     weight_capture(3+I*4 downto I*4) <= std_logic_vector(unsigned(weight_capture(3+I*4 downto I*4)) - 1);
elsif (lose_weight = '1' and channel_number = I) then -- WRR fair distribution
     weight_capture(3+I*4 downto I*4) <= (others => '0');
end if;
end if;
end process;

--weight_ok(I) <= '0' when ((weight_capture(3+I*4 downto I*4) = "0000") or ((ch_idle_int(I) = '0') and (channel_idle(I) = '1'))) else '1';
weight_ok(I) <= '1' when (((weight_capture(3+I*4 downto I*4) /= "0000")  and ch_idle_int(I) = '0' and channel_idle (I) = '0')) else '0'; -- or ((ch_idle_int(I) = '0') and (channel_idle(I) = '1'))) else '0';

end generate WEIGHT_OK_GEN;

UNUSED: if C_MAX_CHANNELS > C_NUM_CHANNELS generate
begin

     shift_reg (C_MAX_CHANNELS downto C_NUM_CHANNELS+1) <= (others => '0');

WEIGHT_OK_GEN1: for I in C_NUM_CHANNELS to C_MAX_CHANNELS-1 generate
begin

     weight_ok(I) <= '0';

end generate WEIGHT_OK_GEN1;
end generate UNUSED;

process (m_axi_sg_aclk)
begin
if (m_axi_sg_aclk 'event and m_axi_sg_aclk = '1') then
if (m_axi_sg_aresetn = '0') then
    shift_reg (0) <= '1';
    shift_reg (C_NUM_CHANNELS downto 1) <= (others => '0');
elsif (iteration_complete = '1') then
    shift_reg (0) <= '1';
    shift_reg (C_NUM_CHANNELS downto 1) <= (others => '0');
elsif (move_to_next = '1') then
    shift_reg (0) <= shift_reg (C_NUM_CHANNELS); --'0';
    shift_reg (C_NUM_CHANNELS downto 1) <= shift_reg (C_NUM_CHANNELS-1 downto 0);
end if;
end if;
end process; 

-- following signal will give me the channels that are qualified to run through
-- channels_captured will not change for iteration
-- channels_idle is dynamic, can change based on CD/TD programming
    
process (m_axi_sg_aclk)
begin
if (m_axi_sg_aclk 'event and m_axi_sg_aclk = '1') then
if (m_axi_sg_aresetn = '0') then
   qualified <= (others => '0');
else --if (start = '1' or (channel_eof = '1' and mm2s_new_curdesc_wren = '1')) then
   qualified <= channels_captured and weight_ok_cap;
  -- qualified <= channel_enable and weight_ok;
end if;
end if;
end process;

at_least_one <= '0' when (qualified = x"0000") else '1';
--iteration_complete <= '1' when (qualified = x"0000") else '0';
process (m_axi_sg_aclk)
begin
if (m_axi_sg_aclk 'event and m_axi_sg_aclk = '1') then
if (m_axi_sg_aresetn = '0') then
   iteration_complete <= '1';
elsif (qualified = x"0000" and eof_del2 = '1') then -- and channel_eof = '1' and mm2s_new_curdesc_wren = '1' ) then
   iteration_complete <= '1';
elsif (qualified /= x"0000") then 
   iteration_complete <= '0';
end if;
end if;
end process;

-- following is the one-hot signal which tell which channel is being serviced

ch_under_service <= qualified and shift_reg(C_MAX_CHANNELS-1 downto 0);
process_ch <= '0' when (ch_under_service = x"0000") else '1';


process (m_axi_sg_aclk)
begin
if (m_axi_sg_aclk 'event and m_axi_sg_aclk = '1') then
if (m_axi_sg_aresetn = '0') then
   channel_number <= 0;
elsif (process_ch = '0') then
   channel_number <= 0;
elsif (process_ch = '1') then
   channel_number <= channel_number_c;
end if;
end if;
end process;


process (m_axi_sg_aclk)
begin
if (m_axi_sg_aclk 'event and m_axi_sg_aclk = '1') then
if (m_axi_sg_aresetn = '0') then
   ch_id_to_sg <= (others => '0');
            tdest_capture <= "0000";
--elsif (process_ch = '0' or (channel_eof = '1' and mm2s_new_curdesc_wren = '1')) then
elsif (capture_ch = '1') then
--elsif (process_ch = '1') then
   ch_id_to_sg <= ch_under_service;
            tdest_capture <= tdest;
elsif (channel_eof = '1' and mm2s_new_curdesc_wren = '1') then
   ch_id_to_sg <= (others => '0');
end if;
end if;
end process;

process (ch_under_service)
begin
            tdest <= "0000";
            channel_number_c <= 0; 

    case ch_under_service (15 downto 0) is
       when "0000000000000001" =>
            tdest <= "0000";
            channel_number_c <= 0; 
       when "0000000000000010" =>
            tdest <= "0001";
            channel_number_c <= 1; 
       when "0000000000000100" =>
            tdest <= "0010";
            channel_number_c <= 2; 
       when "0000000000001000" =>
            tdest <= "0011";
            channel_number_c <= 3; 
       when "0000000000010000" =>
            tdest <= "0100";
            channel_number_c <= 4; 
       when "0000000000100000" =>
            tdest <= "0101";
            channel_number_c <= 5; 
       when "0000000001000000" =>
            tdest <= "0110";
            channel_number_c <= 6; 
       when "0000000010000000" =>
            tdest <= "0111";
            channel_number_c <= 7; 
       when "0000000100000000" =>
            tdest <= "1000";
            channel_number_c <= 8; 
       when "0000001000000000" =>
            tdest <= "1001";
            channel_number_c <= 9; 
       when "0000010000000000" =>
            tdest <= "1010";
            channel_number_c <= 10; 
       when "0000100000000000" =>
            tdest <= "1011";
            channel_number_c <= 11; 
       when "0001000000000000" =>
            tdest <= "1100";
            channel_number_c <= 12; 
       when "0010000000000000" =>
            tdest <= "1101";
            channel_number_c <= 13; 
       when "0100000000000000" =>
            tdest <= "1110";
            channel_number_c <= 14; 
       when "1000000000000000" =>
            tdest <= "1111";
            channel_number_c <= 15; 
          -- coverage off
       when others => 
            tdest <= "0000";
            channel_number_c <= 0; 
          -- coverage on
     end case;
end process;

tdest_to_fifo <= tdest_capture;
tdest_wr_en <= channel_sof and mm2s_new_curdesc_wren;

tid_wr_en <= channel_sof and mm2s_new_curdesc_wren;
tid_to_fifo <= tuser_tid_from_sg (23 downto 16) when (channel_sof = '1' and mm2s_new_curdesc_wren = '1') else (others => '0'); 

tuser_to_fifo <= tuser_tid_from_sg (15 downto 0) when (channel_eof = '1' and mm2s_new_curdesc_wren = '1') else (others => '0'); 
tuser_wr_en <= channel_eof and mm2s_new_curdesc_wren;
-- need to keep TID same throughout the packet transfer

end implementation;


-------------------------------------------------------------------------------
-- axi_mcdma_mm2s_sg_if
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_mcdma_mm2s_sg_if.vhd
-- Description: This entity is the MM2S Scatter Gather Interface for Descriptor
--              Fetches and Updates.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;


library lib_srl_fifo_v1_0_2;
use lib_srl_fifo_v1_0_2.srl_fifo_f;

library lib_cdc_v1_0_2;

-------------------------------------------------------------------------------
entity  axi_mcdma_mm2s_sg_if is
    generic (
        C_PRMRY_IS_ACLK_ASYNC        : integer range 0 to 1          := 0       ;
            -- Primary MM2S/S2MM sync/async mode
            -- 0 = synchronous mode     - all clocks are synchronous
            -- 1 = asynchronous mode    - Any one of the 4 clock inputs is not
            --                            synchronous to the other

        -----------------------------------------------------------------------
        -- Scatter Gather Parameters
        -----------------------------------------------------------------------
        C_SG_INCLUDE_STSCNTRL_STRM      : integer range 0 to 1          := 1    ;
            -- Include or Exclude AXI Status and AXI Control Streams
            -- 0 = Exclude Status and Control Streams
            -- 1 = Include Status and Control Streams

        C_SG_INCLUDE_DESC_QUEUE         : integer range 0 to 1          := 0    ;
            -- Include or Exclude Scatter Gather Descriptor Queuing
            -- 0 = Exclude SG Descriptor Queuing
            -- 1 = Include SG Descriptor Queuing

        C_M_AXIS_SG_TDATA_WIDTH          : integer range 32 to 32        := 32  ;
            -- AXI Master Stream in for descriptor fetch


        C_S_AXIS_UPDPTR_TDATA_WIDTH      : integer range 32 to 64        := 32   ;
            -- 32 Update Status Bits

        C_S_AXIS_UPDSTS_TDATA_WIDTH      : integer range 33 to 33        := 33   ;
            -- 1 IOC bit + 32 Update Status Bits

        C_M_AXI_SG_ADDR_WIDTH           : integer range 32 to 64        := 32   ;
            -- Master AXI Memory Map Data Width for Scatter Gather R/W Port

        C_M_AXI_MM2S_ADDR_WIDTH         : integer range 32 to 64        := 32   ;
            -- Master AXI Memory Map Address Width for MM2S Read Port

        C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH  : integer range 32 to 32        := 32  ;
            -- Master AXI Control Stream Data Width
        C_MAX_CHANNELS                  : integer range 1 to 16          := 16  ;

        C_FAMILY                        : string                        := "virtex5"
            -- Target FPGA Device Family

    );
    port (

        m_axi_sg_aclk               : in  std_logic                         ;           --
        m_axi_sg_aresetn            : in  std_logic                         ;           --
                                                                                        --
        -- SG MM2S Descriptor Fetch AXI Stream In                                       --
        m_axis_mm2s_ftch_tdata      : in  std_logic_vector                              --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0);           --
        m_axis_mm2s_ftch_tvalid     : in  std_logic                         ;           --
        m_axis_mm2s_ftch_tready     : out std_logic                         ;           --
        m_axis_mm2s_ftch_tlast      : in  std_logic                         ;           --
        m_axis_mm2s_ftch_data_valid : in std_logic;
        m_axis_mm2s_ftch_id         : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
                                                                                        --
                                                                                        --
        -- SG MM2S Descriptor Update AXI Stream Out                                     --
        s_axis_mm2s_updtptr_tdata   : out std_logic_vector                              --
                                     (C_S_AXIS_UPDPTR_TDATA_WIDTH-1 downto 0);          --
        s_axis_mm2s_updtptr_tvalid  : out std_logic                         ;           --
        s_axis_mm2s_updtptr_tready  : in  std_logic                         ;           --
        s_axis_mm2s_updtptr_tlast   : out std_logic                         ;           --
                                                                                        --
        s_axis_mm2s_updtsts_tdata   : out std_logic_vector                              --
                                     (C_S_AXIS_UPDSTS_TDATA_WIDTH-1 downto 0);          --
        s_axis_mm2s_updtsts_tvalid  : out std_logic                         ;           --
        s_axis_mm2s_updtsts_tready  : in  std_logic                         ;           --
        s_axis_mm2s_updtsts_tlast   : out std_logic                         ;           --
        s_axis_mm2s_updtsts_id      : out std_logic_vector (C_MAX_CHANNELS-1 downto 0); -----------------------
                                                                                --
                                                                                        --
                                                                                        --
                                                                                        --
                                                                                        --
        -- MM2S Descriptor Fetch Request (from mm2s_sm)                                 --
        desc_available              : out std_logic                         ;           --
        desc_fetch_req              : in  std_logic                         ;           --
        desc_fetch_done             : out std_logic                         ;           --
        packet_in_progress          : out std_logic                         ;           --
                                                                                        --
        -- MM2S Descriptor Update Request (from mm2s_sm)                                --
        desc_update_done            : out std_logic                         ;           --
                                                                                        --
        mm2s_sts_received_clr       : out std_logic                         ;           --
        mm2s_sts_received           : in  std_logic                         ;           --
        mm2s_ftch_stale_desc        : in  std_logic                         ;           --
        mm2s_done                   : in  std_logic                         ;           --
        mm2s_interr                 : in  std_logic                         ;           --
        mm2s_slverr                 : in  std_logic                         ;           --
        mm2s_decerr                 : in  std_logic                         ;           --
        mm2s_tag                    : in  std_logic_vector(3 downto 0)      ;           --
        mm2s_halt                   : in  std_logic                         ;           --
                                                                                        --
        -- Control Stream Output                                                        --
        cntrlstrm_fifo_wren         : out std_logic                         ;           --
        cntrlstrm_fifo_din          : out std_logic_vector                              --
                                        (C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH downto 0);     --
        cntrlstrm_fifo_full         : in  std_logic                         ;           --

        tuser_tid_data              : out std_logic_vector (23 downto 0);
        tuser_wr_en                 : out std_logic;
                                                                                        --
                                                                                        --
        -- MM2S Descriptor Field Output                                                 --
        mm2s_new_curdesc            : out std_logic_vector                              --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;           --
        mm2s_new_curdesc_wren       : out std_logic                         ;           --
        mm2s_channel_id_reg_update  : out std_logic_vector (C_MAX_CHANNELS-1 downto 0);
                                                                                        --
        mm2s_desc_baddress          : out std_logic_vector                              --
                                        (C_M_AXI_MM2S_ADDR_WIDTH-1 downto 0);           --
        mm2s_desc_blength           : out std_logic_vector                              --
                                        (BUFFER_LENGTH_WIDTH-1 downto 0)    ;           --
        mm2s_desc_eof               : out std_logic                         ;           --
        mm2s_desc_sof               : out std_logic                         ;           --
        mm2s_desc_cmplt             : out std_logic                         ;           --
        mm2s_desc_app0              : out std_logic_vector                              --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0) ;          --
        mm2s_desc_app1              : out std_logic_vector                              --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0) ;          --
        mm2s_desc_app2              : out std_logic_vector                              --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0) ;          --
        mm2s_desc_app3              : out std_logic_vector                              --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0) ;          --
        mm2s_desc_app4              : out std_logic_vector                              --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0)            --
    );

end axi_mcdma_mm2s_sg_if;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_mm2s_sg_if is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";


-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
-- Status reserved bits
constant RESERVED_STS           : std_logic_vector(1 downto 0) := (others => '0');

-- Used to determine when Control word is coming, in order to check SOF bit.
-- This then indicates that the app fields need to be directed towards the
-- control stream fifo.
-- Word Five Count
constant TWO_COUNT              : std_logic_vector(3 downto 0) := "0010";
constant THREE_COUNT            : std_logic_vector(3 downto 0) := "0011";
constant FOUR_COUNT             : std_logic_vector(3 downto 0) := "0100";
constant FIVE_COUNT             : std_logic_vector(3 downto 0) := "0101";
-- Word Six Count
constant SIX_COUNT              : std_logic_vector(3 downto 0) := "0110";
-- Word Seven Count
constant SEVEN_COUNT            : std_logic_vector(3 downto 0) := "0111";
constant DESC_EOF_BIT_MM2S : integer := 30;
constant DESC_SOF_BIT_MM2S : integer := 31;


-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal ftch_shftenbl            : std_logic := '0';
signal ftch_tready              : std_logic := '0';
signal desc_fetch_done_i        : std_logic := '0';

signal desc_reg12               : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg11               : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg10               : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg9                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg8                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg7                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg6                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg5                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg4                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg3                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg2                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg1                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg0                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');

signal mm2s_desc_curdesc_lsb    : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal mm2s_desc_curdesc_msb    : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal mm2s_desc_baddr_lsb      : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal mm2s_desc_baddr_msb      : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal mm2s_desc_tuser_tid      : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal mm2s_desc_blength_i      : std_logic_vector(BUFFER_LENGTH_WIDTH - 1 downto 0)    := (others => '0');

-- Fetch control signals for driving out control app stream
signal desc_word                : std_logic_vector(3 downto 0) := (others => '0');
signal analyze_control          : std_logic := '0';
signal redirect_app             : std_logic := '0';
signal redirect_app_d1          : std_logic := '0';
signal redirect_app_re          : std_logic := '0';
signal redirect_app_hold        : std_logic := '0';
signal mask_fifo_write          : std_logic := '0';

-- Current descriptor control and fetch throttle control
signal mm2s_new_curdesc_wren_i  : std_logic := '0';
signal mm2s_pending_update      : std_logic := '0';
signal mm2s_pending_ptr_updt    : std_logic := '0';

-- Descriptor Update Signals
signal mm2s_complete            : std_logic := '0';
signal mm2s_xferd_bytes         : std_logic_vector(BUFFER_LENGTH_WIDTH-1 downto 0)      := (others => '0');

-- Update Descriptor Pointer Holding Registers
signal updt_desc_reg0           : std_logic_vector(C_S_AXIS_UPDPTR_TDATA_WIDTH downto 0) := (others => '0');
signal updt_desc_reg1           : std_logic_vector(C_S_AXIS_UPDPTR_TDATA_WIDTH downto 0) := (others => '0');
-- Update Descriptor Status Holding Register
signal updt_desc_reg2           : std_logic_vector(C_S_AXIS_UPDSTS_TDATA_WIDTH downto 0) := (others => '0');

-- Pointer shift control
signal updt_shftenbl            : std_logic := '0';

-- Update pointer stream
signal updtptr_tvalid           : std_logic := '0';
signal updtptr_tlast            : std_logic := '0';
signal updtptr_tdata            : std_logic_vector(C_S_AXIS_UPDPTR_TDATA_WIDTH-1 downto 0) := (others => '0');

-- Update status stream
signal updtsts_tvalid           : std_logic := '0';
signal updtsts_tlast            : std_logic := '0';
signal updtsts_tdata            : std_logic_vector(C_S_AXIS_UPDSTS_TDATA_WIDTH-1 downto 0) := (others => '0');

-- Status control
signal sts_received             : std_logic := '0';
signal sts_received_d1          : std_logic := '0';
signal sts_received_re          : std_logic := '0';

-- Queued Update signals
signal updt_data_clr            : std_logic := '0';
signal updt_sts_clr             : std_logic := '0';
signal updt_data                : std_logic := '0';
signal updt_sts                 : std_logic := '0';

signal packet_start             : std_logic := '0';
signal packet_end               : std_logic := '0';

signal mm2s_halt_d1             : std_logic := '0';
signal mm2s_halt_d2             : std_logic := '0';

signal read_count : std_logic_vector (3 downto 0);
signal bmg_rd_en             : std_logic := '0';

signal mm2s_desc_eof_i : std_logic;
signal mm2s_desc_sof_i : std_logic;

signal channel_id : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal id_rst     : std_logic;
signal id_write   : std_logic;
signal id_read_data : std_logic_vector (C_MAX_CHANNELS-1 downto 0);

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

mm2s_desc_eof <= mm2s_desc_eof_i;
mm2s_desc_sof <= mm2s_desc_sof_i;

-- Drive buffer length out
mm2s_desc_blength <= mm2s_desc_blength_i;

channel_id      <= m_axis_mm2s_ftch_id;

mm2s_channel_id_reg_update <= channel_id;
-- Drive fetch request done on tlast
--desc_fetch_done_i   <= m_axis_mm2s_ftch_tlast
--                 and m_axis_mm2s_ftch_tvalid
--                 and ftch_tready;


desc_fetch_done_i   <= m_axis_mm2s_ftch_tlast
                 and ftch_shftenbl;

-- pass out of module
desc_fetch_done <= desc_fetch_done_i;


tuser_wr_en <= mm2s_new_curdesc_wren_i and mm2s_desc_eof_i;
tuser_tid_data <= mm2s_desc_tuser_tid (31 downto 24) & mm2s_desc_tuser_tid (15 downto 0); 

-- Shift in data from SG engine if tvalid and fetch request
--ftch_shftenbl     <= m_axis_mm2s_ftch_tvalid
--                        and ftch_tready
--                        and desc_fetch_req
--                        and not mm2s_pending_update;

ftch_shftenbl           <= m_axis_mm2s_ftch_data_valid
                            and not mm2s_pending_update;

-- Passed curdes write out to register module
mm2s_new_curdesc_wren   <= mm2s_new_curdesc_wren_i;

-- tvalid asserted means descriptor availble
desc_available          <= m_axis_mm2s_ftch_tvalid and (not mm2s_pending_update); -- just a trigger


D1ESC_WRD_PROCESS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0' or (m_axis_mm2s_ftch_tlast = '1' and ftch_shftenbl = '1'))then
               read_count <= "0000";
            elsif (desc_fetch_req = '1') then
               read_count <= std_logic_vector(unsigned(read_count(3 downto 0)) +1);
            end if;
         end if;
end process D1ESC_WRD_PROCESS; 


--***************************************************************************--
--** Register DataMover Halt to secondary if needed
--***************************************************************************--
GEN_FOR_ASYNC : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
begin
    -- Double register to secondary clock domain.  This is sufficient
    -- because halt will remain asserted until halt_cmplt detected in
    -- reset module in secondary clock domain.
--    REG_TO_SECONDARY : process(m_axi_sg_aclk)
--        begin
--            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--                if(m_axi_sg_aresetn = '0')then
--                    mm2s_halt_d1 <= '0';
--                    mm2s_halt_d2 <= '0';
--                else
--                    mm2s_halt_d1 <= mm2s_halt;
--                    mm2s_halt_d2 <= mm2s_halt_d1;
--                end if;
--            end if;
--        end process REG_TO_SECONDARY;

REG_TO_SECONDARY : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => mm2s_halt,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => mm2s_halt_d2,
        scndry_vect_out            => open
    );



end generate GEN_FOR_ASYNC;

GEN_FOR_SYNC : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
begin
    -- No clock crossing required therefore simple pass through
    mm2s_halt_d2 <= mm2s_halt;

end generate GEN_FOR_SYNC;




--***************************************************************************--
--**                        Descriptor Fetch Logic                         **--
--***************************************************************************--

packet_start <= '1' when mm2s_new_curdesc_wren_i ='1'
                     and mm2s_desc_sof_i = '1' --desc_reg6(DESC_SOF_BIT_MM2S) = '1'
           else '0';

packet_end <= '1' when mm2s_new_curdesc_wren_i ='1'
                   and mm2s_desc_eof_i = '1' --desc_reg6(DESC_EOF_BIT_MM2S) = '1'
           else '0';

REG_PACKET_PROGRESS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0' or packet_end = '1')then
                packet_in_progress <= '0';
            elsif(packet_start = '1')then
                packet_in_progress <= '1';
            end if;
        end if;
    end process REG_PACKET_PROGRESS;


-- Status/Control stream enabled therefore APP fields are included
GEN_FTCHIF_WITH_APP : if C_SG_INCLUDE_STSCNTRL_STRM = 1 generate
-- Control Stream Ethernet TAG
constant ETHERNET_CNTRL_TAG     : std_logic_vector
                                    (C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH - 1 downto 0)
                                    := X"A000_0000";
begin
    -------------------------------------------------------------------------------
    -- Large shift register to bring in descriptor fields
    -------------------------------------------------------------------------------
    DESC_WRD_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    desc_reg12    <= (others => '0');
                    desc_reg11    <= (others => '0');
                    desc_reg10    <= (others => '0');
                    desc_reg9     <= (others => '0');
                    desc_reg8     <= (others => '0');
                    desc_reg7     <= (others => '0');
                    desc_reg6     <= (others => '0');
                    desc_reg5     <= (others => '0');
                    desc_reg4     <= (others => '0');
                    desc_reg3     <= (others => '0');
                    desc_reg2     <= (others => '0');
                    desc_reg1     <= (others => '0');
                    desc_reg0     <= (others => '0');
                -- Shift if enabled or if doing and overlay
                elsif(ftch_shftenbl = '1' and C_M_AXI_MM2S_ADDR_WIDTH = 64)then
                    desc_reg11    <= m_axis_mm2s_ftch_tdata;
                  --  desc_reg11    <= desc_reg12;
                    desc_reg10    <= desc_reg11;
                    desc_reg9     <= desc_reg10;
                    desc_reg8     <= desc_reg9;
                    desc_reg7     <= desc_reg8;
                    desc_reg6     <= desc_reg7;
                    desc_reg5     <= desc_reg6;
                    desc_reg4     <= desc_reg5;
                    desc_reg3     <= desc_reg4;
                    desc_reg2     <= desc_reg3;
                    desc_reg1     <= desc_reg2;
                    desc_reg0     <= desc_reg1;
                elsif(ftch_shftenbl = '1' and C_M_AXI_MM2S_ADDR_WIDTH = 32)then
                    desc_reg10    <= m_axis_mm2s_ftch_tdata;
                  --  desc_reg11    <= desc_reg12;
                  --  desc_reg10    <= desc_reg11;
                    desc_reg9     <= desc_reg10;
                    desc_reg8     <= desc_reg9;
                    desc_reg7     <= desc_reg8;
                    desc_reg6     <= desc_reg7;
                    desc_reg5     <= desc_reg6;
                    desc_reg4     <= desc_reg5;
                    desc_reg3     <= desc_reg4;
                    desc_reg2     <= desc_reg3;
                    desc_reg1     <= desc_reg2;
                    desc_reg0     <= desc_reg1;
                end if;
            end if;
        end process DESC_WRD_PROCESS;


    mm2s_desc_curdesc_lsb   <= desc_reg0;
    mm2s_desc_curdesc_msb   <= desc_reg1;
    mm2s_desc_baddr_lsb     <= desc_reg2;


GEN_NEW_64BIT_BUFADDR : if C_M_AXI_MM2S_ADDR_WIDTH = 64 generate
begin

    mm2s_desc_baddr_msb     <= desc_reg3;
    mm2s_desc_tuser_tid     <= desc_reg5;
    -- desc 4 and desc 5 are reserved and thus don't care
    mm2s_desc_blength_i     <= desc_reg4(DESC_BLENGTH_MSB_BIT downto DESC_BLENGTH_LSB_BIT);
    mm2s_desc_eof_i           <= desc_reg4(DESC_EOF_BIT_MM2S);
    mm2s_desc_sof_i           <= desc_reg4(DESC_SOF_BIT_MM2S);
    mm2s_desc_cmplt         <= desc_reg6(DESC_STS_CMPLTD_BIT);
    mm2s_desc_app0          <= desc_reg7;
    mm2s_desc_app1          <= desc_reg8;
    mm2s_desc_app2          <= desc_reg9;
    mm2s_desc_app3          <= desc_reg10;
    mm2s_desc_app4          <= desc_reg11;

end generate GEN_NEW_64BIT_BUFADDR;

GEN_NEW_32BIT_BUFADDR : if C_M_AXI_MM2S_ADDR_WIDTH = 32 generate
begin

    mm2s_desc_baddr_msb     <= (others => '0');
    mm2s_desc_tuser_tid     <= desc_reg4;
    -- desc 4 and desc 5 are reserved and thus don't care
    mm2s_desc_blength_i     <= desc_reg3(DESC_BLENGTH_MSB_BIT downto DESC_BLENGTH_LSB_BIT);
    mm2s_desc_eof_i           <= desc_reg3(DESC_EOF_BIT_MM2S);
    mm2s_desc_sof_i           <= desc_reg3(DESC_SOF_BIT_MM2S);
    mm2s_desc_cmplt         <= desc_reg5(DESC_STS_CMPLTD_BIT);
    mm2s_desc_app0          <= desc_reg6;
    mm2s_desc_app1          <= desc_reg7;
    mm2s_desc_app2          <= desc_reg8;
    mm2s_desc_app3          <= desc_reg9;
    mm2s_desc_app4          <= desc_reg10;

end generate GEN_NEW_32BIT_BUFADDR;


    -- Drive ready if descriptor fetch request is being made
    -- If not redirecting app fields then drive ready based on sm request
    -- If redirecting app fields then drive ready based on room in cntrl strm fifo
--    ftch_tready     <=   '1' when(redirect_app = '0'                -- Not re-directing app fields
--                                and desc_fetch_req = '1'            -- Descriptor fetch requested
--                                and mm2s_pending_update = '0')      -- No pending pointer updates
--
--                             or (redirect_app = '1'                 -- Re-Directing app fields
--                                and cntrlstrm_fifo_full = '0')      -- control fifo not full
--                                else '0';

 --   m_axis_mm2s_ftch_tready <= ftch_tready;


    ftch_tready     <= desc_fetch_req               -- desc fetch request
                   and not mm2s_pending_update; -- no pntr updates pending


  --  m_axis_mm2s_ftch_tready <= ftch_tready;
    m_axis_mm2s_ftch_tready     <= bmg_rd_en --desc_fetch_req                   -- Request descriptor fetch
                                and not mm2s_pending_update;    -- No pending pointer updates

    ---------------------------------------------------------------------------
    -- Word Counter for determining which descriptor word is the control word
    ---------------------------------------------------------------------------
    WRD_COUNTER : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' or desc_fetch_done_i = '1')then
                    desc_word <= (others => '0');
                elsif(ftch_shftenbl = '1')then
                    desc_word <= std_logic_vector(unsigned(desc_word) + 1);
                end if;
             end if;
         end process WRD_COUNTER;

    ---------------------------------------------------------------------------
    -- On correct word count sample stream in to capture control word.  Used
    -- to see if SOF = 1 in order to steer app fields to control stream out.
    ---------------------------------------------------------------------------
    ANLYZ_CNTRL : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    analyze_control <= '0';
                elsif(m_axis_mm2s_ftch_data_valid = '1') then --m_axis_mm2s_ftch_tvalid = '1')then
                    case desc_word is
                        when TWO_COUNT =>
                            if (C_M_AXI_MM2S_ADDR_WIDTH = 32) then 
                               analyze_control <= '1';
                            else
                               analyze_control <= '0';
                            end if;
                        when THREE_COUNT =>
                            if (C_M_AXI_MM2S_ADDR_WIDTH = 64) then 
                               analyze_control <= '1';
                            else
                               analyze_control <= '0';
                            end if;
                        when FOUR_COUNT =>
                            analyze_control <= '0';
          -- coverage off
                        when others =>
                            analyze_control <= '0';
          -- coverage on
                    end case;
                end if;
            end if;
        end process ANLYZ_CNTRL;

    ---------------------------------------------------------------------------
    -- Flag for directing app fields to control fifo on SOF descriptor
    ---------------------------------------------------------------------------
    REDIRECT_APP_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                -- Reset or descriptor was stale (i.e. cmplt bit already set)
                -- therefore do not re-direct app fields
                if(m_axi_sg_aresetn = '0' or mm2s_ftch_stale_desc = '1')then
                    redirect_app <= '0';
                -- Reset flag on fetch complete
                elsif(desc_fetch_done_i = '1')then
                    redirect_app <= '0';
                -- If SOF then redirect to control fifo
                elsif(analyze_control = '1' and m_axis_mm2s_ftch_tdata(DESC_SOF_BIT_MM2S) = '1'
                and m_axis_mm2s_ftch_data_valid = '1')then
                    redirect_app <= '1';
                 end if;
            end if;
        end process REDIRECT_APP_PROCESS;


    -- Mux between writing the Ethernet TAG and writing the descriptor APP fields
    CNTRL_STRM_MUX : process(redirect_app,
                             mm2s_ftch_stale_desc,
                             desc_word,
                             cntrlstrm_fifo_full,
                             m_axis_mm2s_ftch_tlast,
                             m_axis_mm2s_ftch_tdata,
                             m_axis_mm2s_ftch_data_valid
                             )
        begin
            -- Write TAG during descriptor status coming in if not
            -- stale descriptor
            if(redirect_app = '1' and desc_word = FIVE_COUNT and C_M_AXI_MM2S_ADDR_WIDTH = 32
            and m_axis_mm2s_ftch_data_valid = '1'
            and m_axis_mm2s_ftch_tdata(DESC_STS_CMPLTD_BIT) = '0')then

                cntrlstrm_fifo_din  <= '0' & ETHERNET_CNTRL_TAG;
                cntrlstrm_fifo_wren <= not cntrlstrm_fifo_full;

            elsif(redirect_app = '1' and desc_word = SIX_COUNT and C_M_AXI_MM2S_ADDR_WIDTH = 64
            and m_axis_mm2s_ftch_data_valid = '1'
            and m_axis_mm2s_ftch_tdata(DESC_STS_CMPLTD_BIT) = '0')then

                cntrlstrm_fifo_din  <= '0' & ETHERNET_CNTRL_TAG;
                cntrlstrm_fifo_wren <= not cntrlstrm_fifo_full;

            -- If not on status word (word seven) and not
            -- a stale descriptor and command to redirect app fields
            -- then direct app words to control stream fifo
            elsif(redirect_app='1' and desc_word > FIVE_COUNT and C_M_AXI_MM2S_ADDR_WIDTH = 32
            and m_axis_mm2s_ftch_data_valid = '1'
            and mm2s_ftch_stale_desc = '0')then
                cntrlstrm_fifo_din  <= m_axis_mm2s_ftch_tlast & m_axis_mm2s_ftch_tdata;
                cntrlstrm_fifo_wren <= not cntrlstrm_fifo_full;

            elsif(redirect_app='1' and desc_word > SIX_COUNT and C_M_AXI_MM2S_ADDR_WIDTH = 64
            and m_axis_mm2s_ftch_data_valid = '1'
            and mm2s_ftch_stale_desc = '0')then
                cntrlstrm_fifo_din  <= m_axis_mm2s_ftch_tlast & m_axis_mm2s_ftch_tdata;
                cntrlstrm_fifo_wren <= not cntrlstrm_fifo_full;
            else
                cntrlstrm_fifo_din  <= (others => '0');
                cntrlstrm_fifo_wren <= '0';
            end if;
        end process CNTRL_STRM_MUX;


end generate GEN_FTCHIF_WITH_APP;


-- Status/Control stream diabled therefore APP fields are NOT included
GEN_FTCHIF_WITHOUT_APP : if C_SG_INCLUDE_STSCNTRL_STRM = 0 generate
    -------------------------------------------------------------------------------
    -- Large shift register to bring in descriptor fields
    -------------------------------------------------------------------------------
    DESC_WRD_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
               --     desc_reg7     <= (others => '0');
               --     desc_reg6     <= (others => '0');
                    desc_reg5     <= (others => '0');
                    desc_reg4     <= (others => '0');
                    desc_reg3     <= (others => '0');
                    desc_reg2     <= (others => '0');
                    desc_reg1     <= (others => '0');
                    desc_reg0     <= (others => '0');
                -- Shift if enabled or if doing and overlay
                elsif(ftch_shftenbl = '1' and C_M_AXI_MM2S_ADDR_WIDTH = 64)then
                    desc_reg6       <= m_axis_mm2s_ftch_tdata;
                 --   desc_reg6       <= desc_reg7;
                    desc_reg5       <= desc_reg6;
                    desc_reg4       <= desc_reg5;
                    desc_reg3       <= desc_reg4;
                    desc_reg2       <= desc_reg3;
                    desc_reg1       <= desc_reg2;
                    desc_reg0       <= desc_reg1;
                elsif(ftch_shftenbl = '1' and C_M_AXI_MM2S_ADDR_WIDTH = 32)then
                 --   desc_reg7       <= m_axis_mm2s_ftch_tdata;
                 --   desc_reg6       <= desc_reg7;
                    desc_reg5       <= m_axis_mm2s_ftch_tdata;--desc_reg6;
                    desc_reg4       <= desc_reg5;
                    desc_reg3       <= desc_reg4;
                    desc_reg2       <= desc_reg3;
                    desc_reg1       <= desc_reg2;
                    desc_reg0       <= desc_reg1;
                end if;
            end if;
        end process DESC_WRD_PROCESS;

    mm2s_desc_curdesc_lsb   <= desc_reg0;
    mm2s_desc_curdesc_msb   <= desc_reg1;
    mm2s_desc_baddr_lsb     <= desc_reg2;

GEN_NEW_64BIT_BUFADDR : if C_M_AXI_MM2S_ADDR_WIDTH = 64 generate
begin

    mm2s_desc_baddr_msb     <= desc_reg3;
    mm2s_desc_tuser_tid     <= desc_reg5;
    mm2s_desc_blength_i     <= desc_reg4(DESC_BLENGTH_MSB_BIT downto DESC_BLENGTH_LSB_BIT);
    mm2s_desc_eof_i           <= desc_reg4(DESC_EOF_BIT_MM2S);
    mm2s_desc_sof_i           <= desc_reg4(DESC_SOF_BIT_MM2S);
    mm2s_desc_cmplt         <= desc_reg6(DESC_STS_CMPLTD_BIT);
    mm2s_desc_app0          <= (others => '0');
    mm2s_desc_app1          <= (others => '0');
    mm2s_desc_app2          <= (others => '0');
    mm2s_desc_app3          <= (others => '0');
    mm2s_desc_app4          <= (others => '0');

--desc5 will have sideband control
end generate GEN_NEW_64BIT_BUFADDR;

GEN_NEW_32BIT_BUFADDR : if C_M_AXI_MM2S_ADDR_WIDTH = 32 generate
begin

    mm2s_desc_baddr_msb     <= (others => '0');
    mm2s_desc_tuser_tid     <= desc_reg4;
    mm2s_desc_blength_i     <= desc_reg3(DESC_BLENGTH_MSB_BIT downto DESC_BLENGTH_LSB_BIT);
    mm2s_desc_eof_i           <= desc_reg3(DESC_EOF_BIT_MM2S);
    mm2s_desc_sof_i           <= desc_reg3(DESC_SOF_BIT_MM2S);
    mm2s_desc_cmplt         <= desc_reg5(DESC_STS_CMPLTD_BIT);
    mm2s_desc_app0          <= (others => '0');
    mm2s_desc_app1          <= (others => '0');
    mm2s_desc_app2          <= (others => '0');
    mm2s_desc_app3          <= (others => '0');
    mm2s_desc_app4          <= (others => '0');

--desc4 will have sideband control

end generate GEN_NEW_32BIT_BUFADDR;

    -- desc 4 and desc 5 are reserved and thus don't care


    -- Drive ready if descriptor fetch request is being made
    ftch_tready     <= desc_fetch_req               -- desc fetch request
                   and not mm2s_pending_update; -- no pntr updates pending


  --  m_axis_mm2s_ftch_tready <= ftch_tready;
    m_axis_mm2s_ftch_tready     <= bmg_rd_en --desc_fetch_req                   -- Request descriptor fetch
                                and not mm2s_pending_update;    -- No pending pointer updates

    cntrlstrm_fifo_wren     <= '0';
    cntrlstrm_fifo_din      <= (others => '0');


end generate GEN_FTCHIF_WITHOUT_APP;

-------------------------------------------------------------------------------
-- BUFFER ADDRESS
-------------------------------------------------------------------------------
-- If 64 bit addressing then concatinate msb to lsb
GEN_NEW_64BIT_BUFADDR : if C_M_AXI_MM2S_ADDR_WIDTH = 64 generate
    mm2s_desc_baddress <= mm2s_desc_baddr_msb & mm2s_desc_baddr_lsb;

GEN_FTCHIF_WITHOUT_APP : if C_SG_INCLUDE_STSCNTRL_STRM = 0 generate
bmg_rd_en <= '1' when (read_count <= "0110" and desc_fetch_req = '1') else '0';
end generate GEN_FTCHIF_WITHOUT_APP;

GEN_FTCHIF_WITH_APP : if C_SG_INCLUDE_STSCNTRL_STRM = 1 generate
bmg_rd_en <= '1' when (read_count <= "1011" and desc_fetch_req = '1') else '0';
end generate GEN_FTCHIF_WITH_APP;


end generate GEN_NEW_64BIT_BUFADDR;

-- If 32 bit addressing then simply pass lsb out
GEN_NEW_32BIT_BUFADDR : if C_M_AXI_MM2S_ADDR_WIDTH = 32 generate
    mm2s_desc_baddress <= mm2s_desc_baddr_lsb;

GEN_FTCHIF_WITHOUT_APP : if C_SG_INCLUDE_STSCNTRL_STRM = 0 generate
bmg_rd_en <= '1' when (read_count <= "0101" and desc_fetch_req = '1') else '0';
end generate GEN_FTCHIF_WITHOUT_APP;

GEN_FTCHIF_WITH_APP : if C_SG_INCLUDE_STSCNTRL_STRM = 1 generate
bmg_rd_en <= '1' when (read_count <= "1010" and desc_fetch_req = '1') else '0';
end generate GEN_FTCHIF_WITH_APP;


end generate GEN_NEW_32BIT_BUFADDR;

-------------------------------------------------------------------------------
-- NEW CURRENT DESCRIPTOR
-------------------------------------------------------------------------------
-- If 64 bit addressing then concatinate msb to lsb
GEN_NEW_64BIT_CURDESC : if C_M_AXI_SG_ADDR_WIDTH = 64 generate
    mm2s_new_curdesc <= mm2s_desc_curdesc_msb & mm2s_desc_curdesc_lsb;
end generate GEN_NEW_64BIT_CURDESC;

-- If 32 bit addressing then simply pass lsb out
GEN_NEW_32BIT_CURDESC : if C_M_AXI_SG_ADDR_WIDTH = 32 generate
    mm2s_new_curdesc <= mm2s_desc_curdesc_lsb;
end generate GEN_NEW_32BIT_CURDESC;

-- Write new current descriptor out on last
REG_CURDESC_WREN : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                mm2s_new_curdesc_wren_i <= '0';
            -- Write new curdesc on fetch done
            elsif(desc_fetch_done_i = '1')then
                mm2s_new_curdesc_wren_i <= '1';
            else
                mm2s_new_curdesc_wren_i <= '0';
            end if;
        end if;
    end process REG_CURDESC_WREN;

--***************************************************************************--
--**                       Descriptor Update Logic                         **--
--***************************************************************************--

--*****************************************************************************
--** Pointer Update Logic
--*****************************************************************************

    -----------------------------------------------------------------------
    -- Capture LSB cur descriptor on write for use on descriptor update.
    -- This will be the address the descriptor is updated to
    -----------------------------------------------------------------------
    UPDT_DESC_WRD0: process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    updt_desc_reg0 <= (others => '0');
                elsif(mm2s_new_curdesc_wren_i = '1' and C_M_AXI_MM2S_ADDR_WIDTH = 32)then
                    updt_desc_reg0 <= DESC_LAST
                                      & mm2s_desc_curdesc_lsb;
                elsif(mm2s_new_curdesc_wren_i = '1' and C_M_AXI_MM2S_ADDR_WIDTH = 64)then
                    updt_desc_reg0 <= DESC_LAST
                                      & mm2s_desc_curdesc_msb
                                      & mm2s_desc_curdesc_lsb;


                -- Shift data out on shift enable
--                elsif(updt_shftenbl = '1')then
--                    updt_desc_reg0 <= updt_desc_reg1;

                end if;
            end if;
        end process UPDT_DESC_WRD0;

    -----------------------------------------------------------------------
    -- Capture MSB cur descriptor on write for use on descriptor update.
    -- This will be the address the descriptor is updated to
    -----------------------------------------------------------------------
--    UPDT_DESC_WRD1: process(m_axi_sg_aclk)
--        begin
--            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--                if(m_axi_sg_aresetn = '0')then
--                    updt_desc_reg1 <= (others => '0');
--                elsif(mm2s_new_curdesc_wren_i = '1')then
--                    updt_desc_reg1 <= DESC_LAST
--                                      & mm2s_desc_curdesc_msb;
--
--                -- Shift data out on shift enable
--                elsif(updt_shftenbl = '1')then
--                    updt_desc_reg1 <= (others => '0');
--
--                end if;
--            end if;
--        end process UPDT_DESC_WRD1;


    -- Shift in data from SG engine if tvalid, tready, and not on last word
    updt_shftenbl <=  updt_data and updtptr_tvalid and s_axis_mm2s_updtptr_tready;


    -- Update data done when updating data and tlast received and target
    -- (i.e. SG Engine) is ready
    updt_data_clr <= '1' when updtptr_tvalid = '1' and updtptr_tlast = '1'
                          and s_axis_mm2s_updtptr_tready = '1'
                else '0';


    -- When desc data ready for update set and hold flag until
    -- data can be updated to queue.  Note it may
    -- be held off due to update of status
    UPDT_DATA_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    updt_data   <= '0';
                -- clear flag when data update complete
                elsif(updt_data_clr = '1')then
                    updt_data <= '0';
                -- set flag when desc fetched as indicated
                -- by curdesc wren
                elsif(mm2s_new_curdesc_wren_i = '1')then
                    updt_data <= '1';
                end if;
            end if;
        end process UPDT_DATA_PROCESS;

    updtptr_tvalid  <= updt_data;
    updtptr_tlast   <= updt_desc_reg0(C_S_AXIS_UPDPTR_TDATA_WIDTH);
    updtptr_tdata   <= updt_desc_reg0(C_S_AXIS_UPDPTR_TDATA_WIDTH-1 downto 0);


--*****************************************************************************
--** Status Update Logic
--*****************************************************************************

    mm2s_complete <= '1'; -- Fixed at '1'

    ---------------------------------------------------------------------------
    -- Descriptor queuing turned on in sg engine therefore need to instantiate
    -- fifo to hold fetch buffer lengths.  Also need to throttle fetches
    -- if pointer has not been updated yet or length fifo is full
    ---------------------------------------------------------------------------
    GEN_UPDT_FOR_QUEUE : if C_SG_INCLUDE_DESC_QUEUE = 1 generate
    signal xb_fifo_reset   : std_logic; -- xfer'ed bytes fifo reset
    signal xb_fifo_full    : std_logic; -- xfer'ed bytes fifo full
    begin
        -----------------------------------------------------------------------
        -- Need to flag a pending pointer update to prevent subsequent fetch of
        -- descriptor from stepping on the stored pointer, and buffer length
        -----------------------------------------------------------------------
        REG_PENDING_UPDT : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0' or updt_data_clr = '1')then
                        mm2s_pending_ptr_updt <= '0';
                    elsif(mm2s_new_curdesc_wren_i = '1')then
                        mm2s_pending_ptr_updt <= '1';
                    end if;
                end if;
            end process REG_PENDING_UPDT;

        -- Pointer pending update or xferred bytes fifo full
        mm2s_pending_update <= mm2s_pending_ptr_updt or xb_fifo_full;

        -----------------------------------------------------------------------
        -- On MM2S transferred bytes equals buffer length.  Capture length
        -- on curdesc write.
        -----------------------------------------------------------------------
        XFERRED_BYTE_FIFO : entity lib_srl_fifo_v1_0_2.srl_fifo_f
          generic map(
            C_DWIDTH        => BUFFER_LENGTH_WIDTH          ,
            C_DEPTH         => 16                           ,
            C_FAMILY        => C_FAMILY
            )
          port map(
            Clk             => m_axi_sg_aclk              ,
            Reset           => xb_fifo_reset                ,
            FIFO_Write      => mm2s_new_curdesc_wren_i      ,
            Data_In         => mm2s_desc_blength_i          ,
            FIFO_Read       => sts_received_re              ,
            Data_Out        => mm2s_xferd_bytes             ,
            FIFO_Empty      => open                         ,
            FIFO_Full       => xb_fifo_full                 ,
            Addr            => open
            );

        xb_fifo_reset      <= not m_axi_sg_aresetn;

        -- clear status received flag in cmdsts_if to
        -- allow more status to be received from datamover
        mm2s_sts_received_clr <= updt_sts_clr;

        -- Generate a rising edge off status received in order to
        -- flag status update
        REG_STATUS : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0')then
                        sts_received_d1 <= '0';
                    else
                        sts_received_d1 <= mm2s_sts_received;
                    end if;
                end if;
            end process REG_STATUS;

        -- CR566306 - status invalid during halt
        --sts_received_re <= mm2s_sts_received and not sts_received_d1;
        sts_received_re <= mm2s_sts_received and not sts_received_d1 and not mm2s_halt_d2;

    end generate GEN_UPDT_FOR_QUEUE;




    -----------------------------------------------------------------------
    -- Receive Status SG Update Logic
    -----------------------------------------------------------------------
    -- clear flag when updating status and see a tlast and target
    -- (i.e. sg engine) is ready
    updt_sts_clr <= '1' when updt_sts = '1'
                         and updtsts_tlast = '1'
                         and updtsts_tvalid = '1'
                         and s_axis_mm2s_updtsts_tready = '1'
                else '0';

    -- When status received set and hold flag until
    -- status can be updated to queue.  Note it may
    -- be held off due to update of data
    UPDT_STS_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    updt_sts                <= '0';
                -- clear flag when status update done
                -- or datamover halted
                elsif(updt_sts_clr = '1')then
                    updt_sts                <= '0';
                -- set flag when status received
                elsif(sts_received_re = '1')then
                    updt_sts                <= '1';
                end if;
            end if;
        end process UPDT_STS_PROCESS;


    UPDT_STS_PRO1CESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
s_axis_mm2s_updtsts_id      <= (others => '0');
                -- clear flag when status update done
                -- or datamover halted
                -- set flag when status received
                elsif(sts_received_re = '1') then --mm2s_desc_sof_i = '1' and mm2s_new_curdesc_wren_i = '1')then
s_axis_mm2s_updtsts_id      <= id_read_data;
                end if;
            end if;
        end process UPDT_STS_PRO1CESS;


        id_rst <= not (m_axi_sg_aresetn);
        id_write <= mm2s_new_curdesc_wren_i;

            ID_FIFO : entity lib_srl_fifo_v1_0_2.srl_fifo_f
              generic map(
                C_DWIDTH        => 16                              ,
                C_DEPTH         => 16                                               ,
                C_FAMILY        => C_FAMILY
                )
              port map(
                Clk             => m_axi_sg_aclk                                  ,
                Reset           => id_rst, --xb_fifo_reset                                    ,
                FIFO_Write      => id_write                                     ,
                Data_In         => channel_id                                       ,
                FIFO_Read       => sts_received_re                                  ,
                Data_Out        => id_read_data, --s2mm_xferd_bytes                                 ,
                FIFO_Empty      => open                                             ,
                FIFO_Full       => open, --xb_fifo_full                                     ,
                Addr            => open
                );



    -----------------------------------------------------------------------
    -- Catpure Status.  Status is built from status word from DataMover
    -- and from transferred bytes value.
    -----------------------------------------------------------------------
    UPDT_DESC_WRD2 : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    updt_desc_reg2  <= (others => '0');

                elsif(sts_received_re = '1')then
                    updt_desc_reg2  <= DESC_LAST
                                     & mm2s_tag(DATAMOVER_STS_TAGLSB_BIT)  -- Desc_IOC
                                     & mm2s_complete
                                     & mm2s_decerr
                                     & mm2s_slverr
                                     & mm2s_interr
                                     & RESERVED_STS
                                     & mm2s_xferd_bytes;
                end if;
            end if;
        end process UPDT_DESC_WRD2;


    updtsts_tdata  <= updt_desc_reg2(C_S_AXIS_UPDSTS_TDATA_WIDTH-1 downto 0);
    -- MSB asserts last on last word of update stream
    updtsts_tlast  <= updt_desc_reg2(C_S_AXIS_UPDSTS_TDATA_WIDTH);
    -- Drive tvalid
    updtsts_tvalid <= updt_sts;


    -- Drive update done to mm2s sm for the no queue case to indicate
    -- readyd to fetch next descriptor
    UPDT_DONE_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    desc_update_done <= '0';
                elsif(updt_sts_clr = '1')then
                    desc_update_done <= '1';
                else
                    desc_update_done <= '0';
                end if;
            end if;
       end process UPDT_DONE_PROCESS;


    -- Update Pointer Stream
    s_axis_mm2s_updtptr_tvalid <= updtptr_tvalid;
    s_axis_mm2s_updtptr_tlast  <= updtptr_tlast and updtptr_tvalid;
    s_axis_mm2s_updtptr_tdata  <= updtptr_tdata ;

    -- Update Status Stream
    s_axis_mm2s_updtsts_tvalid <= updtsts_tvalid;
    s_axis_mm2s_updtsts_tlast  <= updtsts_tlast and updtsts_tvalid;
    s_axis_mm2s_updtsts_tdata  <= updtsts_tdata ;


end implementation;
















-------------------------------------------------------------------------------
-- axi_mcdma_mm2s_sm
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_mcdma_mm2s_sm.vhd
-- Description: This entity contains the MM2S DMA Controller State Machine
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.clog2;


-------------------------------------------------------------------------------
entity  axi_mcdma_mm2s_sm is
    generic (
        C_M_AXI_MM2S_ADDR_WIDTH     : integer range 32 to 64    := 32;
            -- Master AXI Memory Map Address Width for MM2S Read Port

        C_SG_LENGTH_WIDTH           : integer range 8 to 26     := 14;
            -- Width of Buffer Length, Transferred Bytes, and BTT fields

        C_SG_INCLUDE_DESC_QUEUE     : integer range 0 to 1      := 0;
            -- Include or Exclude Scatter Gather Descriptor Queuing
            -- 0 = Exclude SG Descriptor Queuing
            -- 1 = Include SG Descriptor Queuing

        C_PRMY_CMDFIFO_DEPTH        : integer range 1 to 16     := 1
            -- Depth of DataMover command FIFO
    );
    port (
        m_axi_sg_aclk               : in  std_logic                         ;                      --
        m_axi_sg_aresetn            : in  std_logic                         ;                      --
                                                                                                   --
        -- Channel 1 Control and Status                                                            --
        mm2s_run_stop               : in  std_logic                         ;                      --
        mm2s_ftch_idle              : in  std_logic                         ;                      --
        mm2s_stop                   : in  std_logic                         ;                      --
        mm2s_cmnd_idle              : out std_logic                         ;                      --
        mm2s_sts_idle               : out std_logic                         ;                      --
        mm2s_desc_flush             : out std_logic                         ;                      --
                                                                                                   --
        -- MM2S Descriptor Fetch Request (from mm2s_sm)                                            --
        desc_available              : in  std_logic                         ;                      --
        desc_fetch_req              : out std_logic                         ;                      --
        desc_fetch_done             : in  std_logic                         ;                      --
        desc_update_done            : in  std_logic                         ;                      --
        packet_in_progress          : in  std_logic                         ;                      --
                                                                                                   --
        -- DataMover Command                                                                       --
        mm2s_cmnd_wr                : out std_logic                         ;                      --
        mm2s_cmnd_data              : out std_logic_vector                                         --
                                        ((C_M_AXI_MM2S_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);     --
        mm2s_cmnd_pending           : in std_logic                          ;                      --
                                                                                                   --
        -- Descriptor Fields                                                                       --
        mm2s_desc_baddress          : in  std_logic_vector                                         --
                                        (C_M_AXI_MM2S_ADDR_WIDTH-1 downto 0);                      --
        mm2s_desc_blength           : in  std_logic_vector                                         --
                                        (BUFFER_LENGTH_WIDTH-1 downto 0)    ;                      --
        mm2s_desc_eof               : in  std_logic                         ;                      --
        mm2s_desc_sof               : in  std_logic                                                --

    );

end axi_mcdma_mm2s_sm;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_mm2s_sm is

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
-- DataMover Commmand TAG
constant MM2S_CMD_TAG       : std_logic_vector(2 downto 0)  := (others => '0');
-- DataMover Command Destination Stream Offset
constant MM2S_CMD_DSA       : std_logic_vector(5 downto 0)  := (others => '0');
-- DataMover Cmnd Reserved Bits
constant MM2S_CMD_RSVD      : std_logic_vector(
                                DATAMOVER_CMD_RSVMSB_BOFST + C_M_AXI_MM2S_ADDR_WIDTH downto
                                DATAMOVER_CMD_RSVLSB_BOFST + C_M_AXI_MM2S_ADDR_WIDTH)
                                := (others => '0');

-- Queued commands counter width
constant COUNTER_WIDTH      : integer := clog2(C_PRMY_CMDFIFO_DEPTH+1);
-- Queued commands zero count
constant ZERO_COUNT         : std_logic_vector(COUNTER_WIDTH - 1 downto 0)
                                := (others => '0');



-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
type SG_MM2S_STATE_TYPE      is (
                                IDLE,
                                FETCH_DESCRIPTOR,
                                EXECUTE_XFER,
                                WAIT_STATUS,
                                BUBBLE1,
                                BUBBLE2
                                );

signal mm2s_cs                  : SG_MM2S_STATE_TYPE;
signal mm2s_ns                  : SG_MM2S_STATE_TYPE;



-- State Machine Signals
signal desc_fetch_req_cmb       : std_logic := '0';
signal write_cmnd_cmb           : std_logic := '0';
signal mm2s_cmnd_wr_i           : std_logic := '0';

signal cmnds_queued             : std_logic_vector(COUNTER_WIDTH - 1 downto 0) := (others => '0');
signal count_incr               : std_logic := '0';
signal count_decr               : std_logic := '0';
signal mm2s_desc_flush_i        : std_logic := '0';

signal queue_more               : std_logic := '0';
signal mm2s_run_stop_re               : std_logic := '0';
signal mm2s_run_stop_fe               : std_logic := '0';
signal mm2s_run_stop_del               : std_logic := '0';
signal flush_bd                       : std_logic := '0';

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

mm2s_cmnd_wr    <= mm2s_cmnd_wr_i;
mm2s_desc_flush <= mm2s_desc_flush_i;

-- this lock register is added to ensure that BDs are not flushed at start
-- helps to improve throughput
BD_QUEUE_STATE : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
               mm2s_run_stop_del <= '0';
            else
               mm2s_run_stop_del <= mm2s_run_stop;
            end if;
        end if;
    end process BD_QUEUE_STATE;

mm2s_run_stop_re <= mm2s_run_stop and (not mm2s_run_stop_del);
mm2s_run_stop_fe <= mm2s_run_stop_del and (not mm2s_run_stop);


FLUSH_BD_QUEUE_STATE : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
               flush_bd <= '0';
            elsif (mm2s_run_stop_fe = '1') then
               flush_bd <= '1';
            elsif (mm2s_run_stop_re = '1') then
               flush_bd <= '0';
            end if;
        end if;
    end process FLUSH_BD_QUEUE_STATE;


-- Flush any fetch descriptors if stopped due to errors or soft reset
-- or if not in middle of packet and run/stop clears
mm2s_desc_flush_i <= '1' when (mm2s_stop = '1')

                          or  (packet_in_progress = '0'
                               and flush_bd  = '1')
              else '0';

-------------------------------------------------------------------------------
-- MM2S Transfer State Machine
-------------------------------------------------------------------------------
MM2S_MACHINE : process(mm2s_cs,
                       mm2s_run_stop,
                       packet_in_progress,
                       desc_available,
                       desc_fetch_done,
                       desc_update_done,
                       mm2s_cmnd_pending,
                       mm2s_stop,
                       mm2s_desc_flush_i,
                       queue_more
                       )
    begin

        -- Default signal assignment
        desc_fetch_req_cmb      <= '0';
        write_cmnd_cmb          <= '0';
        mm2s_cmnd_idle          <= '0';
        mm2s_ns                 <= mm2s_cs;

        case mm2s_cs is

            -------------------------------------------------------------------
            when IDLE =>
                -- Running or Stopped but in middle of xfer and Descriptor
                -- data available, No errors logged, and Room to queue more
                -- commands, then fetch descriptor
                if( (mm2s_run_stop = '1' or packet_in_progress = '1')
                and desc_available = '1' and mm2s_stop = '0' and queue_more = '1') then
                    mm2s_ns <= FETCH_DESCRIPTOR;
                else
                    mm2s_cmnd_idle <= '1';
                end if;

            -------------------------------------------------------------------
            when FETCH_DESCRIPTOR =>
                -- error detected or run/stop cleared
                if(mm2s_desc_flush_i = '1')then
                    mm2s_ns     <= IDLE;
                -- descriptor fetch complete
                elsif(desc_fetch_done = '1')then
                    desc_fetch_req_cmb  <= '0';
                    mm2s_ns             <= EXECUTE_XFER;
                else
                    desc_fetch_req_cmb  <= '1';
                end if;

            -------------------------------------------------------------------
            when EXECUTE_XFER =>
                -- error detected
                if(mm2s_stop = '1')then
                    mm2s_ns     <= IDLE;
                -- Write another command if there is not one already pending
                elsif(mm2s_cmnd_pending = '0')then
                    write_cmnd_cmb  <= '1';
                    if(C_SG_INCLUDE_DESC_QUEUE = 1)then
                        mm2s_ns         <= BUBBLE1; --IDLE;
                    else
                        mm2s_ns         <= WAIT_STATUS;
                    end if;
                else
                    mm2s_ns             <= EXECUTE_XFER;
                end if;

            -------------------------------------------------------------------
            when WAIT_STATUS =>
                -- wait until desc update complete or error occurs
                if(desc_update_done = '1' or mm2s_stop = '1')then
                    mm2s_ns <= IDLE;
                else
                    mm2s_ns <= WAIT_STATUS;
                end if;

            when BUBBLE1 =>
                -- wait until desc update complete or error occurs
                    mm2s_ns <= BUBBLE2;

            when BUBBLE2 =>
                -- wait until desc update complete or error occurs
                    mm2s_ns <= IDLE;
            -------------------------------------------------------------------
          -- coverage off
            when others =>
                mm2s_ns <= IDLE;
          -- coverage on

        end case;
    end process MM2S_MACHINE;

-------------------------------------------------------------------------------
-- register state machine states
-------------------------------------------------------------------------------
REGISTER_STATE : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                mm2s_cs     <= IDLE;
            else
                mm2s_cs     <= mm2s_ns;
            end if;
        end if;
    end process REGISTER_STATE;

-------------------------------------------------------------------------------
-- register state machine signals
-------------------------------------------------------------------------------
SM_SIG_REGISTER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                desc_fetch_req      <= '0'      ;
            else
                desc_fetch_req      <= desc_fetch_req_cmb   ;
            end if;
        end if;
    end process SM_SIG_REGISTER;

-------------------------------------------------------------------------------
-- Build DataMover command
-------------------------------------------------------------------------------
-- If Bytes To Transfer (BTT) width less than 23, need to add pad
GEN_CMD_BTT_LESS_23 : if C_SG_LENGTH_WIDTH < 26 generate
constant PAD_VALUE : std_logic_vector(25 - C_SG_LENGTH_WIDTH downto 0)
                        := (others => '0');
begin
    -- When command by sm, drive command to mm2s_cmdsts_if
    GEN_DATAMOVER_CMND : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    mm2s_cmnd_wr_i  <= '0';
                    mm2s_cmnd_data  <= (others => '0');

                -- Fetch SM issued a command write
                --
                -- Note: change to mode where EOF generates IOC interrupt as
                -- opposed to a IOC bit in the descriptor negated need for an
                -- EOF and IOC tag.  Given time, these two bits could be combined
                -- into 1.  Associated logic in SG engine would also need to be
                -- modified as well as in mm2s_sg_if.
                elsif(write_cmnd_cmb = '1')then
                    mm2s_cmnd_wr_i  <= '1';
                    mm2s_cmnd_data  <=  MM2S_CMD_RSVD
                                        -- Command Tag
                                        & '0'
                                        & '0'
                                        & mm2s_desc_eof  -- Cat. EOF to CMD Tag
                                        & mm2s_desc_eof  -- Cat. IOC to CMD Tag
                                        -- Command
                                        & mm2s_desc_baddress
                                        & mm2s_desc_sof
                                        & mm2s_desc_eof
                                        & MM2S_CMD_DSA
                                        & '1'       -- mm2s_desc_type IR#545697
                                        & PAD_VALUE
                                        & mm2s_desc_blength(C_SG_LENGTH_WIDTH-1 downto 0);

                else
                    mm2s_cmnd_wr_i  <= '0';

                end if;
            end if;
        end process GEN_DATAMOVER_CMND;

end generate GEN_CMD_BTT_LESS_23;

-- If Bytes To Transfer (BTT) width equal 23, no required pad
GEN_CMD_BTT_EQL_23 : if C_SG_LENGTH_WIDTH = 26 generate
begin
    -- When command by sm, drive command to mm2s_cmdsts_if
    GEN_DATAMOVER_CMND : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    mm2s_cmnd_wr_i  <= '0';
                    mm2s_cmnd_data  <= (others => '0');

                -- Fetch SM issued a command write
                --
                -- Note: change to mode where EOF generates IOC interrupt as
                -- opposed to a IOC bit in the descriptor negated need for an
                -- EOF and IOC tag.  Given time, these two bits could be combined
                -- into 1.  Associated logic in SG engine would also need to be
                -- modified as well as in mm2s_sg_if.
                elsif(write_cmnd_cmb = '1')then
                    mm2s_cmnd_wr_i  <= '1';
                    mm2s_cmnd_data  <=  MM2S_CMD_RSVD
                                        -- Command Tag
                                        & '0'
                                        & '0'
                                        & mm2s_desc_eof  -- Cat. EOF to CMD Tag
                                        & mm2s_desc_eof  -- Cat. IOC to CMD Tag (ioc changed to EOF)
                                        -- Command
                                        & mm2s_desc_baddress
                                        & mm2s_desc_sof
                                        & mm2s_desc_eof
                                        & MM2S_CMD_DSA
                                        & '1'               -- mm2s_desc_type IR#545697
                                        & mm2s_desc_blength;

                else
                    mm2s_cmnd_wr_i  <= '0';

                end if;
            end if;
        end process GEN_DATAMOVER_CMND;

end generate GEN_CMD_BTT_EQL_23;


-------------------------------------------------------------------------------
-- Counter for keepting track of pending commands/status in primary datamover
-- Use this to determine if primary datamover for mm2s is Idle.
-------------------------------------------------------------------------------
-- increment with each command written
count_incr  <= '1' when mm2s_cmnd_wr_i = '1' and desc_update_done = '0'
          else '0';

-- decrement with each status received
count_decr  <= '1' when mm2s_cmnd_wr_i = '0' and desc_update_done = '1'
          else '0';

-- count number of queued commands to keep track of what datamover is still
-- working on
CMD2STS_COUNTER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0' or mm2s_stop = '1')then
                cmnds_queued <= (others => '0');
            elsif(count_incr = '1')then
                cmnds_queued <= std_logic_vector(unsigned(cmnds_queued(COUNTER_WIDTH - 1 downto 0)) + 1);
            elsif(count_decr = '1')then
                cmnds_queued <= std_logic_vector(unsigned(cmnds_queued(COUNTER_WIDTH - 1 downto 0)) - 1);
            end if;
        end if;
    end process CMD2STS_COUNTER;

-- Indicate status is idle when no cmnd/sts queued
mm2s_sts_idle <= '1' when  cmnds_queued = ZERO_COUNT
            else '0';

-------------------------------------------------------------------------------
-- Queue only the amount of commands that can be queued on descriptor update
-- else lock up can occur. Note datamover command fifo depth is set to number
-- of descriptors to queue.
-------------------------------------------------------------------------------
QUEUE_MORE_PROCESS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                queue_more <= '0';
            elsif(cmnds_queued < std_logic_vector(to_unsigned(C_PRMY_CMDFIFO_DEPTH,COUNTER_WIDTH)))then
                queue_more <= '1';
            else
                queue_more <= '0';
            end if;
        end if;
    end process QUEUE_MORE_PROCESS;

end implementation;



-------------------------------------------------------------------------------
-- axi_mcdma_mm2s_cmdsts_if
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:    axi_mcdma_mm2s_cmdsts_if.vhd
-- Description: This entity is the descriptor fetch command and status inteface
--              for the Scatter Gather Engine AXI DataMover.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_mcdma_mm2s_cmdsts_if is
    generic (
        C_M_AXI_MM2S_ADDR_WIDTH       : integer range 32 to 64        := 32
            -- Master AXI Memory Map Address Width for Scatter Gather R/W Port

    );
    port (
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               : in  std_logic                         ;                   --
        m_axi_sg_aresetn            : in  std_logic                         ;                   --
                                                                                                --
        -- Command write interface from mm2s sm                                                 --
        mm2s_cmnd_wr                : in  std_logic                         ;                   --
        mm2s_cmnd_data              : in  std_logic_vector                                      --
                                        ((C_M_AXI_MM2S_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);  --
        mm2s_cmnd_pending           : out std_logic                         ;                   --
        mm2s_sts_received_clr       : in  std_logic                         ;                   --
        mm2s_sts_received           : out std_logic                         ;                   --
        mm2s_tailpntr_enble         : in  std_logic                         ;                   --
        mm2s_desc_cmplt             : in  std_logic                         ;                   --
                                                                                                --
        -- User Command Interface Ports (AXI Stream)                                            --
        s_axis_mm2s_cmd_tvalid      : out std_logic                         ;                   --
        s_axis_mm2s_cmd_tready      : in  std_logic                         ;                   --
        s_axis_mm2s_cmd_tdata       : out std_logic_vector                                      --
                                        ((C_M_AXI_MM2S_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);  --
                                                                                                --
        -- User Status Interface Ports (AXI Stream)                                             --
        m_axis_mm2s_sts_tvalid      : in  std_logic                         ;                   --
        m_axis_mm2s_sts_tready      : out std_logic                         ;                   --
        m_axis_mm2s_sts_tdata       : in  std_logic_vector(7 downto 0)      ;                   --
        m_axis_mm2s_sts_tkeep       : in  std_logic_vector(0 downto 0)      ;                   --
                                                                                                --
        -- Scatter Gather Fetch Status                                                          --
        mm2s_err                    : in  std_logic                         ;                   --
        mm2s_done                   : out std_logic                         ;                   --
        mm2s_error                  : out std_logic                         ;                   --
        mm2s_interr                 : out std_logic                         ;                   --
        mm2s_slverr                 : out std_logic                         ;                   --
        mm2s_decerr                 : out std_logic                         ;                   --
        mm2s_tag                    : out std_logic_vector(3 downto 0)                          --

    );

end axi_mcdma_mm2s_cmdsts_if;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_mm2s_cmdsts_if is

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal sts_tready       : std_logic := '0';
signal sts_received_i   : std_logic := '0';
signal stale_desc       : std_logic := '0';
signal log_status       : std_logic := '0';

signal mm2s_slverr_i    : std_logic := '0';
signal mm2s_decerr_i    : std_logic := '0';
signal mm2s_interr_i    : std_logic := '0';
signal mm2s_error_or    : std_logic := '0';

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

mm2s_slverr <= mm2s_slverr_i;
mm2s_decerr <= mm2s_decerr_i;
mm2s_interr <= mm2s_interr_i;

-- Stale descriptor if complete bit already set and in tail pointer mode.
stale_desc <= '1' when mm2s_desc_cmplt = '1' and mm2s_tailpntr_enble = '1'
         else '0';


-------------------------------------------------------------------------------
-- DataMover Command Interface
-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
-- When command by fetch sm, drive descriptor fetch command to data mover.
-- Hold until data mover indicates ready.
-------------------------------------------------------------------------------
GEN_DATAMOVER_CMND : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                s_axis_mm2s_cmd_tvalid  <= '0';
                s_axis_mm2s_cmd_tdata   <= (others => '0');
                mm2s_cmnd_pending       <= '0';
            -- New command write and not flagged as stale descriptor
            elsif(mm2s_cmnd_wr = '1' and stale_desc = '0')then
                s_axis_mm2s_cmd_tvalid  <= '1';
                s_axis_mm2s_cmd_tdata   <= mm2s_cmnd_data;
                mm2s_cmnd_pending       <= '1';
            -- Clear flags when command excepted by datamover
            elsif(s_axis_mm2s_cmd_tready = '1')then
                s_axis_mm2s_cmd_tvalid  <= '0';
                s_axis_mm2s_cmd_tdata   <= (others => '0');
                mm2s_cmnd_pending       <= '0';

            end if;
        end if;
    end process GEN_DATAMOVER_CMND;

-------------------------------------------------------------------------------
-- DataMover Status Interface
-------------------------------------------------------------------------------
-- Drive ready low during reset to indicate not ready
REG_STS_READY : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                sts_tready <= '0';

            -- De-assert tready on acceptance of status to prevent
            -- over writing current status
            elsif(sts_tready = '1' and m_axis_mm2s_sts_tvalid = '1')then
                sts_tready <= '0';

            -- If not status received assert ready to datamover
            elsif(sts_received_i = '0') then
                sts_tready <= '1';
            end if;
        end if;
    end process REG_STS_READY;

-- Pass to DataMover
m_axis_mm2s_sts_tready <= sts_tready;

-------------------------------------------------------------------------------
-- Log status bits out of data mover.
-------------------------------------------------------------------------------
log_status <= '1' when m_axis_mm2s_sts_tvalid = '1' and sts_received_i = '0'
         else '0';

DATAMOVER_STS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                mm2s_done       <= '0';
                mm2s_slverr_i   <= '0';
                mm2s_decerr_i   <= '0';
                mm2s_interr_i   <= '0';
                mm2s_tag        <= (others => '0');
            -- Status valid, therefore capture status
            elsif(log_status = '1')then
                mm2s_done       <= m_axis_mm2s_sts_tdata(DATAMOVER_STS_CMDDONE_BIT);
                mm2s_slverr_i   <= m_axis_mm2s_sts_tdata(DATAMOVER_STS_SLVERR_BIT);
                mm2s_decerr_i   <= m_axis_mm2s_sts_tdata(DATAMOVER_STS_DECERR_BIT);
                mm2s_interr_i   <= m_axis_mm2s_sts_tdata(DATAMOVER_STS_INTERR_BIT);
                mm2s_tag        <= m_axis_mm2s_sts_tdata(DATAMOVER_STS_TAGMSB_BIT downto DATAMOVER_STS_TAGLSB_BIT);
            -- Only assert when valid
            else
                mm2s_done       <= '0';
                mm2s_slverr_i   <= '0';
                mm2s_decerr_i   <= '0';
                mm2s_interr_i   <= '0';
                mm2s_tag        <= (others => '0');
            end if;
        end if;
    end process DATAMOVER_STS;

-- Flag when status is received.  Used to hold status until sg if
-- can use status.  This only has meaning when SG Engine Queues are turned
-- on
STS_RCVD_FLAG : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            -- Clear flag on reset or sg_if status clear
            if(m_axi_sg_aresetn = '0' or mm2s_sts_received_clr = '1')then
                sts_received_i  <= '0';
            -- Status valid, therefore capture status
            elsif(m_axis_mm2s_sts_tvalid = '1' and sts_received_i = '0')then
                sts_received_i  <= '1';
            end if;
        end if;
    end process STS_RCVD_FLAG;

mm2s_sts_received    <= sts_received_i;


-------------------------------------------------------------------------------
-- Register global error from data mover.
-------------------------------------------------------------------------------
mm2s_error_or <= mm2s_slverr_i or mm2s_decerr_i or mm2s_interr_i;

-- Log errors into a global error output
MM2S_ERROR_PROCESS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                mm2s_error <= '0';
            -- If Datamover issues error on the transfer or if a stale descriptor is
            -- detected when in tailpointer mode then issue an error
            elsif((mm2s_error_or = '1')
               or (stale_desc = '1' and mm2s_cmnd_wr='1'))then
                mm2s_error <= '1';
            end if;
        end if;
    end process MM2S_ERROR_PROCESS;



end implementation;







































--  (c) Copyright 2012 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
------------------------------------------------------------
-------------------------------------------------------------------------------
-- Filename:    axi_mcdma_mm2s_cmdsts_if.vhd
-- Description: This entity is the descriptor fetch command and status inteface
--              for the Scatter Gather Engine AXI DataMover.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
--library ieee;
--use ieee.std_logic_1164.all;
--use ieee.numeric_std.all;
--use ieee.std_logic_misc.all;
--
--library unisim;
--use unisim.vcomponents.all;
--
--library axi_mcdma_v1_1_8;
--use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;
--
---------------------------------------------------------------------------------
--entity  axi_mcdma_mm2s_cmdsts_if is
--    generic (
--        C_M_AXI_MM2S_ADDR_WIDTH       : integer range 32 to 64        := 32;
--        C_ENABLE_QUEUE                : integer range 0 to 1          := 1;
--        C_ENABLE_MULTI_CHANNEL               : integer range 0 to 1          := 0
--            -- Master AXI Memory Map Address Width for Scatter Gather R/W Port
--
--    );
--    port (
--        -----------------------------------------------------------------------
--        -- AXI Scatter Gather Interface
--        -----------------------------------------------------------------------
--        m_axi_sg_aclk               : in  std_logic                         ;                   --
--        m_axi_sg_aresetn            : in  std_logic                         ;                   --
--                                                                                                --
--        -- Command write interface from mm2s sm                                                 --
--        mm2s_cmnd_wr                : in  std_logic                         ;                   --
--        mm2s_cmnd_data              : in  std_logic_vector                                      --
--                                        ((C_M_AXI_MM2S_ADDR_WIDTH-32+2*32+CMD_BASE_WIDTH+46)-1 downto 0);  --
--        mm2s_cmnd_pending           : out std_logic                         ;                   --
--        mm2s_sts_received_clr       : in  std_logic                         ;                   --
--        mm2s_sts_received           : out std_logic                         ;                   --
--        mm2s_tailpntr_enble         : in  std_logic                         ;                   --
--        mm2s_desc_cmplt             : in  std_logic                         ;                   --
--                                                                                                --
--        -- User Command Interface Ports (AXI Stream)                                            --
--        s_axis_mm2s_cmd_tvalid      : out std_logic                         ;                   --
--        s_axis_mm2s_cmd_tready      : in  std_logic                         ;                   --
--        s_axis_mm2s_cmd_tdata       : out std_logic_vector                                      --
--                                        ((C_M_AXI_MM2S_ADDR_WIDTH-32+2*32+CMD_BASE_WIDTH+46)-1 downto 0);  --
--                                                                                                --
--        -- User Status Interface Ports (AXI Stream)                                             --
--        m_axis_mm2s_sts_tvalid      : in  std_logic                         ;                   --
--        m_axis_mm2s_sts_tready      : out std_logic                         ;                   --
--        m_axis_mm2s_sts_tdata       : in  std_logic_vector(7 downto 0)      ;                   --
--        m_axis_mm2s_sts_tkeep       : in  std_logic_vector(0 downto 0)      ;                   --
--                                                                                                --
--        -- Scatter Gather Fetch Status                                                          --
--        mm2s_err                    : in  std_logic                         ;                   --
--        mm2s_done                   : out std_logic                         ;                   --
--        mm2s_error                  : out std_logic                         ;                   --
--        mm2s_interr                 : out std_logic                         ;                   --
--        mm2s_slverr                 : out std_logic                         ;                   --
--        mm2s_decerr                 : out std_logic                         ;                   --
--        mm2s_tag                    : out std_logic_vector(3 downto 0)                          --
--
--    );
--
--end axi_mcdma_mm2s_cmdsts_if;
--
---------------------------------------------------------------------------------
---- Architecture
---------------------------------------------------------------------------------
--architecture implementation of axi_mcdma_mm2s_cmdsts_if is
--  attribute DowngradeIPIdentifiedWarnings: string;
--  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";
--
--
---------------------------------------------------------------------------------
---- Functions
---------------------------------------------------------------------------------
--
---- No Functions Declared
--
---------------------------------------------------------------------------------
---- Constants Declarations
---------------------------------------------------------------------------------
--
---- No Constants Declared
--
---------------------------------------------------------------------------------
---- Signal / Type Declarations
---------------------------------------------------------------------------------
--signal sts_tready       : std_logic := '0';
--signal sts_received_i   : std_logic := '0';
--signal stale_desc       : std_logic := '0';
--signal log_status       : std_logic := '0';
--
--signal mm2s_slverr_i    : std_logic := '0';
--signal mm2s_decerr_i    : std_logic := '0';
--signal mm2s_interr_i    : std_logic := '0';
--signal mm2s_error_or    : std_logic := '0';
--
---------------------------------------------------------------------------------
---- Begin architecture logic
---------------------------------------------------------------------------------
--begin
--
--mm2s_slverr <= mm2s_slverr_i;
--mm2s_decerr <= mm2s_decerr_i;
--mm2s_interr <= mm2s_interr_i;
--
---- Stale descriptor if complete bit already set and in tail pointer mode.
--stale_desc <= '1' when mm2s_desc_cmplt = '1' and mm2s_tailpntr_enble = '1'
--         else '0';
--
--
---------------------------------------------------------------------------------
---- DataMover Command Interface
---------------------------------------------------------------------------------
--
--
---------------------------------------------------------------------------------
---- When command by fetch sm, drive descriptor fetch command to data mover.
---- Hold until data mover indicates ready.
---------------------------------------------------------------------------------
--GEN_NO_HOLD_DATA : if C_ENABLE_QUEUE = 1 generate
--begin
--GEN_DATAMOVER_CMND : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
--                s_axis_mm2s_cmd_tvalid  <= '0';
--          --      s_axis_mm2s_cmd_tdata   <= (others => '0');
--                mm2s_cmnd_pending       <= '0';
--            -- New command write and not flagged as stale descriptor
--            elsif(mm2s_cmnd_wr = '1' and stale_desc = '0')then
--                s_axis_mm2s_cmd_tvalid  <= '1';
--          --      s_axis_mm2s_cmd_tdata   <= mm2s_cmnd_data;
--                mm2s_cmnd_pending       <= '1';
--            -- Clear flags when command excepted by datamover
--            elsif(s_axis_mm2s_cmd_tready = '1')then
--                s_axis_mm2s_cmd_tvalid  <= '0';
--          --      s_axis_mm2s_cmd_tdata   <= (others => '0');
--                mm2s_cmnd_pending       <= '0';
--
--            end if;
--        end if;
--    end process GEN_DATAMOVER_CMND;
--
--                s_axis_mm2s_cmd_tdata   <= mm2s_cmnd_data;
--
--end generate GEN_NO_HOLD_DATA;
--
--GEN_HOLD_DATA : if C_ENABLE_QUEUE = 0 generate
--begin
--
--GEN_DATAMOVER_CMND : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
--                s_axis_mm2s_cmd_tvalid  <= '0';
--                s_axis_mm2s_cmd_tdata   <= (others => '0');
--                mm2s_cmnd_pending       <= '0';
--            -- New command write and not flagged as stale descriptor
--            elsif(mm2s_cmnd_wr = '1' and stale_desc = '0')then
--                s_axis_mm2s_cmd_tvalid  <= '1';
--                s_axis_mm2s_cmd_tdata   <= mm2s_cmnd_data;
--                mm2s_cmnd_pending       <= '1';
--            -- Clear flags when command excepted by datamover
--            elsif(s_axis_mm2s_cmd_tready = '1')then
--                s_axis_mm2s_cmd_tvalid  <= '0';
--                s_axis_mm2s_cmd_tdata   <= (others => '0');
--                mm2s_cmnd_pending       <= '0';
--
--            end if;
--        end if;
--    end process GEN_DATAMOVER_CMND;
--             --   s_axis_mm2s_cmd_tdata   <= mm2s_cmnd_data;
--end generate GEN_HOLD_DATA;
---------------------------------------------------------------------------------
---- DataMover Status Interface
---------------------------------------------------------------------------------
---- Drive ready low during reset to indicate not ready
--REG_STS_READY : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
--                sts_tready <= '0';
--
--            -- De-assert tready on acceptance of status to prevent
--            -- over writing current status
--            elsif(sts_tready = '1' and m_axis_mm2s_sts_tvalid = '1')then
--                sts_tready <= '0';
--
--            -- If not status received assert ready to datamover
--            elsif(sts_received_i = '0') then
--                sts_tready <= '1';
--            end if;
--        end if;
--    end process REG_STS_READY;
--
---- Pass to DataMover
--m_axis_mm2s_sts_tready <= sts_tready;
--
---------------------------------------------------------------------------------
---- Log status bits out of data mover.
---------------------------------------------------------------------------------
--log_status <= '1' when m_axis_mm2s_sts_tvalid = '1' and sts_received_i = '0'
--         else '0';
--
--DATAMOVER_STS : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
--                mm2s_done       <= '0';
--                mm2s_slverr_i   <= '0';
--                mm2s_decerr_i   <= '0';
--                mm2s_interr_i   <= '0';
--                mm2s_tag        <= (others => '0');
--            -- Status valid, therefore capture status
--            elsif(log_status = '1')then
--                mm2s_done       <= m_axis_mm2s_sts_tdata(DATAMOVER_STS_CMDDONE_BIT);
--                mm2s_slverr_i   <= m_axis_mm2s_sts_tdata(DATAMOVER_STS_SLVERR_BIT);
--                mm2s_decerr_i   <= m_axis_mm2s_sts_tdata(DATAMOVER_STS_DECERR_BIT);
--                mm2s_interr_i   <= m_axis_mm2s_sts_tdata(DATAMOVER_STS_INTERR_BIT);
--                mm2s_tag        <= m_axis_mm2s_sts_tdata(DATAMOVER_STS_TAGMSB_BIT downto DATAMOVER_STS_TAGLSB_BIT);
--            -- Only assert when valid
--            else
--                mm2s_done       <= '0';
--                mm2s_slverr_i   <= '0';
--                mm2s_decerr_i   <= '0';
--                mm2s_interr_i   <= '0';
--                mm2s_tag        <= (others => '0');
--            end if;
--        end if;
--    end process DATAMOVER_STS;
--
---- Flag when status is received.  Used to hold status until sg if
---- can use status.  This only has meaning when SG Engine Queues are turned
---- on
--STS_RCVD_FLAG : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            -- Clear flag on reset or sg_if status clear
--            if(m_axi_sg_aresetn = '0' or mm2s_sts_received_clr = '1')then
--                sts_received_i  <= '0';
--            -- Status valid, therefore capture status
--            elsif(m_axis_mm2s_sts_tvalid = '1' and sts_received_i = '0')then
--                sts_received_i  <= '1';
--            end if;
--        end if;
--    end process STS_RCVD_FLAG;
--
--mm2s_sts_received    <= sts_received_i;
--
--
---------------------------------------------------------------------------------
---- Register global error from data mover.
---------------------------------------------------------------------------------
--mm2s_error_or <= mm2s_slverr_i or mm2s_decerr_i or mm2s_interr_i;
--
---- Log errors into a global error output
--MM2S_ERROR_PROCESS : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
--                mm2s_error <= '0';
--            -- If Datamover issues error on the transfer or if a stale descriptor is
--            -- detected when in tailpointer mode then issue an error
--            elsif((mm2s_error_or = '1')
--               or (stale_desc = '1' and mm2s_cmnd_wr='1'))then
--                mm2s_error <= '1';
--            end if;
--        end if;
--    end process MM2S_ERROR_PROCESS;
--
--
--
--end implementation;


--  (c) Copyright 2012 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
------------------------------------------------------------
-------------------------------------------------------------------------------
-- Filename:    axi_mcdma_mm2s_sts_mngr.vhd
-- Description: This entity mangages 'halt' and 'idle' status for the MM2S
--              channel
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library lib_cdc_v1_0_2;
library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_mcdma_mm2s_sts_mngr is
    generic (
        C_PRMRY_IS_ACLK_ASYNC        : integer range 0 to 1          := 0
            -- Primary MM2S/S2MM sync/async mode
            -- 0 = synchronous mode     - all clocks are synchronous
            -- 1 = asynchronous mode    - Any one of the 4 clock inputs is not
            --                            synchronous to the other
    );
    port (
        -- system signals
        m_axi_sg_aclk               : in  std_logic                         ;           --
        m_axi_sg_aresetn            : in  std_logic                         ;           --
                                                                                        --
        -- dma control and sg engine status signals                                     --
        mm2s_run_stop               : in  std_logic                         ;           --
                                                                                        --
        mm2s_ftch_idle              : in  std_logic                         ;           --
        mm2s_updt_idle              : in  std_logic                         ;           --
        mm2s_cmnd_idle              : in  std_logic                         ;           --
        mm2s_sts_idle               : in  std_logic                         ;           --
                                                                                        --
        -- stop and halt control/status                                                 --
        mm2s_stop                   : in  std_logic                         ;           --
        mm2s_halt_cmplt             : in  std_logic                         ;           --
                                                                                        --
        -- system state and control                                                     --
        mm2s_all_idle               : out std_logic                         ;           --
        mm2s_halted_clr             : out std_logic                         ;           --
        mm2s_halted_set             : out std_logic                         ;           --
        mm2s_idle_set               : out std_logic                         ;           --
        mm2s_idle_clr               : out std_logic                                     --

    );

end axi_mcdma_mm2s_sts_mngr;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_mm2s_sts_mngr is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  ATTRIBUTE async_reg                      : STRING;
-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal all_is_idle          : std_logic := '0';
signal all_is_idle_d1       : std_logic := '0';
signal all_is_idle_re       : std_logic := '0';
signal all_is_idle_fe       : std_logic := '0';
signal mm2s_datamover_idle  : std_logic := '0';

signal mm2s_halt_cmpt_d1_cdc_tig    : std_logic := '0';
signal mm2s_halt_cmpt_cdc_d2    : std_logic := '0';
  --ATTRIBUTE async_reg OF mm2s_halt_cmpt_d1_cdc_tig  : SIGNAL IS "true";
  --ATTRIBUTE async_reg OF mm2s_halt_cmpt_cdc_d2  : SIGNAL IS "true";

signal mm2s_halt_cmpt_d2    : std_logic := '0';

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

-- Everything is idle when everything is idle
all_is_idle <=  mm2s_ftch_idle
            and mm2s_updt_idle
            and mm2s_cmnd_idle
            and mm2s_sts_idle;

-- Pass out for soft reset use
mm2s_all_idle <= all_is_idle;



-------------------------------------------------------------------------------
-- For data mover halting look at halt complete to determine when halt
-- is done and datamover has completly halted.  If datamover not being
-- halted then can ignore flag thus simply flag as idle.
-------------------------------------------------------------------------------
GEN_FOR_ASYNC : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
begin
    -- Double register to secondary clock domain.  This is sufficient
    -- because halt_cmplt will remain asserted until detected in
    -- reset module in secondary clock domain.
AWVLD_CDC_TO : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => mm2s_halt_cmplt,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => mm2s_halt_cmpt_cdc_d2,
        scndry_vect_out            => open
    );


--    REG_TO_SECONDARY : process(m_axi_sg_aclk)
--        begin
--            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            --    if(m_axi_sg_aresetn = '0')then
--            --        mm2s_halt_cmpt_d1_cdc_tig <= '0';
--            --        mm2s_halt_cmpt_d2 <= '0';
--            --    else
--                    mm2s_halt_cmpt_d1_cdc_tig <= mm2s_halt_cmplt;
--                    mm2s_halt_cmpt_cdc_d2 <= mm2s_halt_cmpt_d1_cdc_tig;
--            --    end if;
--            end if;
--        end process REG_TO_SECONDARY;

                    mm2s_halt_cmpt_d2 <= mm2s_halt_cmpt_cdc_d2;

end generate GEN_FOR_ASYNC;

GEN_FOR_SYNC : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
begin
    -- No clock crossing required therefore simple pass through
    mm2s_halt_cmpt_d2 <= mm2s_halt_cmplt;

end generate GEN_FOR_SYNC;




mm2s_datamover_idle  <= '1' when (mm2s_stop = '1' and mm2s_halt_cmpt_d2 = '1')
                              or (mm2s_stop = '0')
                   else '0';

-------------------------------------------------------------------------------
-- Set halt bit if run/stop cleared and all processes are idle
-------------------------------------------------------------------------------
HALT_PROCESS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                mm2s_halted_set <= '0';

            -- DMACR.Run/Stop is cleared, all processes are idle, datamover halt cmplted
            elsif(mm2s_run_stop = '0' and all_is_idle = '1' and mm2s_datamover_idle = '1')then
                mm2s_halted_set <= '1';
            else
                mm2s_halted_set <= '0';
            end if;
        end if;
    end process HALT_PROCESS;

-------------------------------------------------------------------------------
-- Clear halt bit if run/stop is set and SG engine begins to fetch descriptors
-------------------------------------------------------------------------------
NOT_HALTED_PROCESS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                mm2s_halted_clr <= '0';
            elsif(mm2s_run_stop = '1')then
                mm2s_halted_clr <= '1';
            else
                mm2s_halted_clr <= '0';
            end if;
        end if;
    end process NOT_HALTED_PROCESS;

-------------------------------------------------------------------------------
-- Register ALL is Idle to create rising and falling edges on idle flag
-------------------------------------------------------------------------------
IDLE_REG_PROCESS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                all_is_idle_d1 <= '0';
            else
                all_is_idle_d1 <= all_is_idle;
            end if;
        end if;
    end process IDLE_REG_PROCESS;

all_is_idle_re  <= all_is_idle and not all_is_idle_d1;
all_is_idle_fe  <= not all_is_idle and all_is_idle_d1;

-- Set or Clear IDLE bit in DMASR
mm2s_idle_set <= all_is_idle_re and mm2s_run_stop;
mm2s_idle_clr <= all_is_idle_fe;


end implementation;


-------------------------------------------------------------------------------
-- axi_mcdma_mm2s_cntrl_strm
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_mcdma_mm2s_cntrl_strm.vhd
-- Description: This entity is MM2S control stream logic
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.clog2;
use lib_pkg_v1_0_2.lib_pkg.max2;


library lib_fifo_v1_0_16;

-------------------------------------------------------------------------------
entity  axi_mcdma_mm2s_cntrl_strm is
    generic(
        C_PRMRY_IS_ACLK_ASYNC           : integer range 0 to 1      := 0;
            -- Primary MM2S/S2MM sync/async mode
            -- 0 = synchronous mode     - all clocks are synchronous
            -- 1 = asynchronous mode    - Primary data path channels (MM2S and S2MM)
            --                            run asynchronous to AXI Lite, DMA Control,
            --                            and SG.

        C_PRMY_CMDFIFO_DEPTH        : integer range 1 to 16         := 1;
            -- Depth of DataMover command FIFO

        C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH : integer range 32 to 32    := 32;
            -- Master AXI Control Stream Data Width

        C_FAMILY                        : string                    := "virtex6"
            -- Target FPGA Device Family
    );
    port (
        -- Secondary clock / reset
        m_axi_sg_aclk               : in  std_logic                         ;           --
        m_axi_sg_aresetn            : in  std_logic                         ;           --
                                                                                        --
        -- Primary clock / reset                                                        --
        axi_prmry_aclk              : in  std_logic                         ;           --
        p_reset_n                   : in  std_logic                         ;           --
                                                                                        --
        -- MM2S Error                                                                   --
        mm2s_stop                   : in  std_logic                         ;           --
                                                                                        --
        -- Control Stream FIFO write signals (from axi_mcdma_mm2s_sg_if)                  --
        cntrlstrm_fifo_wren         : in  std_logic                         ;           --
        cntrlstrm_fifo_din          : in  std_logic_vector                              --
                                        (C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH downto 0);     --
        cntrlstrm_fifo_full         : out std_logic                         ;           --
                                                                                        --
                                                                                        --
        -- Memory Map to Stream Control Stream Interface                                --
        m_axis_mm2s_cntrl_tdata     : out std_logic_vector                              --
                                        (C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH-1 downto 0);   --
        m_axis_mm2s_cntrl_tkeep     : out std_logic_vector                              --
                                        ((C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH/8)-1 downto 0);--
        m_axis_mm2s_cntrl_tvalid    : out std_logic                         ;           --
        m_axis_mm2s_cntrl_tready    : in  std_logic                         ;           --
        m_axis_mm2s_cntrl_tlast     : out std_logic                                     --



    );
end axi_mcdma_mm2s_cntrl_strm;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_mm2s_cntrl_strm is

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- Number of words deep fifo needs to be
-- Only 5 app fields, but set to 8 so depth is a power of 2
constant CNTRL_FIFO_DEPTH       : integer := max2(16,8 * C_PRMY_CMDFIFO_DEPTH);


-- Width of fifo rd and wr counts - only used for proper fifo operation
constant CNTRL_FIFO_CNT_WIDTH   : integer   := clog2(CNTRL_FIFO_DEPTH+1);

constant USE_LOGIC_FIFOS        : integer   := 0; -- Use Logic FIFOs
constant USE_BRAM_FIFOS         : integer   := 1; -- Use BRAM FIFOs

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
-- FIFO signals
signal cntrl_fifo_rden  : std_logic := '0';
signal cntrl_fifo_empty : std_logic := '0';
signal cntrl_fifo_dout  : std_logic_vector
                            (C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH downto 0) := (others => '0');
signal cntrl_fifo_dvalid: std_logic := '0';

signal cntrl_tdata      : std_logic_vector
                            (C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH-1 downto 0) := (others => '0');
signal cntrl_tkeep      : std_logic_vector
                            ((C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH/8)-1 downto 0) := (others => '0');
signal cntrl_tvalid     : std_logic := '0';
signal cntrl_tready     : std_logic := '0';
signal cntrl_tlast      : std_logic := '0';
signal sinit            : std_logic := '0';

signal m_valid          : std_logic := '0';
signal m_ready          : std_logic := '0';
signal m_data           : std_logic_vector(C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH-1 downto 0) := (others => '0');
signal m_strb           : std_logic_vector((C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH/8)-1 downto 0) := (others => '0');
signal m_last           : std_logic := '0';

signal skid_rst         : std_logic := '0';
-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin
-- All bytes always valid
cntrl_tkeep <= (others => '1');


-- Primary Clock is synchronous to Secondary Clock therfore
-- instantiate a sync fifo.
GEN_SYNC_FIFO : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
signal mm2s_stop_d1     : std_logic := '0';
signal mm2s_stop_re     : std_logic := '0';
signal xfer_in_progress : std_logic := '0';
begin
    -- reset on hard reset or mm2s stop
    sinit   <= not m_axi_sg_aresetn or mm2s_stop;

    -- Generate Synchronous FIFO
    I_CNTRL_FIFO : entity lib_fifo_v1_0_16.sync_fifo_fg
    generic map (
        C_FAMILY                =>  C_FAMILY                ,
        C_MEMORY_TYPE           =>  USE_LOGIC_FIFOS,
        C_WRITE_DATA_WIDTH      =>  C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH + 1,
        C_WRITE_DEPTH           =>  CNTRL_FIFO_DEPTH       ,
        C_READ_DATA_WIDTH       =>  C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH + 1,
        C_READ_DEPTH            =>  CNTRL_FIFO_DEPTH       ,
        C_PORTS_DIFFER          =>  0,
        C_HAS_DCOUNT            =>  1, --req for proper fifo operation
        C_DCOUNT_WIDTH          =>  CNTRL_FIFO_CNT_WIDTH,
        C_HAS_ALMOST_FULL       =>  0,
        C_HAS_RD_ACK            =>  0,
        C_HAS_RD_ERR            =>  0,
        C_HAS_WR_ACK            =>  0,
        C_HAS_WR_ERR            =>  0,
        C_RD_ACK_LOW            =>  0,
        C_RD_ERR_LOW            =>  0,
        C_WR_ACK_LOW            =>  0,
        C_WR_ERR_LOW            =>  0,
        C_PRELOAD_REGS          =>  1,-- 1 = first word fall through
        C_PRELOAD_LATENCY       =>  0, -- 0 = first word fall through
        C_XPM_FIFO              =>  1
 --       C_USE_EMBEDDED_REG      =>  1 -- 0 ;
    )
    port map (

        Clk             =>  m_axi_sg_aclk       ,
        Sinit           =>  sinit               ,
        Din             =>  cntrlstrm_fifo_din  ,
        Wr_en           =>  cntrlstrm_fifo_wren ,
        Rd_en           =>  cntrl_fifo_rden     ,
        Dout            =>  cntrl_fifo_dout     ,
        Full            =>  cntrlstrm_fifo_full ,
        Empty           =>  cntrl_fifo_empty    ,
        Almost_full     =>  open                ,
        Data_count      =>  open                ,
        Rd_ack          =>  open                ,
        Rd_err          =>  open                ,
        Wr_ack          =>  open                ,
        Wr_err          =>  open

    );

    -----------------------------------------------------------------------
    -- Control Stream OUT Side
    -----------------------------------------------------------------------
    -- Read if fifo is not empty and target is ready
    cntrl_fifo_rden  <= not cntrl_fifo_empty
                        and cntrl_tready;

    -- Drive valid if fifo is not empty or in the middle
    -- of transfer and stop issued.
    cntrl_tvalid  <= not cntrl_fifo_empty
                    or (xfer_in_progress and mm2s_stop_re);

    -- Pass data out to control channel with MSB driving tlast
    cntrl_tlast   <= (cntrl_tvalid and cntrl_fifo_dout(C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH))
                    or (xfer_in_progress and mm2s_stop_re);

    cntrl_tdata   <= cntrl_fifo_dout(C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH-1 downto 0);

    -- Register stop to create re pulse for cleaning shutting down
    -- stream out during soft reset.
    REG_STOP : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    mm2s_stop_d1    <= '0';
                else
                    mm2s_stop_d1    <= mm2s_stop;
                end if;
            end if;
        end process REG_STOP;

    mm2s_stop_re <= mm2s_stop and not mm2s_stop_d1;

    -------------------------------------------------------------
    -- Flag transfer in progress. If xfer in progress then
    -- a fake tlast and tvalid need to be asserted during soft
    -- reset else no need of tlast.
    -------------------------------------------------------------
    TRANSFER_IN_PROGRESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(cntrl_tlast = '1' and cntrl_tvalid = '1' and cntrl_tready = '1')then
                    xfer_in_progress <= '0';
                elsif(xfer_in_progress = '0' and cntrl_tvalid = '1')then
                    xfer_in_progress <= '1';
                end if;
            end if;
        end process TRANSFER_IN_PROGRESS;

    skid_rst   <= not m_axi_sg_aresetn;

    ---------------------------------------------------------------------------
    -- Buffer AXI Signals
    ---------------------------------------------------------------------------
    CNTRL_SKID_BUF_I : entity axi_mcdma_v1_1_8.axi_mcdma_skid_buf
        generic map(
            C_WDATA_WIDTH           => C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH
        )
        port map(
            -- System Ports
            ACLK            => m_axi_sg_aclk                          ,
            ARST            => skid_rst                                 ,

            skid_stop       => mm2s_stop_re                             ,

            -- Slave Side (Stream Data Input)
            S_VALID         => cntrl_tvalid                             ,
            S_READY         => cntrl_tready                             ,
            S_Data          => cntrl_tdata                              ,
            S_STRB          => cntrl_tkeep                              ,
            S_Last          => cntrl_tlast                              ,

            -- Master Side (Stream Data Output
            M_VALID         => m_axis_mm2s_cntrl_tvalid                 ,
            M_READY         => m_axis_mm2s_cntrl_tready                 ,
            M_Data          => m_axis_mm2s_cntrl_tdata                  ,
            M_STRB          => m_axis_mm2s_cntrl_tkeep                  ,
            M_Last          => m_axis_mm2s_cntrl_tlast
        );


end generate GEN_SYNC_FIFO;

-- Primary Clock is asynchronous to Secondary Clock therfore
-- instantiate an async fifo.
GEN_ASYNC_FIFO : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
signal mm2s_stop_reg        : std_logic := '0'; -- CR605883
signal p_mm2s_stop_cdc_to       : std_logic := '0';
signal p_mm2s_stop_d2       : std_logic := '0';
signal p_mm2s_stop_d3       : std_logic := '0';
signal p_mm2s_stop_d4       : std_logic := '0';
signal p_mm2s_stop_re       : std_logic := '0';
signal xfer_in_progress     : std_logic := '0';

ATTRIBUTE async_reg                           : STRING;
ATTRIBUTE async_reg OF p_mm2s_stop_cdc_to                       : signal IS "true";
ATTRIBUTE async_reg OF p_mm2s_stop_d2                       : signal IS "true";

begin

    -- reset on hard reset, soft reset, or mm2s error
    sinit   <= not m_axi_sg_aresetn or mm2s_stop; --p_mm2s_stop_d2;

    -- Generate Asynchronous FIFO
    I_CNTRL_STRM_FIFO : entity axi_mcdma_v1_1_8.axi_mcdma_afifo_autord
      generic map(
         C_DWIDTH        => C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH + 1  ,
-- Temp work around for issue in async fifo model
         C_DEPTH         => CNTRL_FIFO_DEPTH                    ,
--         C_CNT_WIDTH     => CNTRL_FIFO_CNT_WIDTH                ,
--         C_DEPTH         => 31                                  ,
         C_CNT_WIDTH     => 5                                   ,
         C_USE_BLKMEM    => USE_LOGIC_FIFOS                     ,
         C_FAMILY        => C_FAMILY
        )
      port map(
        -- Inputs
         AFIFO_Ainit                => sinit                    ,
         AFIFO_Wr_clk               => m_axi_sg_aclk            ,
         AFIFO_Wr_en                => cntrlstrm_fifo_wren      ,
         AFIFO_Din                  => cntrlstrm_fifo_din       ,
         AFIFO_Rd_clk               => axi_prmry_aclk           ,
         AFIFO_Rd_en                => cntrl_fifo_rden          ,
         AFIFO_Clr_Rd_Data_Valid    => '0'                      ,

        -- Outputs
         AFIFO_DValid               => cntrl_fifo_dvalid        ,
         AFIFO_Dout                 => cntrl_fifo_dout          ,
         AFIFO_Full                 => cntrlstrm_fifo_full      ,
         AFIFO_Empty                => cntrl_fifo_empty         ,
         AFIFO_Almost_full          => open                     ,
         AFIFO_Almost_empty         => open                     ,
         AFIFO_Wr_count             => open                     ,
         AFIFO_Rd_count             => open                     ,
         AFIFO_Corr_Rd_count        => open                     ,
         AFIFO_Corr_Rd_count_minus1 => open                     ,
         AFIFO_Rd_ack               => open
        );


    -----------------------------------------------------------------------
    -- Control Stream OUT Side
    -----------------------------------------------------------------------
    -- Read if fifo is not empty and target is ready
    cntrl_fifo_rden <= not cntrl_fifo_empty        -- fifo has data
                       and cntrl_tready;           -- target ready


    -- Drive valid if fifo is not empty or in the middle
    -- of transfer and stop issued.
    cntrl_tvalid  <= cntrl_fifo_dvalid
                    or (xfer_in_progress and p_mm2s_stop_re);

    -- Pass data out to control channel with MSB driving tlast
    cntrl_tlast   <= cntrl_tvalid and cntrl_fifo_dout(C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH);

    cntrl_tdata   <= cntrl_fifo_dout(C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH-1 downto 0);

    -- CR605883
    -- Register stop to provide pure FF output for synchronizer
    REG_STOP : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    mm2s_stop_reg <= '0';
                else
                    mm2s_stop_reg <= mm2s_stop;
                end if;
            end if;
        end process REG_STOP;


    -- Double/triple register mm2s error into primary clock domain
    -- Triple register to give two versions with min double reg for use
    -- in rising edge detection.
    REG_ERR2PRMRY : process(axi_prmry_aclk)
        begin
            if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
                if(p_reset_n = '0')then
                    p_mm2s_stop_cdc_to <= '0';
                    p_mm2s_stop_d2 <= '0';
                    p_mm2s_stop_d3 <= '0';
                    p_mm2s_stop_d4 <= '0';
                else
                    --p_mm2s_stop_d1 <= mm2s_stop;
                    p_mm2s_stop_cdc_to <= mm2s_stop_reg;
                    p_mm2s_stop_d2 <= p_mm2s_stop_cdc_to;
                    p_mm2s_stop_d3 <= p_mm2s_stop_d2;
                    p_mm2s_stop_d4 <= p_mm2s_stop_d3;
                end if;
            end if;
        end process REG_ERR2PRMRY;

    -- Rising edge pulse for use in shutting down stream output
    p_mm2s_stop_re <= p_mm2s_stop_d3 and not p_mm2s_stop_d4;

    -------------------------------------------------------------
    -- Flag transfer in progress. If xfer in progress then
    -- a fake tlast needs to be asserted during soft reset.
    -- else no need of tlast.
    -------------------------------------------------------------
    TRANSFER_IN_PROGRESS : process(axi_prmry_aclk)
        begin
            if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
                if(cntrl_tlast = '1' and cntrl_tvalid = '1' and cntrl_tready = '1')then
                    xfer_in_progress <= '0';
                elsif(xfer_in_progress = '0' and cntrl_tvalid = '1')then
                    xfer_in_progress <= '1';
                end if;
            end if;
        end process TRANSFER_IN_PROGRESS;


    skid_rst   <= not p_reset_n;

    ---------------------------------------------------------------------------
    -- Buffer AXI Signals
    ---------------------------------------------------------------------------
    CNTRL_SKID_BUF_I : entity axi_mcdma_v1_1_8.axi_mcdma_skid_buf
        generic map(
            C_WDATA_WIDTH           => C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH
        )
        port map(
            -- System Ports
            ACLK            => axi_prmry_aclk                           ,
            ARST            => skid_rst                                 ,

            skid_stop       => p_mm2s_stop_re                           ,

            -- Slave Side (Stream Data Input)
            S_VALID         => cntrl_tvalid                             ,
            S_READY         => cntrl_tready                             ,
            S_Data          => cntrl_tdata                              ,
            S_STRB          => cntrl_tkeep                              ,
            S_Last          => cntrl_tlast                              ,

            -- Master Side (Stream Data Output
            M_VALID         => m_axis_mm2s_cntrl_tvalid                 ,
            M_READY         => m_axis_mm2s_cntrl_tready                 ,
            M_Data          => m_axis_mm2s_cntrl_tdata                  ,
            M_STRB          => m_axis_mm2s_cntrl_tkeep                  ,
            M_Last          => m_axis_mm2s_cntrl_tlast
        );


end generate GEN_ASYNC_FIFO;


end implementation;


-------------------------------------------------------------------------------
-- axi_mcdma_mm2s_mngr
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_mcdma_mm2s_mngr.vhd
-- Description: This entity is the top level entity for the AXI DMA MM2S
--              manager.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_mcdma_mm2s_mngr is
    generic(

        C_PRMRY_IS_ACLK_ASYNC       : integer range 0 to 1         := 0;
            -- Primary MM2S/S2MM sync/async mode
            -- 0 = synchronous mode     - all clocks are synchronous
            -- 1 = asynchronous mode    - Primary data path channels (MM2S and S2MM)
            --                            run asynchronous to AXI Lite, DMA Control,
            --                            and SG.

        C_PRMY_CMDFIFO_DEPTH        : integer range 1 to 16         := 1;
            -- Depth of DataMover command FIFO

        -----------------------------------------------------------------------
        -- Scatter Gather Parameters
        -----------------------------------------------------------------------
        C_INCLUDE_SG                : integer range 0 to 1          := 1;
            -- Include or Exclude the Scatter Gather Engine
            -- 0 = Exclude SG Engine - Enables Simple DMA Mode
            -- 1 = Include SG Engine - Enables Scatter Gather Mode

        C_SG_INCLUDE_STSCNTRL_STRM      : integer range 0 to 1      := 1;
            -- Include or Exclude AXI Status and AXI Control Streams
            -- 0 = Exclude Status and Control Streams
            -- 1 = Include Status and Control Streams

        C_SG_INCLUDE_DESC_QUEUE     : integer range 0 to 1          := 0;
            -- Include or Exclude Scatter Gather Descriptor Queuing
            -- 0 = Exclude SG Descriptor Queuing
            -- 1 = Include SG Descriptor Queuing

        C_SG_LENGTH_WIDTH               : integer range 8 to 26     := 14;
            -- Descriptor Buffer Length, Transferred Bytes, and Status Stream
            -- Rx Length Width.  Indicates the least significant valid bits of
            -- descriptor buffer length, transferred bytes, or Rx Length value
            -- in the status word coincident with tlast.

        C_M_AXI_SG_ADDR_WIDTH           : integer range 32 to 64    := 32;
            -- Master AXI Memory Map Address Width for Scatter Gather R/W Port

        C_M_AXIS_SG_TDATA_WIDTH         : integer range 32 to 32    := 32;
            -- AXI Master Stream in for descriptor fetch

        C_S_AXIS_UPDPTR_TDATA_WIDTH : integer range 32 to 64     := 32;
            -- 32 Update Status Bits

        C_S_AXIS_UPDSTS_TDATA_WIDTH : integer range 33 to 33     := 33;
            -- 1 IOC bit + 32 Update Status Bits

        C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH : integer range 32 to 32    := 32;
            -- Master AXI Control Stream Data Width

        -----------------------------------------------------------------------
        -- Memory Map to Stream (MM2S) Parameters
        -----------------------------------------------------------------------
        C_INCLUDE_MM2S                  : integer range 0 to 1      := 1;
            -- Include or exclude MM2S primary data path
            -- 0 = Exclude MM2S primary data path
            -- 1 = Include MM2S primary data path

        C_M_AXI_MM2S_ADDR_WIDTH         : integer range 32 to 64    := 32;
            -- Master AXI Memory Map Address Width for MM2S Read Port

        C_MAX_CHANNELS                  : integer range 1 to 16     := 1;
        C_NUM_CHANNELS                  : integer range 1 to 16     := 1;
        C_MM2S_SCHEDULE                 : integer range 0 to 3      := 1;

        C_FAMILY                        : string            := "virtex6"
            -- Target FPGA Device Family
    );
    port (

        -- Secondary Clock and Reset
        m_axi_sg_aclk               : in  std_logic                         ;                 --
        m_axi_sg_aresetn            : in  std_logic                         ;                 --
                                                                                              --
        -- Primary Clock and Reset                                                            --
        axi_prmry_aclk              : in  std_logic                         ;                 --
        p_reset_n                   : in  std_logic                         ;                 --
                                                                                              --
        soft_reset                  : in  std_logic                         ;                 --

        channel_enable              : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        channel_weight              : in std_logic_vector (31 downto 0);
        channel_weight_2            : in std_logic_vector (31 downto 0);
        mm2s_schedule               : in std_logic_vector (3 downto 0);
        channel_idle                : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        channel_id                  : out std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        mm2s_tlast                  : in std_logic;
        mm2s_tready                 : in std_logic;
        tuser_out                   : out std_logic_vector (15 downto 0);
        tid_out                     : out std_logic_vector (7 downto 0);
        tdest_out                   : out std_logic_vector (3 downto 0);
                                                                                              --
        -- MM2S Control and Status                                                            --
        mm2s_run_stop               : in  std_logic                         ;                 --
        mm2s_halted                 : in  std_logic                         ;                 --
        mm2s_ftch_idle              : in  std_logic                         ;                 --
        mm2s_updt_idle              : in  std_logic                         ;                 --
        mm2s_ftch_err_early         : in  std_logic                         ;                 --
        mm2s_ftch_stale_desc        : in  std_logic                         ;                 --
        mm2s_tailpntr_enble         : in  std_logic                         ;                 --
        mm2s_halt                   : in  std_logic                         ;                 --
        mm2s_halt_cmplt             : in  std_logic                         ;                 --
        mm2s_halted_clr             : out std_logic                         ;                 --
        mm2s_halted_set             : out std_logic                         ;                 --
        mm2s_idle_set               : out std_logic                         ;                 --
        mm2s_idle_clr               : out std_logic                         ;                 --
        mm2s_new_curdesc            : out std_logic_vector                                    --
                                            (C_M_AXI_SG_ADDR_WIDTH-1 downto 0);               --
        mm2s_new_curdesc_wren       : out std_logic                         ;                 --
        mm2s_channel_id_reg_update  : out std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        mm2s_stop                   : out std_logic                         ;                 --
        mm2s_desc_flush             : out std_logic                         ;                 --
        mm2s_all_idle               : out std_logic                         ;                 --
                                                                                              --
        mm2s_error                  : out std_logic                         ;                 --
        s2mm_error                  : in  std_logic                         ;                 --

        -- Simple DMA Mode Signals
        mm2s_sa                     : in  std_logic_vector                                    --
                                        (C_M_AXI_MM2S_ADDR_WIDTH-1 downto 0);                 --
        mm2s_length_wren            : in  std_logic                         ;                 --
        mm2s_length                 : in  std_logic_vector                                    --
                                        (C_SG_LENGTH_WIDTH-1 downto 0)      ;                 --
        mm2s_smple_done             : out std_logic                         ;                 --
        mm2s_interr_set             : out std_logic                         ;                 --
        mm2s_slverr_set             : out std_logic                         ;                 --
        mm2s_decerr_set             : out std_logic                         ;                 --
                                                                                              --
                                                                                              --
        -- SG MM2S Descriptor Fetch AXI Stream In                                             --
        m_axis_mm2s_ftch_tdata      : in  std_logic_vector                                    --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0);                 --
        m_axis_mm2s_ftch_tvalid     : in  std_logic                         ;                 --
        m_axis_mm2s_ftch_tready     : out std_logic                         ;                 --
        m_axis_mm2s_ftch_tlast      : in  std_logic                         ;                 --
        m_axis_mm2s_ftch_data_valid : in std_logic;
        m_axis_mm2s_ftch_id         : in std_logic_vector (C_MAX_CHANNELS-1 downto 0);
                                                                                              --
        -- SG MM2S Descriptor Update AXI Stream Out                                           --
        s_axis_mm2s_updtptr_tdata   : out std_logic_vector                                    --
                                     (C_S_AXIS_UPDPTR_TDATA_WIDTH-1 downto 0);                --
        s_axis_mm2s_updtptr_tvalid  : out std_logic                         ;                 --
        s_axis_mm2s_updtptr_tready  : in  std_logic                         ;                 --
        s_axis_mm2s_updtptr_tlast   : out std_logic                         ;                 --
                                                                                              --
        s_axis_mm2s_updtsts_tdata   : out std_logic_vector                                    --
                                     (C_S_AXIS_UPDSTS_TDATA_WIDTH-1 downto 0);                --
        s_axis_mm2s_updtsts_tvalid  : out std_logic                         ;                 --
        s_axis_mm2s_updtsts_tready  : in  std_logic                         ;                 --
        s_axis_mm2s_updtsts_tlast   : out std_logic                         ;                 --
        s_axis_mm2s_updtsts_id      : out std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;  
                                                                                              --
        -- User Command Interface Ports (AXI Stream)                                          --
        s_axis_mm2s_cmd_tvalid      : out std_logic                         ;                 --
        s_axis_mm2s_cmd_tready      : in  std_logic                         ;                 --
        s_axis_mm2s_cmd_tdata       : out std_logic_vector                                    --
                                        ((C_M_AXI_MM2S_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);--
                                                                                              --
        -- User Status Interface Ports (AXI Stream)                                           --
        m_axis_mm2s_sts_tvalid      : in  std_logic                         ;                 --
        m_axis_mm2s_sts_tready      : out std_logic                         ;                 --
        m_axis_mm2s_sts_tdata       : in  std_logic_vector(7 downto 0)      ;                 --
        m_axis_mm2s_sts_tkeep       : in  std_logic_vector(0 downto 0)      ;                 --
        mm2s_err                    : in  std_logic                         ;                 --
                                                                                              --
        ftch_error                  : in  std_logic                         ;                 --
        updt_error                  : in  std_logic                         ;                 --
                                                                                              --
        -- Memory Map to Stream Control Stream Interface                                      --
        m_axis_mm2s_cntrl_tdata     : out std_logic_vector                                    --
                                        (C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH-1 downto 0);         --
        m_axis_mm2s_cntrl_tkeep     : out std_logic_vector                                    --
                                        ((C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH/8)-1 downto 0);     --
        m_axis_mm2s_cntrl_tvalid    : out std_logic                         ;                 --
        m_axis_mm2s_cntrl_tready    : in  std_logic                         ;                 --
        m_axis_mm2s_cntrl_tlast     : out std_logic                                           --

    );

end axi_mcdma_mm2s_mngr;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_mm2s_mngr is

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
-- Primary DataMover Command signals
signal mm2s_cmnd_wr                 : std_logic := '0';
signal mm2s_cmnd_data               : std_logic_vector
                                        ((C_M_AXI_MM2S_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0) := (others => '0');
signal mm2s_cmnd_pending            : std_logic := '0';

-- Primary DataMover Status signals
signal mm2s_done                    : std_logic := '0';
signal mm2s_stop_i                  : std_logic := '0';
signal mm2s_interr                  : std_logic := '0';
signal mm2s_slverr                  : std_logic := '0';
signal mm2s_decerr                  : std_logic := '0';
signal mm2s_tag                     : std_logic_vector(3 downto 0) := (others => '0');
signal dma_mm2s_error               : std_logic := '0';
signal soft_reset_d1                : std_logic := '0';
signal soft_reset_d2                : std_logic := '0';
signal soft_reset_re                : std_logic := '0';
signal mm2s_error_i                 : std_logic := '0';
signal cntrl_strm_stop              : std_logic := '0';
signal mm2s_halted_set_i            : std_logic := '0';

signal mm2s_sts_received_clr        : std_logic := '0';
signal mm2s_sts_received            : std_logic := '0';

signal mm2s_cmnd_idle               : std_logic := '0';
signal mm2s_sts_idle                : std_logic := '0';

-- Scatter Gather Interface signals
signal desc_fetch_req               : std_logic := '0';
signal desc_fetch_done              : std_logic := '0';
signal desc_update_req              : std_logic := '0';
signal desc_update_done             : std_logic := '0';
signal desc_available               : std_logic := '0';
signal packet_in_progress           : std_logic := '0';

signal mm2s_desc_baddress           : std_logic_vector(C_M_AXI_MM2S_ADDR_WIDTH-1 downto 0)  := (others => '0');
signal mm2s_desc_blength            : std_logic_vector(BUFFER_LENGTH_WIDTH-1 downto 0)    := (others => '0');
signal mm2s_desc_eof                : std_logic := '0';
signal mm2s_desc_sof                : std_logic := '0';
signal mm2s_desc_cmplt              : std_logic := '0';
signal mm2s_desc_app0               : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH-1 downto 0)    := (others => '0');
signal mm2s_desc_app1               : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH-1 downto 0)    := (others => '0');
signal mm2s_desc_app2               : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH-1 downto 0)    := (others => '0');
signal mm2s_desc_app3               : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH-1 downto 0)    := (others => '0');
signal mm2s_desc_app4               : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH-1 downto 0)    := (others => '0');

-- Control Stream Fifo write signals
signal cntrlstrm_fifo_wren          : std_logic := '0';
signal cntrlstrm_fifo_full          : std_logic := '0';
signal cntrlstrm_fifo_din           : std_logic_vector(C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH downto 0) := (others => '0');

signal mm2s_tuser_tid : std_logic_vector (23 downto 0);
signal mm2s_new_curdesc_wren_i : std_logic;

signal tdest_to_fifo : std_logic_vector (3 downto 0);
signal tuser_to_fifo : std_logic_vector (15 downto 0);
signal tid_to_fifo : std_logic_vector (7 downto 0);
signal tdest_wr_en : std_logic;
signal tuser_wr_en : std_logic;
signal tid_wr_en : std_logic;

signal tdest_to_fifo_fp : std_logic_vector (3 downto 0);
signal tuser_to_fifo_fp : std_logic_vector (15 downto 0);
signal tid_to_fifo_fp : std_logic_vector (7 downto 0);
signal tdest_wr_en_fp : std_logic;
signal tuser_wr_en_fp : std_logic;
signal tid_wr_en_fp : std_logic;

signal tdest_to_fifo_wrr : std_logic_vector (3 downto 0);
signal tuser_to_fifo_wrr : std_logic_vector (15 downto 0);
signal tid_to_fifo_wrr : std_logic_vector (7 downto 0);
signal tdest_wr_en_wrr : std_logic;
signal tuser_wr_en_wrr : std_logic;
signal tid_wr_en_wrr : std_logic;

signal tdest_to_fifo_wrr_fd : std_logic_vector (3 downto 0);
signal tuser_to_fifo_wrr_fd : std_logic_vector (15 downto 0);
signal tid_to_fifo_wrr_fd : std_logic_vector (7 downto 0);
signal tdest_wr_en_wrr_fd : std_logic;
signal tuser_wr_en_wrr_fd : std_logic;
signal tid_wr_en_wrr_fd : std_logic;

signal channel_id_fp : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal channel_id_wrr_fd : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal channel_id_wrr : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

mm2s_new_curdesc_wren <= mm2s_new_curdesc_wren_i;

-------------------------------------------------------------------------------
-- Include MM2S State Machine and support logic
-------------------------------------------------------------------------------
GEN_MM2S_DMA_CONTROL : if C_INCLUDE_MM2S = 1 generate
begin

    -- Pass out to register module
    mm2s_halted_set <= mm2s_halted_set_i;


    -------------------------------------------------------------------------------
    -- Graceful shut down logic
    -------------------------------------------------------------------------------
    -- Error from DataMover (DMAIntErr, DMADecErr, or DMASlvErr) or SG Update error
    -- or SG Fetch error, or Stale Descriptor Error
    mm2s_error_i <= dma_mm2s_error              -- Primary data mover reports error
                    or updt_error               -- SG Update engine reports error
                    or ftch_error               -- SG Fetch engine reports error
                    or mm2s_ftch_err_early      -- SG Fetch engine reports early error on mm2s
                    or mm2s_ftch_stale_desc;    -- SG Fetch stale descriptor error

    -- pass out to shut down s2mm
    mm2s_error <= mm2s_error_i;

    -- Clear run/stop and stop state machines due to errors or soft reset
    -- Error based on datamover error report or sg update error or sg fetch error
    -- SG update error and fetch error included because need to shut down, no way
    -- to update descriptors on sg update error and on fetch error descriptor
    -- data is corrupt therefor do not want to issue the xfer command to primary datamover
--CR#566306 status for both mm2s and s2mm datamover are masked during shutdown therefore
-- need to stop all processes regardless of the source of the error.
--    mm2s_stop_i    <= mm2s_error                -- Error
--                   or soft_reset;               -- Soft Reset issued
    mm2s_stop_i    <= mm2s_error_i              -- Error on MM2S
                   or s2mm_error                -- Error on S2MM
                   or soft_reset;               -- Soft Reset issued

    -- Reg stop out
    REG_STOP_OUT : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    mm2s_stop <= '0';
                else
                    mm2s_stop      <= mm2s_stop_i;
                end if;
            end if;
        end process REG_STOP_OUT;

    -- Generate DMA Controller For Scatter Gather Mode
    GEN_SCATTER_GATHER_MODE : if C_INCLUDE_SG = 1 generate
    begin
        -- Not Used in SG Mode (Errors are imbedded in updated descriptor and
        -- generate error after descriptor update is complete)
        mm2s_interr_set  <=  '0';
        mm2s_slverr_set  <=  '0';
        mm2s_decerr_set  <=  '0';
        mm2s_smple_done  <=  '0';


        ---------------------------------------------------------------------------
        -- MM2S Channel ID Generation
        ---------------------------------------------------------------------------
        I_MM2S_ID_WRR : entity  axi_mcdma_v1_1_8.axi_mcdma_mm2s_wrr
            generic map(
                C_PRMRY_IS_ACLK_ASYNC     => C_PRMRY_IS_ACLK_ASYNC          ,
                C_NUM_CHANNELS            => C_NUM_CHANNELS                 ,
                C_MM2S_SEQUENCE           => C_MM2S_SCHEDULE                ,
                C_FAMILY                  => C_FAMILY
            )
            port map(
                m_axi_sg_aclk               => m_axi_sg_aclk                    ,
                m_axi_sg_aresetn            => m_axi_sg_aresetn                 ,
                axi_prmry_aclk              => axi_prmry_aclk,
                p_reset_n                   => p_reset_n     ,

                start_trigger               => mm2s_run_stop,
                channel_enable              => channel_enable            ,-- from register

                channel_weight              => channel_weight,                           -- from register
                channel_weight_2            => channel_weight_2,                           -- from register

                mm2s_new_curdesc_wren       => mm2s_new_curdesc_wren_i        ,
                channel_eof                 => mm2s_desc_eof,                           -- from mm2s sg module
                channel_sof                 => mm2s_desc_sof,                           -- from mm2s sg module
                tuser_tid_from_sg           => mm2s_tuser_tid,                           -- from mm2s sg module

                channel_idle                => channel_idle,                            -- from SG
                mm2s_schedule               => mm2s_schedule,                           -- from register
                ch_id_to_sg                 => channel_id_wrr,
 
                tdest_to_fifo               => tdest_to_fifo_wrr,                           -- write to FIFO
                tuser_to_fifo               => tuser_to_fifo_wrr,                           -- write to FIFO
                tid_to_fifo                 => tid_to_fifo_wrr,                           -- write to FIFO
                tuser_wr_en                 => tuser_wr_en_wrr,                           -- FIFO wr_en
                tid_wr_en                   => tid_wr_en_wrr,                           -- FIFO wr_en
                tdest_wr_en                 => tdest_wr_en_wrr                           -- FIFO wr_en
               

            );

        I_MM2S_ID_WRR_FD : entity  axi_mcdma_v1_1_8.axi_mcdma_mm2s_wrr
            generic map(
                C_PRMRY_IS_ACLK_ASYNC     => C_PRMRY_IS_ACLK_ASYNC          ,
                C_NUM_CHANNELS            => C_NUM_CHANNELS                 ,
                C_MM2S_SEQUENCE           => C_MM2S_SCHEDULE                ,
                C_FAMILY                  => C_FAMILY
            )
            port map(
                m_axi_sg_aclk               => m_axi_sg_aclk                    ,
                m_axi_sg_aresetn            => m_axi_sg_aresetn                 ,
                axi_prmry_aclk              => axi_prmry_aclk,
                p_reset_n                   => p_reset_n     ,

                start_trigger               => mm2s_run_stop,
                channel_enable              => channel_enable            ,-- from register

                channel_weight              => channel_weight,                           -- from register
                channel_weight_2            => channel_weight_2,                           -- from register

                mm2s_new_curdesc_wren       => mm2s_new_curdesc_wren_i        ,
                channel_eof                 => mm2s_desc_eof,                           -- from mm2s sg module
                channel_sof                 => mm2s_desc_sof,                           -- from mm2s sg module
                tuser_tid_from_sg           => mm2s_tuser_tid,                           -- from mm2s sg module

                channel_idle                => channel_idle,                            -- from SG
                mm2s_schedule               => mm2s_schedule,                           -- from register
                ch_id_to_sg                 => channel_id_wrr_fd,
 
                tdest_to_fifo               => tdest_to_fifo_wrr_fd,                           -- write to FIFO
                tuser_to_fifo               => tuser_to_fifo_wrr_fd,                           -- write to FIFO
                tid_to_fifo                 => tid_to_fifo_wrr_fd,                           -- write to FIFO
                tuser_wr_en                 => tuser_wr_en_wrr_fd,                           -- FIFO wr_en
                tid_wr_en                   => tid_wr_en_wrr_fd,                           -- FIFO wr_en
                tdest_wr_en                 => tdest_wr_en_wrr_fd                           -- FIFO wr_en
               

            );

        I_MM2S_ID_FIXED : entity  axi_mcdma_v1_1_8.axi_mcdma_mm2s_priority
            generic map(
                C_PRMRY_IS_ACLK_ASYNC     => C_PRMRY_IS_ACLK_ASYNC          ,
                C_NUM_CHANNELS            => C_NUM_CHANNELS                 ,
                C_MM2S_SEQUENCE           => C_MM2S_SCHEDULE                ,
                C_FAMILY                  => C_FAMILY
            )
            port map(
                m_axi_sg_aclk               => m_axi_sg_aclk                    ,
                m_axi_sg_aresetn            => m_axi_sg_aresetn                 ,
                axi_prmry_aclk              => axi_prmry_aclk,
                p_reset_n                   => p_reset_n     ,

                start_trigger               => mm2s_run_stop,
                channel_enable              => channel_enable            ,-- from register

                channel_weight              => channel_weight,                           -- from register
                channel_weight_2            => channel_weight_2,                           -- from register

                mm2s_new_curdesc_wren       => mm2s_new_curdesc_wren_i        ,
                channel_eof                 => mm2s_desc_eof,                           -- from mm2s sg module
                channel_sof                 => mm2s_desc_sof,                           -- from mm2s sg module
                tuser_tid_from_sg           => mm2s_tuser_tid,                           -- from mm2s sg module

                channel_idle                => channel_idle,                            -- from SG
                mm2s_schedule               => mm2s_schedule,                           -- from register
                ch_id_to_sg                 => channel_id_fp,
 
                tdest_to_fifo               => tdest_to_fifo_fp,                           -- write to FIFO
                tuser_to_fifo               => tuser_to_fifo_fp,                           -- write to FIFO
                tid_to_fifo                 => tid_to_fifo_fp,                           -- write to FIFO
                tuser_wr_en                 => tuser_wr_en_fp,                           -- FIFO wr_en
                tid_wr_en                   => tid_wr_en_fp,                           -- FIFO wr_en
                tdest_wr_en                 => tdest_wr_en_fp                           -- FIFO wr_en
               

            );


FIXED_PRIORITY: if (C_MM2S_SCHEDULE = 1) generate
begin
    channel_id <= channel_id_fp;
    tdest_to_fifo <= tdest_to_fifo_fp;
    tuser_to_fifo <= tuser_to_fifo_fp;
    tid_to_fifo <= tid_to_fifo_fp;
    tdest_wr_en <= tdest_wr_en_fp;
    tuser_wr_en <= tuser_wr_en_fp;
    tid_wr_en <= tid_wr_en_fp;
end generate FIXED_PRIORITY;

WRR: if (C_MM2S_SCHEDULE = 2) generate
begin
    channel_id <= channel_id_wrr;
    tdest_to_fifo <= tdest_to_fifo_wrr;
    tuser_to_fifo <= tuser_to_fifo_wrr;
    tid_to_fifo <= tid_to_fifo_wrr;
    tdest_wr_en <= tdest_wr_en_wrr;
    tuser_wr_en <= tuser_wr_en_wrr;
    tid_wr_en <= tid_wr_en_wrr;
end generate WRR;

WRR_FD :if (C_MM2S_SCHEDULE = 3) generate
begin
    channel_id <= channel_id_wrr_fd;
    tdest_to_fifo <= tdest_to_fifo_wrr_fd;
    tuser_to_fifo <= tuser_to_fifo_wrr_fd;
    tid_to_fifo <= tid_to_fifo_wrr_fd;
    tdest_wr_en <= tdest_wr_en_wrr_fd;
    tuser_wr_en <= tuser_wr_en_wrr_fd;
    tid_wr_en <= tid_wr_en_wrr_fd;
end generate WRR_FD;

PROG:if (C_MM2S_SCHEDULE = 0) generate
begin

process(mm2s_schedule, channel_id_fp, channel_id_wrr_fd, channel_id_wrr,
tdest_to_fifo_fp, tuser_to_fifo_fp, tdest_wr_en_fp, tid_to_fifo_fp, tid_to_fifo_fp,         
tdest_to_fifo_wrr_fd, tuser_to_fifo_wrr_fd, tdest_wr_en_wrr_fd, tid_to_fifo_wrr_fd,         
tdest_to_fifo_wrr, tuser_to_fifo_wrr, tdest_wr_en_wrr, tid_to_fifo_wrr,
tuser_wr_en_fp, tuser_wr_en_wrr_fd, tuser_wr_en_wrr,
tid_wr_en_fp, tid_wr_en_wrr_fd, tid_wr_en_wrr         
)

begin

  case mm2s_schedule(2 downto 0) is
    when "001" =>
    channel_id <= channel_id_fp;
    tdest_to_fifo <= tdest_to_fifo_fp;
    tuser_to_fifo <= tuser_to_fifo_fp;
    tid_to_fifo <= tid_to_fifo_fp;
    tdest_wr_en <= tdest_wr_en_fp;
    tuser_wr_en <= tuser_wr_en_fp;
    tid_wr_en <= tid_wr_en_fp;

    when "010" =>
    channel_id <= channel_id_wrr;
    tdest_to_fifo <= tdest_to_fifo_wrr;
    tuser_to_fifo <= tuser_to_fifo_wrr;
    tid_to_fifo <= tid_to_fifo_wrr;
    tdest_wr_en <= tdest_wr_en_wrr;
    tuser_wr_en <= tuser_wr_en_wrr;
    tid_wr_en <= tid_wr_en_wrr;

    when "100" =>
    channel_id <= channel_id_wrr_fd;
    tdest_to_fifo <= tdest_to_fifo_wrr_fd;
    tuser_to_fifo <= tuser_to_fifo_wrr_fd;
    tid_to_fifo <= tid_to_fifo_wrr_fd;
    tdest_wr_en <= tdest_wr_en_wrr_fd;
    tuser_wr_en <= tuser_wr_en_wrr_fd;
    tid_wr_en <= tid_wr_en_wrr_fd;
          -- coverage off
    when others =>
    channel_id <= channel_id_wrr_fd;
    tdest_to_fifo <= tdest_to_fifo_wrr_fd;
    tuser_to_fifo <= tuser_to_fifo_wrr_fd;
    tid_to_fifo <= tid_to_fifo_wrr_fd;
    tdest_wr_en <= tdest_wr_en_wrr_fd;
    tuser_wr_en <= tuser_wr_en_wrr_fd;
    tid_wr_en <= tid_wr_en_wrr_fd;
          -- coverage on
end case;
end process;
end generate PROG;


        I_MM2S_TDEST_FIFO : entity  axi_mcdma_v1_1_8.axi_mcdma_mm2s_tdest

    generic map(

        C_PRMRY_IS_ACLK_ASYNC           => C_PRMRY_IS_ACLK_ASYNC,
        C_FAMILY                        => C_FAMILY
    )
    port map(
        -- Secondary clock / reset
        m_axi_sg_aclk              => m_axi_sg_aclk, 
        m_axi_sg_aresetn           => m_axi_sg_aresetn, 
                                                                                        --
        -- Primary clock / reset                                                        --
        axi_prmry_aclk             => axi_prmry_aclk, 
        p_reset_n                  => p_reset_n, 
        mm2s_tlast                 => mm2s_tlast, 
        mm2s_tready                => mm2s_tready, 

        tuser_data                 => tuser_to_fifo,  -- from the wrr,priority
        tid_data                   => tid_to_fifo,  -- from the wrr,priority
        tuser_wr_en                => tuser_wr_en,  -- from wrr,priority 
        tid_wr_en                  => tid_wr_en,  -- from wrr,priority 
        tuser_out                  => tuser_out,   -- out 
        tid_out                    => tid_out,   -- out 

        tdest_data                 => tdest_to_fifo, -- from the wrr,priority
        tdest_wr_en                => tdest_wr_en,  -- from wrr, priority 
        tdest_out                  => tdest_out   -- out 
    );


        ---------------------------------------------------------------------------
        -- MM2S Primary DMA Controller State Machine
        ---------------------------------------------------------------------------
        I_MM2S_SM : entity  axi_mcdma_v1_1_8.axi_mcdma_mm2s_sm
            generic map(
                C_M_AXI_MM2S_ADDR_WIDTH     => C_M_AXI_MM2S_ADDR_WIDTH          ,
                C_SG_LENGTH_WIDTH           => C_SG_LENGTH_WIDTH                ,
                C_SG_INCLUDE_DESC_QUEUE     => C_SG_INCLUDE_DESC_QUEUE          ,
                C_PRMY_CMDFIFO_DEPTH        => C_PRMY_CMDFIFO_DEPTH+1
            )
            port map(
                m_axi_sg_aclk               => m_axi_sg_aclk                    ,
                m_axi_sg_aresetn            => m_axi_sg_aresetn                 ,

                -- Channel 1 Control and Status
                mm2s_run_stop               => mm2s_run_stop                    ,
                mm2s_ftch_idle              => mm2s_ftch_idle                   ,
                mm2s_cmnd_idle              => mm2s_cmnd_idle                   ,
                mm2s_sts_idle               => mm2s_sts_idle                    ,
                mm2s_stop                   => mm2s_stop_i                      ,
                mm2s_desc_flush             => mm2s_desc_flush                  ,

                -- MM2S Descriptor Fetch Request (from mm2s_sm)
                desc_available              => desc_available                   ,
                desc_fetch_req              => desc_fetch_req                   ,
                desc_fetch_done             => desc_fetch_done                  ,
                desc_update_done            => desc_update_done                 ,
                packet_in_progress          => packet_in_progress               ,

                -- DataMover Command
                mm2s_cmnd_wr                => mm2s_cmnd_wr                     ,
                mm2s_cmnd_data              => mm2s_cmnd_data                   ,
                mm2s_cmnd_pending           => mm2s_cmnd_pending                ,

                -- Descriptor Fields
                mm2s_desc_baddress          => mm2s_desc_baddress               ,
                mm2s_desc_blength           => mm2s_desc_blength                ,
                mm2s_desc_eof               => mm2s_desc_eof                    ,
                mm2s_desc_sof               => mm2s_desc_sof
            );

        ---------------------------------------------------------------------------
        -- MM2S Scatter Gather State Machine
        ---------------------------------------------------------------------------
        I_MM2S_SG_IF : entity  axi_mcdma_v1_1_8.axi_mcdma_mm2s_sg_if
            generic map(

                -------------------------------------------------------------------
                -- Scatter Gather Parameters
                -------------------------------------------------------------------
                C_PRMRY_IS_ACLK_ASYNC           => C_PRMRY_IS_ACLK_ASYNC            ,
                C_SG_INCLUDE_DESC_QUEUE         => C_SG_INCLUDE_DESC_QUEUE      ,
                C_SG_INCLUDE_STSCNTRL_STRM      => C_SG_INCLUDE_STSCNTRL_STRM   ,
                C_M_AXIS_SG_TDATA_WIDTH         => C_M_AXIS_SG_TDATA_WIDTH      ,
                C_S_AXIS_UPDPTR_TDATA_WIDTH     => C_S_AXIS_UPDPTR_TDATA_WIDTH  ,
                C_S_AXIS_UPDSTS_TDATA_WIDTH     => C_S_AXIS_UPDSTS_TDATA_WIDTH  ,
                C_M_AXI_SG_ADDR_WIDTH           => C_M_AXI_SG_ADDR_WIDTH        ,
                C_M_AXI_MM2S_ADDR_WIDTH         => C_M_AXI_MM2S_ADDR_WIDTH      ,
                C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH => C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH,      
                C_MAX_CHANNELS                  => C_MAX_CHANNELS,
                C_FAMILY                        => C_FAMILY
            )
            port map(

                m_axi_sg_aclk                   => m_axi_sg_aclk                ,
                m_axi_sg_aresetn                => m_axi_sg_aresetn             ,

                -- SG MM2S Descriptor Fetch AXI Stream In
                m_axis_mm2s_ftch_tdata          => m_axis_mm2s_ftch_tdata       ,
                m_axis_mm2s_ftch_tvalid         => m_axis_mm2s_ftch_tvalid      ,
                m_axis_mm2s_ftch_tready         => m_axis_mm2s_ftch_tready      ,
                m_axis_mm2s_ftch_tlast          => m_axis_mm2s_ftch_tlast       ,
                m_axis_mm2s_ftch_data_valid     => m_axis_mm2s_ftch_data_valid  , 
                m_axis_mm2s_ftch_id             => m_axis_mm2s_ftch_id,

                -- SG MM2S Descriptor Update AXI Stream Out
                s_axis_mm2s_updtptr_tdata       => s_axis_mm2s_updtptr_tdata    ,
                s_axis_mm2s_updtptr_tvalid      => s_axis_mm2s_updtptr_tvalid   ,
                s_axis_mm2s_updtptr_tready      => s_axis_mm2s_updtptr_tready   ,
                s_axis_mm2s_updtptr_tlast       => s_axis_mm2s_updtptr_tlast    ,

                s_axis_mm2s_updtsts_tdata       => s_axis_mm2s_updtsts_tdata    ,
                s_axis_mm2s_updtsts_tvalid      => s_axis_mm2s_updtsts_tvalid   ,
                s_axis_mm2s_updtsts_tready      => s_axis_mm2s_updtsts_tready   ,
                s_axis_mm2s_updtsts_tlast       => s_axis_mm2s_updtsts_tlast    ,
                s_axis_mm2s_updtsts_id      => s_axis_mm2s_updtsts_id           ,


                -- MM2S Descriptor Fetch Request (from mm2s_sm)
                desc_available                  => desc_available               ,
                desc_fetch_req                  => desc_fetch_req               ,
                desc_fetch_done                 => desc_fetch_done              ,
                packet_in_progress              => packet_in_progress           ,

                -- MM2S Descriptor Update Request
                desc_update_done                => desc_update_done             ,

                mm2s_ftch_stale_desc            => mm2s_ftch_stale_desc         ,
                mm2s_sts_received_clr           => mm2s_sts_received_clr        ,
                mm2s_sts_received               => mm2s_sts_received            ,
                mm2s_desc_cmplt                 => mm2s_desc_cmplt              ,
                mm2s_done                       => mm2s_done                    ,
                mm2s_interr                     => mm2s_interr                  ,
                mm2s_slverr                     => mm2s_slverr                  ,
                mm2s_decerr                     => mm2s_decerr                  ,
                mm2s_tag                        => mm2s_tag                     ,
                mm2s_halt                       => mm2s_halt                    , -- CR566306

                -- Control Stream Output
                cntrlstrm_fifo_wren             => cntrlstrm_fifo_wren          ,
                cntrlstrm_fifo_full             => cntrlstrm_fifo_full          ,
                cntrlstrm_fifo_din              => cntrlstrm_fifo_din           ,
           
                tuser_tid_data                  => mm2s_tuser_tid,
                tuser_wr_en                     => open,


                -- MM2S Descriptor Field Output
                mm2s_new_curdesc                => mm2s_new_curdesc             ,
                mm2s_new_curdesc_wren           => mm2s_new_curdesc_wren_i        ,
                mm2s_channel_id_reg_update      => mm2s_channel_id_reg_update,
                mm2s_desc_baddress              => mm2s_desc_baddress           ,
                mm2s_desc_blength               => mm2s_desc_blength            ,
                mm2s_desc_eof                   => mm2s_desc_eof                ,
                mm2s_desc_sof                   => mm2s_desc_sof                ,
                mm2s_desc_app0                  => mm2s_desc_app0               ,
                mm2s_desc_app1                  => mm2s_desc_app1               ,
                mm2s_desc_app2                  => mm2s_desc_app2               ,
                mm2s_desc_app3                  => mm2s_desc_app3               ,
                mm2s_desc_app4                  => mm2s_desc_app4
            );
    end generate GEN_SCATTER_GATHER_MODE;
    
GEN_NO_SCATTER_GATHER_MODE : if C_INCLUDE_SG = 0 generate
    begin
	mm2s_cmnd_wr <= '0';
	mm2s_desc_cmplt <= '0';
	mm2s_sts_received_clr <=  '0';
	mm2s_cmnd_data <=(others => '0');
	mm2s_cmnd_idle <=  '0';
	mm2s_sts_idle <=  '0';
	mm2s_new_curdesc_wren_i <= '0';
	mm2s_channel_id_reg_update <=(others => '0');
	tdest_out <= (others => '0');
	channel_id <= (others => '0');
    end generate GEN_NO_SCATTER_GATHER_MODE;


    -------------------------------------------------------------------------------
    -- MM2S Primary DataMover command status interface
    -------------------------------------------------------------------------------
    I_MM2S_CMDSTS : entity  axi_mcdma_v1_1_8.axi_mcdma_mm2s_cmdsts_if
        generic map(
            C_M_AXI_MM2S_ADDR_WIDTH         => C_M_AXI_MM2S_ADDR_WIDTH
        )
        port map(
            m_axi_sg_aclk                   => m_axi_sg_aclk                ,
            m_axi_sg_aresetn                => m_axi_sg_aresetn             ,

            -- Fetch command write interface from mm2s sm
            mm2s_cmnd_wr                    => mm2s_cmnd_wr                 ,
            mm2s_cmnd_data                  => mm2s_cmnd_data               ,
            mm2s_cmnd_pending               => mm2s_cmnd_pending            ,

            mm2s_sts_received_clr           => mm2s_sts_received_clr        ,
            mm2s_sts_received               => mm2s_sts_received            ,
            mm2s_tailpntr_enble             => mm2s_tailpntr_enble          ,
            mm2s_desc_cmplt                 => mm2s_desc_cmplt              ,

            -- User Command Interface Ports (AXI Stream)
            s_axis_mm2s_cmd_tvalid          => s_axis_mm2s_cmd_tvalid       ,
            s_axis_mm2s_cmd_tready          => s_axis_mm2s_cmd_tready       ,
            s_axis_mm2s_cmd_tdata           => s_axis_mm2s_cmd_tdata        ,

            -- User Status Interface Ports (AXI Stream)
            m_axis_mm2s_sts_tvalid          => m_axis_mm2s_sts_tvalid       ,
            m_axis_mm2s_sts_tready          => m_axis_mm2s_sts_tready       ,
            m_axis_mm2s_sts_tdata           => m_axis_mm2s_sts_tdata        ,
            m_axis_mm2s_sts_tkeep           => m_axis_mm2s_sts_tkeep        ,

            -- MM2S Primary DataMover Status
            mm2s_err                        => mm2s_err                     ,
            mm2s_done                       => mm2s_done                    ,
            mm2s_error                      => dma_mm2s_error               ,
            mm2s_interr                     => mm2s_interr                  ,
            mm2s_slverr                     => mm2s_slverr                  ,
            mm2s_decerr                     => mm2s_decerr                  ,
            mm2s_tag                        => mm2s_tag
        );

    ---------------------------------------------------------------------------
    -- Halt / Idle Status Manager
    ---------------------------------------------------------------------------
    I_MM2S_STS_MNGR : entity  axi_mcdma_v1_1_8.axi_mcdma_mm2s_sts_mngr
        generic map(
            C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC
        )
        port map(
            m_axi_sg_aclk               => m_axi_sg_aclk                    ,
            m_axi_sg_aresetn            => m_axi_sg_aresetn                 ,

            -- dma control and sg engine status signals
            mm2s_run_stop               => mm2s_run_stop                    ,
            mm2s_ftch_idle              => mm2s_ftch_idle                   ,
            mm2s_updt_idle              => mm2s_updt_idle                   ,
            mm2s_cmnd_idle              => mm2s_cmnd_idle                   ,
            mm2s_sts_idle               => mm2s_sts_idle                    ,

            -- stop and halt control/status
            mm2s_stop                   => mm2s_stop_i                      ,
            mm2s_halt_cmplt             => mm2s_halt_cmplt                  ,

            -- system state and control
            mm2s_all_idle               => mm2s_all_idle                    ,
            mm2s_halted_clr             => mm2s_halted_clr                  ,
            mm2s_halted_set             => mm2s_halted_set_i                ,
            mm2s_idle_set               => mm2s_idle_set                    ,
            mm2s_idle_clr               => mm2s_idle_clr
        );


    -- MM2S Control Stream Included
    GEN_CNTRL_STREAM : if C_SG_INCLUDE_STSCNTRL_STRM = 1 and C_INCLUDE_SG = 1 generate
    begin

        -- Register soft reset to create rising edge pulse to use for shut down.
        -- soft_reset from DMACR does not clear until after all reset processes
        -- are done.  This causes stop to assert too long causing issue with
        -- status stream skid buffer.
        REG_SFT_RST : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0')then
                        soft_reset_d1 <= '0';
                        soft_reset_d2 <= '0';
                    else
                        soft_reset_d1 <= soft_reset;
                        soft_reset_d2 <= soft_reset_d1;
                    end if;
                end if;
            end process REG_SFT_RST;

        -- Rising edge soft reset pulse
        soft_reset_re <= soft_reset_d1 and not soft_reset_d2;

        -- Control Stream module stop requires rising edge of soft reset to
        -- shut down due to DMACR.SoftReset does not deassert on internal hard reset
        -- It clears after therefore do not want to issue another stop to cntrl strm
        -- skid buffer.
        cntrl_strm_stop <= mm2s_error_i             -- Error
                        or soft_reset_re;           -- Soft Reset issued

        -- Control stream interface
        I_MM2S_CNTRL_STREAM : entity axi_mcdma_v1_1_8.axi_mcdma_mm2s_cntrl_strm
            generic map(
                C_PRMRY_IS_ACLK_ASYNC           => C_PRMRY_IS_ACLK_ASYNC            ,
                C_PRMY_CMDFIFO_DEPTH            => C_PRMY_CMDFIFO_DEPTH+1             ,
                C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH => C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH  ,
                C_FAMILY                        => C_FAMILY
            )
            port map(
                -- Secondary clock / reset
                m_axi_sg_aclk               => m_axi_sg_aclk                ,
                m_axi_sg_aresetn            => m_axi_sg_aresetn             ,

                -- Primary clock / reset
                axi_prmry_aclk              => axi_prmry_aclk               ,
                p_reset_n                   => p_reset_n                    ,

                -- MM2S Error
                mm2s_stop                   => cntrl_strm_stop              ,

                -- Control Stream input
                cntrlstrm_fifo_wren         => cntrlstrm_fifo_wren          ,
                cntrlstrm_fifo_full         => cntrlstrm_fifo_full          ,
                cntrlstrm_fifo_din          => cntrlstrm_fifo_din           ,

                -- Memory Map to Stream Control Stream Interface
                m_axis_mm2s_cntrl_tdata     => m_axis_mm2s_cntrl_tdata      ,
                m_axis_mm2s_cntrl_tkeep     => m_axis_mm2s_cntrl_tkeep      ,
                m_axis_mm2s_cntrl_tvalid    => m_axis_mm2s_cntrl_tvalid     ,
                m_axis_mm2s_cntrl_tready    => m_axis_mm2s_cntrl_tready     ,
                m_axis_mm2s_cntrl_tlast     => m_axis_mm2s_cntrl_tlast

            );
    end generate GEN_CNTRL_STREAM;


    -- MM2S Control Stream Excluded
    GEN_NO_CNTRL_STREAM : if C_SG_INCLUDE_STSCNTRL_STRM = 0 or C_INCLUDE_SG = 0 generate
    begin
        soft_reset_d1               <= '0';
        soft_reset_d2               <= '0';
        soft_reset_re               <= '0';
        cntrl_strm_stop             <= '0';
        cntrlstrm_fifo_full         <= '1';
        m_axis_mm2s_cntrl_tdata     <= (others => '0');
        m_axis_mm2s_cntrl_tkeep     <= (others => '0');
        m_axis_mm2s_cntrl_tvalid    <= '0';
        m_axis_mm2s_cntrl_tlast     <= '0';

    end generate GEN_NO_CNTRL_STREAM;

end generate GEN_MM2S_DMA_CONTROL;


-------------------------------------------------------------------------------
-- Exclude MM2S State Machine and support logic
-------------------------------------------------------------------------------
GEN_NO_MM2S_DMA_CONTROL : if C_INCLUDE_MM2S = 0 generate
begin
        m_axis_mm2s_ftch_tready     <= '0';
        s_axis_mm2s_updtptr_tdata   <= (others =>'0');
        s_axis_mm2s_updtptr_tvalid  <= '0';
        s_axis_mm2s_updtptr_tlast   <= '0';
        s_axis_mm2s_updtsts_tdata   <= (others =>'0');
        s_axis_mm2s_updtsts_tvalid  <= '0';
        s_axis_mm2s_updtsts_tlast   <= '0';
        mm2s_new_curdesc            <= (others =>'0');
        mm2s_new_curdesc_wren       <= '0';
        s_axis_mm2s_cmd_tvalid      <= '0';
        s_axis_mm2s_cmd_tdata       <= (others =>'0');
        m_axis_mm2s_sts_tready      <= '0';
        mm2s_halted_clr             <= '0';
        mm2s_halted_set             <= '0';
        mm2s_idle_set               <= '0';
        mm2s_idle_clr               <= '0';
        m_axis_mm2s_cntrl_tdata     <= (others => '0');
        m_axis_mm2s_cntrl_tkeep     <= (others => '0');
        m_axis_mm2s_cntrl_tvalid    <= '0';
        m_axis_mm2s_cntrl_tlast     <= '0';
        mm2s_stop                   <= '0';
        mm2s_desc_flush             <= '0';
        mm2s_all_idle               <= '1';
        mm2s_error                  <= '0'; -- CR#570587
        mm2s_interr_set             <= '0';
        mm2s_slverr_set             <= '0';
        mm2s_decerr_set             <= '0';
        mm2s_smple_done             <= '0';

end generate GEN_NO_MM2S_DMA_CONTROL;

end implementation;



  -------------------------------------------------------------------------------
  -- axi_mcdma_stbs_set.vhd
  -------------------------------------------------------------------------------
  --
  -- *************************************************************************
  --                                                                      
--  (c) Copyright 2010-2011 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
  --
  -- *************************************************************************
  --
  -------------------------------------------------------------------------------
  -- Filename:        axi_mcdma_stbs_set.vhd
  --
  -- Description:     
  --    This file implements a module to count the number of strobe bits that 
  --    are asserted active high on the input strobe bus. This module does not
  --    support sparse strobe assertions.              
  --                  
  -- VHDL-Standard:   VHDL'93
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;
  


  
  -------------------------------------------------------------------------------
  
  entity axi_mcdma_stbs_set is
    generic (
      
      C_STROBE_WIDTH    : Integer range 1 to 128 := 8
        -- Specifies the width (in bits) of the input strobe bus.
      
      );
    port (
      
      -- Input Strobe bus ----------------------------------------------------
                                                                            --
      tstrb_in          : in  std_logic_vector(C_STROBE_WIDTH-1 downto 0);  --
      ------------------------------------------------------------------------
      
      
      -- Asserted Strobes count output ---------------------------------------
                                                                            --
      num_stbs_asserted : Out std_logic_vector(7 downto 0)                  --
        -- Indicates the number of asserted tstrb_in bits                   --
      ------------------------------------------------------------------------
     
      );
  
  end entity axi_mcdma_stbs_set;
  
  
  architecture implementation of axi_mcdma_stbs_set is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";

  
    
    -- Function
    -------------------------------------------------------------------
    -- Function
    --
    -- Function Name: funct_8bit_stbs_set
    --
    -- Function Description:
    --  Implements an 8-bit lookup table for calculating the number
    -- of asserted bits within an 8-bit strobe vector.
    --
    -- Note that this function assumes that asserted strobes are 
    -- contiguous with each other (no sparse strobe assertions). 
    --
    -------------------------------------------------------------------
    function funct_8bit_stbs_set (strb_8 : std_logic_vector(7 downto 0)) return unsigned is
    
      Constant ASSERTED_VALUE_WIDTH : integer := 4;-- 4 bits needed
      
      
      Variable lvar_num_set : Integer range 0 to 8 := 0;
    
    begin
    
      case strb_8 is
        
        -------  1 bit --------------------------
        when "00000001" | "00000010" | "00000100" | "00001000" | 
             "00010000" | "00100000" | "01000000" | "10000000" =>
        
          lvar_num_set := 1;
        
        
        -------  2 bit --------------------------
        when "00000011" | "00000110" | "00001100" | "00011000" | 
             "00110000" | "01100000" | "11000000"  =>
        
          lvar_num_set := 2;
        
        
        -------  3 bit --------------------------
        when "00000111" | "00001110" | "00011100" | "00111000" | 
             "01110000" | "11100000"   =>
        
          lvar_num_set := 3;
        
        
        -------  4 bit --------------------------
        when "00001111" | "00011110" | "00111100" | "01111000" | 
             "11110000"    =>
        
          lvar_num_set := 4;
        
        
        -------  5 bit --------------------------
        when "00011111" | "00111110" | "01111100" | "11111000"  =>
        
          lvar_num_set := 5;
        
        
        -------  6 bit --------------------------
        when "00111111" | "01111110" | "11111100"  =>
        
          lvar_num_set := 6;
        
        
        -------  7 bit --------------------------
        when "01111111" | "11111110"   =>
        
          lvar_num_set := 7;
        
        
        -------  8 bit --------------------------
        when "11111111"    =>
        
          lvar_num_set := 8;
        
        
        ------- all zeros or sparse strobes ------
        When others =>  
        
          lvar_num_set := 0;
        
      end case;
      
      
      Return (TO_UNSIGNED(lvar_num_set, ASSERTED_VALUE_WIDTH));
       
       
      
    end function funct_8bit_stbs_set;
    
    
    
    
    
    
    -- Constants
    
    Constant LOGIC_LOW              : std_logic := '0';
    Constant LOGIC_HIGH             : std_logic := '1';
    Constant BITS_FOR_STBS_ASSERTED : integer := 8; -- increments of 8 bits
    Constant NUM_ZEROS_WIDTH        : integer := BITS_FOR_STBS_ASSERTED;
    
    
    -- Signals
    
    signal sig_strb_input           : std_logic_vector(C_STROBE_WIDTH-1 downto 0) := (others => '0');
    signal sig_stbs_asserted        : std_logic_vector(BITS_FOR_STBS_ASSERTED-1 downto 0) := (others => '0');


    
    
  begin --(architecture implementation)
  
   
   num_stbs_asserted     <= sig_stbs_asserted;
   
   sig_strb_input        <= tstrb_in         ;
    
    
    
    
 
 
    -------------------------------------------------------------------------
    ----------------  Asserted TSTRB calculation logic  --------------------- 
    -------------------------------------------------------------------------
    
    
 
   
     
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_1_STRB
     --
     -- If Generate Description:
     --   1-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_1_STRB : if (C_STROBE_WIDTH = 1) generate
     
     
        begin
     
          -------------------------------------------------------------
          -- Combinational Process
          --
          -- Label: IMP_1BIT_STRB
          --
          -- Process Description:
          --
          --
          -------------------------------------------------------------
          IMP_1BIT_STRB : process (sig_strb_input)
             begin
          
               
               -- Concatonate the strobe to the ls bit of
               -- the asserted value
               sig_stbs_asserted <= "0000000" &
                                    sig_strb_input(0);
          
             end process IMP_1BIT_STRB; 
        
        end generate GEN_1_STRB;
   
   
   
   
   
   
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_2_STRB
     --
     -- If Generate Description:
     --   2-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_2_STRB : if (C_STROBE_WIDTH = 2) generate
     
     
        signal lsig_num_set     : integer range 0 to 2 := 0;
        signal lsig_strb_vect   : std_logic_vector(1 downto 0) := (others => '0');
        
        begin
     
          
          lsig_strb_vect <=  sig_strb_input;
          
          
          -------------------------------------------------------------
          -- Combinational Process
          --
          -- Label: IMP_2BIT_STRB
          --
          -- Process Description:
          --  Calculates the number of strobes set fo the 2-bit 
          -- strobe case
          --
          -------------------------------------------------------------
          IMP_2BIT_STRB : process (lsig_strb_vect)
             begin
              
               case lsig_strb_vect is
                 when "01" | "10" =>
                   lsig_num_set <= 1;
                 when "11" =>
                   lsig_num_set <= 2;
          -- coverage off
                 when others =>
                   lsig_num_set <= 0;
          -- coverage on
               end case;
               
             end process IMP_2BIT_STRB; 
             
          
          sig_stbs_asserted <= STD_LOGIC_VECTOR(TO_UNSIGNED(lsig_num_set,
                                                            BITS_FOR_STBS_ASSERTED));
     
        
        end generate GEN_2_STRB;
   
   
   
   
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_4_STRB
     --
     -- If Generate Description:
     --   4-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_4_STRB : if (C_STROBE_WIDTH = 4) generate
     
     
       signal lsig_strb_vect   : std_logic_vector(7 downto 0) := (others => '0');
        
       begin
     
          
         lsig_strb_vect <=  "0000" & sig_strb_input; -- make and 8-bit vector 
                                                     -- for the function call
          
          
         sig_stbs_asserted <= STD_LOGIC_VECTOR(RESIZE(funct_8bit_stbs_set(lsig_strb_vect),
                                                      BITS_FOR_STBS_ASSERTED));
     
     
       end generate GEN_4_STRB;
   
   
  
  
   
   
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_8_STRB
     --
     -- If Generate Description:
     --   8-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_8_STRB : if (C_STROBE_WIDTH = 8) generate
     
     
       signal lsig_strb_vect   : std_logic_vector(7 downto 0) := (others => '0');
        
       begin
     
          
         lsig_strb_vect <=  sig_strb_input; -- make and 8-bit vector 
                                            -- for the function call
          
          
         sig_stbs_asserted <= STD_LOGIC_VECTOR(RESIZE(funct_8bit_stbs_set(lsig_strb_vect),
                                                           BITS_FOR_STBS_ASSERTED));
     
     
       end generate GEN_8_STRB;
   
   
   
   
   
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_16_STRB
     --
     -- If Generate Description:
     --   16-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_16_STRB : if (C_STROBE_WIDTH = 16) generate
     
       Constant RESULT_BIT_WIDTH : integer := 8;
       
       signal lsig_strb_vect1    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect2    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_num_in_stbs1  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs2  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_total     : unsigned(RESULT_BIT_WIDTH-1 downto 0) := (others => '0');
        
       begin
     
          
         lsig_strb_vect1   <=  sig_strb_input(7 downto 0); -- make and 8-bit vector 
                                                           -- for the function call
          
         lsig_strb_vect2   <=  sig_strb_input(15 downto 8); -- make and 8-bit vector 
                                                            -- for the function call
          
          
         lsig_num_in_stbs1 <=  funct_8bit_stbs_set(lsig_strb_vect1) ;
          
         lsig_num_in_stbs2 <=  funct_8bit_stbs_set(lsig_strb_vect2) ;
          
          
         lsig_num_total    <= RESIZE(lsig_num_in_stbs1 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs2 , RESULT_BIT_WIDTH);
          
          
          
         sig_stbs_asserted <= STD_LOGIC_VECTOR(lsig_num_total);
     
     
       end generate GEN_16_STRB;
   
   
   
   
   
   
   
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_32_STRB
     --
     -- If Generate Description:
     --   32-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_32_STRB : if (C_STROBE_WIDTH = 32) generate
     
       Constant RESULT_BIT_WIDTH : integer := 8;
       
       signal lsig_strb_vect1   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect2   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect3   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect4   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_num_in_stbs1 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs2 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs3 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs4 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_total    : unsigned(RESULT_BIT_WIDTH-1 downto 0) := (others => '0');
        
       begin
     
          
         lsig_strb_vect1   <=  sig_strb_input(7 downto 0);   -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect2   <=  sig_strb_input(15 downto 8);  -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect3   <=  sig_strb_input(23 downto 16); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect4   <=  sig_strb_input(31 downto 24); -- make and 8-bit vector 
                                                       -- for the function call
          
          
         lsig_num_in_stbs1 <=  funct_8bit_stbs_set(lsig_strb_vect1) ;
          
         lsig_num_in_stbs2 <=  funct_8bit_stbs_set(lsig_strb_vect2) ;
         
         lsig_num_in_stbs3 <=  funct_8bit_stbs_set(lsig_strb_vect3) ;
         
         lsig_num_in_stbs4 <=  funct_8bit_stbs_set(lsig_strb_vect4) ;
          
          
         lsig_num_total    <= RESIZE(lsig_num_in_stbs1 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs2 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs3 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs4 , RESULT_BIT_WIDTH);
          
          
          
         sig_stbs_asserted <= STD_LOGIC_VECTOR(lsig_num_total);
     
     
       end generate GEN_32_STRB;
   
   
   
 
 
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_64_STRB
     --
     -- If Generate Description:
     --   64-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_64_STRB : if (C_STROBE_WIDTH = 64) generate
     
       Constant RESULT_BIT_WIDTH : integer := 8;
       
       signal lsig_strb_vect1   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect2   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect3   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect4   : std_logic_vector(7 downto 0) := (others => '0');
       
       signal lsig_strb_vect5   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect6   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect7   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect8   : std_logic_vector(7 downto 0) := (others => '0');
       
       
       
       signal lsig_num_in_stbs1 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs2 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs3 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs4 : unsigned(3 downto 0) := (others => '0');
       
       signal lsig_num_in_stbs5 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs6 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs7 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs8 : unsigned(3 downto 0) := (others => '0');
       
       signal lsig_num_total    : unsigned(RESULT_BIT_WIDTH-1 downto 0) := (others => '0');
        
       begin
     
          
         lsig_strb_vect1   <=  sig_strb_input(7 downto 0);   -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect2   <=  sig_strb_input(15 downto 8);  -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect3   <=  sig_strb_input(23 downto 16); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect4   <=  sig_strb_input(31 downto 24); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect5   <=  sig_strb_input(39 downto 32);   -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect6   <=  sig_strb_input(47 downto 40);  -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect7   <=  sig_strb_input(55 downto 48); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect8   <=  sig_strb_input(63 downto 56); -- make and 8-bit vector 
                                                       -- for the function call
          
          
          
         lsig_num_in_stbs1 <=  funct_8bit_stbs_set(lsig_strb_vect1) ;
          
         lsig_num_in_stbs2 <=  funct_8bit_stbs_set(lsig_strb_vect2) ;
         
         lsig_num_in_stbs3 <=  funct_8bit_stbs_set(lsig_strb_vect3) ;
         
         lsig_num_in_stbs4 <=  funct_8bit_stbs_set(lsig_strb_vect4) ;
   
   
         lsig_num_in_stbs5 <=  funct_8bit_stbs_set(lsig_strb_vect5) ;
   
         lsig_num_in_stbs6 <=  funct_8bit_stbs_set(lsig_strb_vect6) ;
   
         lsig_num_in_stbs7 <=  funct_8bit_stbs_set(lsig_strb_vect7) ;
   
         lsig_num_in_stbs8 <=  funct_8bit_stbs_set(lsig_strb_vect8) ;
   
          
          
         lsig_num_total    <= RESIZE(lsig_num_in_stbs1 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs2 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs3 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs4 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs5 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs6 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs7 , RESULT_BIT_WIDTH) +
                              RESIZE(lsig_num_in_stbs8 , RESULT_BIT_WIDTH);
          
          
          
         sig_stbs_asserted <= STD_LOGIC_VECTOR(lsig_num_total);
     
     
       end generate GEN_64_STRB;
   
   
   
 
     ------------------------------------------------------------
     -- If Generate
     --
     -- Label: GEN_128_STRB
     --
     -- If Generate Description:
     --   128-bit strobe bus width case
     --
     --
     ------------------------------------------------------------
     GEN_128_STRB : if (C_STROBE_WIDTH = 128) generate
     
       Constant RESULT_BIT_WIDTH : integer := 8;
       
       signal lsig_strb_vect1    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect2    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect3    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect4    : std_logic_vector(7 downto 0) := (others => '0');
       
       signal lsig_strb_vect5    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect6    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect7    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect8    : std_logic_vector(7 downto 0) := (others => '0');
       
       signal lsig_strb_vect9    : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect10   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect11   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect12   : std_logic_vector(7 downto 0) := (others => '0');
       
       signal lsig_strb_vect13   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect14   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect15   : std_logic_vector(7 downto 0) := (others => '0');
       signal lsig_strb_vect16   : std_logic_vector(7 downto 0) := (others => '0');
       
       
       
       signal lsig_num_in_stbs1  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs2  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs3  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs4  : unsigned(3 downto 0) := (others => '0');
       
       signal lsig_num_in_stbs5  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs6  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs7  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs8  : unsigned(3 downto 0) := (others => '0');
       
       signal lsig_num_in_stbs9  : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs10 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs11 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs12 : unsigned(3 downto 0) := (others => '0');
       
       signal lsig_num_in_stbs13 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs14 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs15 : unsigned(3 downto 0) := (others => '0');
       signal lsig_num_in_stbs16 : unsigned(3 downto 0) := (others => '0');
       
       signal lsig_num_total     : unsigned(RESULT_BIT_WIDTH-1 downto 0) := (others => '0');
        
       begin
     
          
         lsig_strb_vect1   <=  sig_strb_input(7 downto 0);   -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect2   <=  sig_strb_input(15 downto 8);  -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect3   <=  sig_strb_input(23 downto 16); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect4   <=  sig_strb_input(31 downto 24); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect5   <=  sig_strb_input(39 downto 32);   -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect6   <=  sig_strb_input(47 downto 40);  -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect7   <=  sig_strb_input(55 downto 48); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect8   <=  sig_strb_input(63 downto 56); -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect9   <=  sig_strb_input(71 downto 64);   -- make and 8-bit vector 
                                                       -- for the function call
          
         lsig_strb_vect10  <=  sig_strb_input(79 downto 72);  -- make and 8-bit vector 
                                                      -- for the function call
          
         lsig_strb_vect11  <=  sig_strb_input(87 downto 80); -- make and 8-bit vector 
                                                      -- for the function call
          
         lsig_strb_vect12  <=  sig_strb_input(95 downto 88); -- make and 8-bit vector 
                                                      -- for the function call
          
         lsig_strb_vect13  <=  sig_strb_input(103 downto 96);   -- make and 8-bit vector 
                                                      -- for the function call
          
         lsig_strb_vect14  <=  sig_strb_input(111 downto 104);  -- make and 8-bit vector 
                                                      -- for the function call
          
         lsig_strb_vect15  <=  sig_strb_input(119 downto 112); -- make and 8-bit vector 
                                                      -- for the function call
          
         lsig_strb_vect16  <=  sig_strb_input(127 downto 120); -- make and 8-bit vector 
                                                       -- for the function call
          
          
          
         lsig_num_in_stbs1  <=  funct_8bit_stbs_set(lsig_strb_vect1) ;
          
         lsig_num_in_stbs2  <=  funct_8bit_stbs_set(lsig_strb_vect2) ;
         
         lsig_num_in_stbs3  <=  funct_8bit_stbs_set(lsig_strb_vect3) ;
         
         lsig_num_in_stbs4  <=  funct_8bit_stbs_set(lsig_strb_vect4) ;
   
   
         lsig_num_in_stbs5  <=  funct_8bit_stbs_set(lsig_strb_vect5) ;
   
         lsig_num_in_stbs6  <=  funct_8bit_stbs_set(lsig_strb_vect6) ;
   
         lsig_num_in_stbs7  <=  funct_8bit_stbs_set(lsig_strb_vect7) ;
   
         lsig_num_in_stbs8  <=  funct_8bit_stbs_set(lsig_strb_vect8) ;
         
   
         lsig_num_in_stbs9  <=  funct_8bit_stbs_set(lsig_strb_vect9) ;
          
         lsig_num_in_stbs10 <=  funct_8bit_stbs_set(lsig_strb_vect10) ;
         
         lsig_num_in_stbs11 <=  funct_8bit_stbs_set(lsig_strb_vect11) ;
         
         lsig_num_in_stbs12 <=  funct_8bit_stbs_set(lsig_strb_vect12) ;
   
   
         lsig_num_in_stbs13 <=  funct_8bit_stbs_set(lsig_strb_vect13) ;
   
         lsig_num_in_stbs14 <=  funct_8bit_stbs_set(lsig_strb_vect14) ;
   
         lsig_num_in_stbs15 <=  funct_8bit_stbs_set(lsig_strb_vect15) ;
   
         lsig_num_in_stbs16 <=  funct_8bit_stbs_set(lsig_strb_vect16) ;
   
          
          
         lsig_num_total     <= RESIZE(lsig_num_in_stbs1  , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs2  , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs3  , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs4  , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs5  , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs6  , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs7  , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs8  , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs9  , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs10 , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs11 , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs12 , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs13 , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs14 , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs15 , RESULT_BIT_WIDTH) +
                               RESIZE(lsig_num_in_stbs16 , RESULT_BIT_WIDTH);
          
          
          
         sig_stbs_asserted  <= STD_LOGIC_VECTOR(lsig_num_total);
     
     
       end generate GEN_128_STRB;
   
  
  
  end implementation;


-------------------------------------------------------------------------------
-- axi_mcdma_s2mm_sg_if
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_mcdma_s2mm_sg_if.vhd
-- Description: This entity is the S2MM Scatter Gather Interface for Descriptor
--              Fetches and Updates.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

library lib_srl_fifo_v1_0_2;
use lib_srl_fifo_v1_0_2.srl_fifo_f;

library lib_cdc_v1_0_2;

-------------------------------------------------------------------------------
entity  axi_mcdma_s2mm_sg_if is
    generic (
        C_PRMRY_IS_ACLK_ASYNC        : integer range 0 to 1          := 0       ;
            -- Primary MM2S/S2MM sync/async mode
            -- 0 = synchronous mode     - all clocks are synchronous
            -- 1 = asynchronous mode    - Any one of the 4 clock inputs is not
            --                            synchronous to the other
        -----------------------------------------------------------------------
        -- Scatter Gather Parameters
        -----------------------------------------------------------------------
        C_SG_INCLUDE_STSCNTRL_STRM      : integer range 0 to 1          := 1    ;
            -- Include or Exclude AXI Status and AXI Control Streams
            -- 0 = Exclude Status and Control Streams
            -- 1 = Include Status and Control Streams

        C_SG_INCLUDE_DESC_QUEUE         : integer range 0 to 1          := 0    ;
            -- Include or Exclude Scatter Gather Descriptor Queuing
            -- 0 = Exclude SG Descriptor Queuing
            -- 1 = Include SG Descriptor Queuing

        C_SG_USE_STSAPP_LENGTH      : integer range 0 to 1          := 1;
            -- Enable or Disable use of Status Stream Rx Length.  Only valid
            -- if C_SG_INCLUDE_STSCNTRL_STRM = 1
            -- 0 = Don't use Rx Length
            -- 1 = Use Rx Length

        C_SG_LENGTH_WIDTH               : integer range 8 to 26         := 14   ;
            -- Descriptor Buffer Length, Transferred Bytes, and Status Stream
            -- Rx Length Width.  Indicates the least significant valid bits of
            -- descriptor buffer length, transferred bytes, or Rx Length value
            -- in the status word coincident with tlast.

        C_M_AXIS_SG_TDATA_WIDTH          : integer range 32 to 32        := 32  ;
            -- AXI Master Stream in for descriptor fetch

        C_S_AXIS_UPDPTR_TDATA_WIDTH : integer range 32 to 64            := 32   ;
            -- 32 Update Status Bits

        C_S_AXIS_UPDSTS_TDATA_WIDTH : integer range 33 to 33            := 33   ;
            -- 1 IOC bit + 32 Update Status Bits

        C_M_AXI_SG_ADDR_WIDTH           : integer range 32 to 64        := 32   ;
            -- Master AXI Memory Map Data Width for Scatter Gather R/W Port

        C_M_AXI_S2MM_ADDR_WIDTH         : integer range 32 to 64        := 32   ;
            -- Master AXI Memory Map Address Width for S2MM Write Port

        C_S_AXIS_S2MM_STS_TDATA_WIDTH   : integer range 32 to 32        := 32   ;
            -- Slave AXI Status Stream Data Width
        C_MAX_CHANNELS                  : integer range 1 to 16         := 1;

        C_FAMILY                        : string                        := "virtex5"
            -- Target FPGA Device Family
    );
    port (

        m_axi_sg_aclk               : in  std_logic                         ;                     --
        m_axi_sg_aresetn            : in  std_logic                         ;                     --
                                                                                                  --
        -- SG S2MM Descriptor Fetch AXI Stream In                                                 --
        m_axis_s2mm_ftch_tdata      : in  std_logic_vector                                        --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0);                     --
        m_axis_s2mm_ftch_tvalid     : in  std_logic                         ;                     --
        m_axis_s2mm_ftch_data_valid     : in  std_logic                         ;                     --
        m_axis_s2mm_ftch_tready     : out std_logic                         ;                     --
        m_axis_s2mm_ftch_tlast      : in  std_logic                         ;                     --
        m_axis_s2mm_ftch_id         : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                     --
                                                                                                  --
                                                                                                  --
        -- SG S2MM Descriptor Update AXI Stream Out                                               --
        s_axis_s2mm_updtptr_tdata   : out std_logic_vector                                        --
                                     (C_S_AXIS_UPDPTR_TDATA_WIDTH-1 downto 0) ;                   --
        s_axis_s2mm_updtptr_tvalid  : out std_logic                         ;                     --
        s_axis_s2mm_updtptr_tready  : in  std_logic                         ;                     --
        s_axis_s2mm_updtptr_tlast   : out std_logic                         ;                     --
                                                                                                  --
        s_axis_s2mm_updtsts_tdata   : out std_logic_vector                                        --
                                     (C_S_AXIS_UPDSTS_TDATA_WIDTH-1 downto 0)  ;                  --
        s_axis_s2mm_updtsts_tvalid  : out std_logic                         ;                     --
        s_axis_s2mm_updtsts_tready  : in  std_logic                         ;                     --
        s_axis_s2mm_updtsts_tlast   : out std_logic                         ;                     --
        s_axis_s2mm_updtsts_id      : out std_logic_vector (C_MAX_CHANNELS-1 downto 0);
                                                                                                  --
        -- S2MM Descriptor Fetch Request (from s2mm_sm)                                           --
        desc_available              : out std_logic                         ;                     --
        desc_fetch_req              : in  std_logic                         ;                     --
        desc_fetch_done             : out std_logic                         ;                     --
                                                                                                  --
        -- S2MM Descriptor Update Request (from s2mm_sm)                                          --
        desc_update_done            : out std_logic                         ;                     --
        s2mm_sts_received_clr       : out std_logic                         ;                     --
        s2mm_sts_received           : in  std_logic                         ;                     --
                                                                                                  --
        -- Scatter Gather Update Status                                                           --
        s2mm_done                   : in  std_logic                         ;                     --
        s2mm_interr                 : in  std_logic                         ;                     --
        s2mm_slverr                 : in  std_logic                         ;                     --
        s2mm_decerr                 : in  std_logic                         ;                     --
        s2mm_tag                    : in  std_logic_vector(3 downto 0)      ;                     --
        s2mm_brcvd                  : in  std_logic_vector                                        --
                                        (C_SG_LENGTH_WIDTH-1 downto 0)      ;                     --
        s2mm_sg_side_band           : in  std_logic_vector (31 downto 0)    ;
        s2mm_eof_set                : in  std_logic                         ;                     --
        s2mm_packet_eof             : in  std_logic                         ;                     --
        s2mm_halt                   : in  std_logic                         ;                     --
                                                                                                  --
        -- S2MM Status Stream Interface                                                           --
        stsstrm_fifo_rden           : out std_logic                         ;                     --
        stsstrm_fifo_empty          : in  std_logic                         ;                     --
        stsstrm_fifo_dout           : in  std_logic_vector                                        --
                                        (C_S_AXIS_S2MM_STS_TDATA_WIDTH downto 0);                 --
                                                                                                  --
        -- DataMover Command                                                                      --
        s2mm_cmnd_wr                : in  std_logic                         ;                     --
        s2mm_cmnd_data              : in  std_logic_vector                                        --
                                        ((C_M_AXI_S2MM_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);    --
                                                                                                  --
        -- S2MM Descriptor Field Output                                                           --
        s2mm_channel_id_reg_update  : out std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        s2mm_new_curdesc            : out std_logic_vector                                        --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                     --
        s2mm_new_curdesc_wren       : out std_logic                         ;                     --
                                                                                                  --
        s2mm_desc_baddress          : out std_logic_vector                                        --
                                        (C_M_AXI_S2MM_ADDR_WIDTH-1 downto 0);                     --
        s2mm_desc_blength           : out std_logic_vector                                        --
                                        (BUFFER_LENGTH_WIDTH-1 downto 0)  ;                       --
        s2mm_desc_cmplt             : out std_logic                         ;                     --
        s2mm_desc_app0              : out std_logic_vector                                        --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0)  ;                   --
        s2mm_desc_app1              : out std_logic_vector                                        --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0)  ;                   --
        s2mm_desc_app2              : out std_logic_vector                                        --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0)  ;                   --
        s2mm_desc_app3              : out std_logic_vector                                        --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0)  ;                   --
        s2mm_desc_app4              : out std_logic_vector                                        --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0)                      --
    );

end axi_mcdma_s2mm_sg_if;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_s2mm_sg_if is

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
-- Status reserved bits
constant RESERVED_STS           : std_logic_vector(2 downto 0)
                                    := (others => '0');
-- Zero value constant
constant ZERO_VALUE             : std_logic_vector(31 downto 0)
                                    := (others => '0');
-- Zero length constant
constant ZERO_LENGTH            : std_logic_vector(C_SG_LENGTH_WIDTH-1 downto 0)
                                    := (others => '0');

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal ftch_shftenbl            : std_logic := '0';
signal ftch_shftenbl1            : std_logic := '0';
signal ftch_shftenbl2            : std_logic := '0';

-- fetch descriptor holding registers
signal desc_reg12               : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg11               : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg10               : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg9                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg8                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg7                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg6                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg5                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg4                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg3                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg2                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg1                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal desc_reg0                : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');

signal s2mm_desc_curdesc_lsb    : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal s2mm_desc_curdesc_msb    : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal s2mm_desc_baddr_lsb      : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal s2mm_desc_baddr_msb      : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH - 1 downto 0) := (others => '0');
signal s2mm_pending_update      : std_logic := '0';
signal s2mm_new_curdesc_wren_i  : std_logic := '0';
signal s2mm_ioc                 : std_logic := '0';
signal s2mm_pending_pntr_updt   : std_logic := '0';

-- Descriptor Update Signals
signal s2mm_complete            : std_logic := '0';
signal s2mm_xferd_bytes         : std_logic_vector(BUFFER_LENGTH_WIDTH-1 downto 0)      := (others => '0');
signal s2mm_desc_blength_i      : std_logic_vector(BUFFER_LENGTH_WIDTH - 1 downto 0)    := (others => '0');

-- Signals for pointer support
-- Make 1 bit wider to allow tagging of LAST for use in generating tlast
signal updt_desc_reg0           : std_logic_vector(C_S_AXIS_UPDPTR_TDATA_WIDTH downto 0)     := (others => '0');
signal updt_desc_reg1           : std_logic_vector(C_S_AXIS_UPDPTR_TDATA_WIDTH downto 0)     := (others => '0');

signal updt_shftenbl            : std_logic := '0';

signal updtptr_tvalid           : std_logic := '0';
signal updtptr_tlast            : std_logic := '0';
signal updtptr_tdata            : std_logic_vector(C_S_AXIS_UPDPTR_TDATA_WIDTH-1 downto 0) := (others => '0');

-- Signals for Status Stream Support
signal updt_desc_sts            : std_logic_vector(C_S_AXIS_UPDSTS_TDATA_WIDTH downto 0)     := (others => '0');
signal updt_desc_sts_l            : std_logic_vector(C_S_AXIS_UPDSTS_TDATA_WIDTH downto 0)     := (others => '0');
signal updt_desc_reg3           : std_logic_vector(C_S_AXIS_UPDSTS_TDATA_WIDTH downto 0)     := (others => '0');
signal updt_zero_reg3           : std_logic_vector(C_S_AXIS_UPDSTS_TDATA_WIDTH downto 0)     := (others => '0');
signal updt_zero_reg4           : std_logic_vector(C_S_AXIS_UPDSTS_TDATA_WIDTH downto 0)     := (others => '0');
signal updt_zero_reg5           : std_logic_vector(C_S_AXIS_UPDSTS_TDATA_WIDTH downto 0)     := (others => '0');
signal updt_zero_reg6           : std_logic_vector(C_S_AXIS_UPDSTS_TDATA_WIDTH downto 0)     := (others => '0');
signal updt_zero_reg7           : std_logic_vector(C_S_AXIS_UPDSTS_TDATA_WIDTH downto 0)     := (others => '0');

signal writing_app_fields       : std_logic := '0';
signal stsstrm_fifo_rden_i      : std_logic := '0';

signal sts_shftenbl             : std_logic := '0';

signal sts_received             : std_logic := '0';
signal sts_received_d1          : std_logic := '0';
signal sts_received_re          : std_logic := '0';

-- Queued Update signals
signal updt_data_clr            : std_logic := '0';
signal updt_sts_clr             : std_logic := '0';
signal updt_data                : std_logic := '0';
signal updt_sts                 : std_logic := '0';

signal ioc_tag                  : std_logic := '0';
signal s2mm_sof_set             : std_logic := '0';
signal s2mm_in_progress         : std_logic := '0';
signal eof_received             : std_logic := '0';
signal sof_received             : std_logic := '0';

signal updtsts_tvalid           : std_logic := '0';
signal updtsts_tlast            : std_logic := '0';
signal updtsts_tdata            : std_logic_vector(C_S_AXIS_UPDSTS_TDATA_WIDTH-1 downto 0) := (others => '0');

signal s2mm_halt_d1             : std_logic := '0';
signal s2mm_halt_d2             : std_logic := '0';
signal channel_id               : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_packet_eof_del      : std_logic := '0';

signal read_count               : std_logic_vector (3 downto 0);
signal bmg_rd_en                : std_logic;
signal id_read_data             : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin
-- Drive buffer length out
s2mm_desc_blength <= s2mm_desc_blength_i;

-- Drive ready if descriptor fetch request is being made
-- this will go as rd_en to FIFO
m_axis_s2mm_ftch_tready     <= bmg_rd_en --desc_fetch_req                   -- Request descriptor fetch
                                and not s2mm_pending_update;    -- No pending pointer updates


-- Drive fetch request done on tlast
desc_fetch_done         <= m_axis_s2mm_ftch_tlast
                            and ftch_shftenbl;

-- Shift in data from SG engine if tvalid and fetch request
--ftch_shftenbl           <= m_axis_s2mm_ftch_tvalid
--                            and desc_fetch_req
--                            and not s2mm_pending_update;

ftch_shftenbl           <= m_axis_s2mm_ftch_data_valid
                            and not s2mm_pending_update;
D1ESC_WRD_PROCESS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0' or (m_axis_s2mm_ftch_tlast = '1' and ftch_shftenbl = '1'))then
               read_count <= "0000";
            elsif (desc_fetch_req = '1') then
               read_count <= std_logic_vector(unsigned(read_count(3 downto 0)) +1);
            end if;
         end if;
end process D1ESC_WRD_PROCESS; 


-- Passed curdes write out to register module
s2mm_new_curdesc_wren   <= s2mm_new_curdesc_wren_i;

-- tvalid asserted means descriptor availble
desc_available          <= m_axis_s2mm_ftch_tvalid and (not s2mm_pending_update); -- just a trigger to SM to fetch


--***************************************************************************--
--** Register DataMover Halt to secondary if needed
--***************************************************************************--
GEN_FOR_ASYNC : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
begin
    -- Double register to secondary clock domain.  This is sufficient
    -- because halt will remain asserted until halt_cmplt detected in
    -- reset module in secondary clock domain.
--    REG_TO_SECONDARY : process(m_axi_sg_aclk)
--        begin
--            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--                if(m_axi_sg_aresetn = '0')then
--                    s2mm_halt_d1 <= '0';
--                    s2mm_halt_d2 <= '0';
--                else
--                    s2mm_halt_d1 <= s2mm_halt;
--                    s2mm_halt_d2 <= s2mm_halt_d1;
--                end if;
--            end if;
--        end process REG_TO_SECONDARY;

REG_TO_SECONDARY : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => s2mm_halt,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => s2mm_halt_d2,
        scndry_vect_out            => open
    );



end generate GEN_FOR_ASYNC;

GEN_FOR_SYNC : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
begin
    -- No clock crossing required therefore simple pass through
    s2mm_halt_d2 <= s2mm_halt;

end generate GEN_FOR_SYNC;


--***************************************************************************--
--**                        Descriptor Fetch Logic                         **--
--***************************************************************************--

-------------------------------------------------------------------------------
-- Large shift register to bring in descriptor fields
-------------------------------------------------------------------------------
DESC_WRD_PROCESS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                desc_reg7     <= (others => '0');
                desc_reg6     <= (others => '0');
                desc_reg5     <= (others => '0');
                desc_reg4     <= (others => '0');
                desc_reg3     <= (others => '0');
                desc_reg2     <= (others => '0');
                desc_reg1     <= (others => '0');
                desc_reg0     <= (others => '0');
--                channel_id    <= (others => '0');
            -- Shift if enabled or if doing and overlay
            elsif(ftch_shftenbl = '1' and C_M_AXI_S2MM_ADDR_WIDTH = 64)then
                desc_reg5       <= m_axis_s2mm_ftch_tdata(C_M_AXIS_SG_TDATA_WIDTH-1 downto 0);
                desc_reg4       <= desc_reg5;
                desc_reg3       <= desc_reg4;
                desc_reg2       <= desc_reg3;
                desc_reg1       <= desc_reg2;
                desc_reg0       <= desc_reg1;
            --    desc_reg1       <= desc_reg2;
            --    desc_reg0       <= desc_reg1;
--                channel_id      <= m_axis_s2mm_ftch_id;
            elsif(ftch_shftenbl = '1' and C_M_AXI_S2MM_ADDR_WIDTH = 32)then
                desc_reg4       <= m_axis_s2mm_ftch_tdata(C_M_AXIS_SG_TDATA_WIDTH-1 downto 0);
                desc_reg3       <= desc_reg4;
                desc_reg2       <= desc_reg3;
                desc_reg1       <= desc_reg2;
                desc_reg0       <= desc_reg1;
             --   desc_reg3       <= desc_reg4;
             --   desc_reg2       <= desc_reg3;
             --   desc_reg1       <= desc_reg2;
             --   desc_reg0       <= desc_reg1;
--                channel_id      <= m_axis_s2mm_ftch_id;
            end if;
        end if;
    end process DESC_WRD_PROCESS;
                channel_id      <= m_axis_s2mm_ftch_id;

-- desc 4 and desc 5 are reserved and thus don't care
s2mm_desc_app0          <= (others => '0');
s2mm_desc_app1          <= (others => '0');
s2mm_desc_app2          <= (others => '0');
s2mm_desc_app3          <= (others => '0');
s2mm_desc_app4          <= (others => '0');

s2mm_channel_id_reg_update <= channel_id;

-------------------------------------------------------------------------------
-- BUFFER ADDRESS
-------------------------------------------------------------------------------
-- If 64 bit addressing then concatinate msb to lsb
GEN_NEW_64BIT_BUFADDR : if C_M_AXI_S2MM_ADDR_WIDTH = 64 generate
bmg_rd_en <= '1' when (read_count <= "0101" and desc_fetch_req = '1') else '0';
    s2mm_desc_curdesc_lsb   <= desc_reg0;
    s2mm_desc_curdesc_msb   <= desc_reg1;
    s2mm_desc_baddr_lsb     <= desc_reg2;
    s2mm_desc_baddr_msb     <= desc_reg3;
    s2mm_desc_blength_i     <= desc_reg4(DESC_BLENGTH_MSB_BIT downto DESC_BLENGTH_LSB_BIT);
    s2mm_desc_cmplt         <= desc_reg5(DESC_STS_CMPLTD_BIT);

    s2mm_desc_baddress      <= s2mm_desc_baddr_msb & s2mm_desc_baddr_lsb;

end generate GEN_NEW_64BIT_BUFADDR;

-- If 32 bit addressing then simply pass lsb out
GEN_NEW_32BIT_BUFADDR : if C_M_AXI_S2MM_ADDR_WIDTH = 32 generate
bmg_rd_en <= '1' when (read_count <= "0100" and desc_fetch_req = '1') else '0';
    s2mm_desc_curdesc_lsb   <= desc_reg0;
    s2mm_desc_baddr_lsb     <= desc_reg2;
    s2mm_desc_blength_i     <= desc_reg3(DESC_BLENGTH_MSB_BIT downto DESC_BLENGTH_LSB_BIT);
    s2mm_desc_cmplt         <= desc_reg4(DESC_STS_CMPLTD_BIT);
    s2mm_desc_curdesc_msb   <= (others => '0');
    s2mm_desc_baddr_msb     <= (others => '0');

    s2mm_desc_baddress      <= s2mm_desc_baddr_lsb;

end generate GEN_NEW_32BIT_BUFADDR;

-------------------------------------------------------------------------------
-- NEW CURRENT DESCRIPTOR
-------------------------------------------------------------------------------
-- If 64 bit addressing then concatinate msb to lsb
GEN_NEW_64BIT_CURDESC : if C_M_AXI_SG_ADDR_WIDTH = 64 generate
    s2mm_new_curdesc <= s2mm_desc_curdesc_msb & s2mm_desc_curdesc_lsb;
end generate GEN_NEW_64BIT_CURDESC;

-- If 32 bit addressing then simply pass lsb out
GEN_NEW_32BIT_CURDESC : if C_M_AXI_SG_ADDR_WIDTH = 32 generate
    s2mm_new_curdesc <= s2mm_desc_curdesc_lsb;
end generate GEN_NEW_32BIT_CURDESC;

-- Write new current descriptor out on last
REG_CURDESC_WREN : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                s2mm_new_curdesc_wren_i <= '0';

            elsif(m_axis_s2mm_ftch_tlast = '1' and ftch_shftenbl = '1')then
                s2mm_new_curdesc_wren_i <= '1';
            else
                s2mm_new_curdesc_wren_i <= '0';
            end if;
        end if;
    end process REG_CURDESC_WREN;



--***************************************************************************--
--**                       Descriptor Update Logic                         **--
--***************************************************************************--
-- SOF Flagging logic for when descriptor queues are enabled in SG Engine
GEN_SOF_QUEUE_MODE : if C_SG_INCLUDE_DESC_QUEUE = 1 generate

-- SOF Queued one count value
constant ONE_COUNT          : std_logic_vector(2 downto 0) := "001";

signal incr_sof_count       : std_logic := '0';
signal decr_sof_count       : std_logic := '0';
signal sof_count            : std_logic_vector(2 downto 0) := (others => '0');
signal sof_received_set     : std_logic := '0';
signal sof_received_clr     : std_logic := '0';
signal cmd_wr_mask          : std_logic := '0';

begin

    -- Keep track of number of commands queued up in data mover to
    -- allow proper setting of SOF's and EOF's when associated
    -- descriptor is updated.
    REG_SOF_COUNT : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    sof_count <= (others => '0');
                elsif(incr_sof_count = '1')then
                    sof_count <= std_logic_vector(unsigned(sof_count(2 downto 0)) + 1);
                elsif(decr_sof_count = '1')then
                    sof_count <= std_logic_vector(unsigned(sof_count(2 downto 0)) - 1);
                end if;
            end if;
        end process REG_SOF_COUNT;

    -- Increment count on each command write that does NOT occur
    -- coincident with a status received
    incr_sof_count  <= s2mm_cmnd_wr and not sts_received_re;

    -- Decrement count on each status received that does NOT
    -- occur coincident with a command write
    decr_sof_count  <= sts_received_re and not s2mm_cmnd_wr;


    -- Drive sof and eof setting to interrupt module for delay interrupt
    --s2mm_packet_sof  <= s2mm_sof_set;
    REG_SOF_STATUS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    sof_received <= '0';
                elsif(sof_received_set = '1')then
                    sof_received <= '1';
                elsif(sof_received_clr = '1')then
                    sof_received <= '0';
                end if;
            end if;
        end process REG_SOF_STATUS;

    -- SOF Received
    -- Case 1 (i.e. already running): EOF received therefore next has to be SOF
    -- Case 2 (i.e. initial command): No commands in queue (count=0) therefore this must be an SOF command
    sof_received_set <= '1' when (sts_received_re = '1'                 -- Status back from Datamover
                              and eof_received = '1')                   -- End of packet received
                                                                        -- OR...
                              or (s2mm_cmnd_wr = '1'                    -- Command written to datamover
                              and cmd_wr_mask = '0'                     -- Not inner-packet command
                              and sof_count = ZERO_VALUE(2 downto 0))   -- No Queued SOF cmnds
                   else '0';

    -- Done with SOF's
    -- Status received and EOF received flag not set
    -- Or status received and EOF received flag set and last SOF
    sof_received_clr <= '1' when (sts_received_re = '1' and eof_received = '0')
                              or (sts_received_re = '1' and eof_received = '1' and sof_count = ONE_COUNT)
                   else '0';

    -- Mask command writes if inner-packet command written.  An inner packet
    -- command is one where status if received and eof_received is not asserted.
    -- This mask is only used for when a cmd_wr occurs and sof_count is zero, meaning
    -- no commands happen to be queued in datamover.
    WR_MASK : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    cmd_wr_mask <= '0';
                -- received data mover status, mask if EOF not set
                -- clear mask if EOF set.
                elsif(sts_received_re = '1')then
                    cmd_wr_mask <= not eof_received;
                end if;
            end if;
        end process WR_MASK;

end generate GEN_SOF_QUEUE_MODE;

-- SOF Flagging logic for when descriptor queues are disabled in SG Engine
--GEN_SOF_NO_QUEUE_MODE : if C_SG_INCLUDE_DESC_QUEUE = 0 generate
--begin
--    -----------------------------------------------------------------------
--    -- Assert window around receive packet in order to properly set
--    -- SOF and EOF bits in descriptor
--    --
--    -- SOF for S2MM determined by new command write to datamover, i.e.
--    -- command write receive packet not already in progress.
--    -----------------------------------------------------------------------
--    RX_IN_PROG_PROCESS : process(m_axi_sg_aclk)
--        begin
--            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--                if(m_axi_sg_aresetn = '0' or s2mm_packet_eof = '1')then
--                    s2mm_in_progress <= '0';
--                    s2mm_sof_set     <= '0';
--                elsif(s2mm_in_progress = '0' and s2mm_cmnd_wr = '1')then
--                    s2mm_in_progress <= '1';
--                    s2mm_sof_set     <= '1';
--                else
--                    s2mm_in_progress <= s2mm_in_progress;
--                    s2mm_sof_set     <= '0';
--                end if;
--            end if;
--        end process RX_IN_PROG_PROCESS;
--
--    -- Drive sof and eof setting to interrupt module for delay interrupt
--    --s2mm_packet_sof  <= s2mm_sof_set;
--    REG_SOF_STATUS : process(m_axi_sg_aclk)
--        begin
--            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--                if(m_axi_sg_aresetn = '0' or sts_received_re = '1')then
--                    sof_received <= '0';
--                elsif(s2mm_sof_set = '1')then
--                    sof_received <= '1';
--                end if;
--            end if;
--        end process REG_SOF_STATUS;
--
--
--end generate GEN_SOF_NO_QUEUE_MODE;

-- IOC and EOF bits in desc update both set via packet eof flag from
-- command/status interface.
eof_received <= s2mm_packet_eof;
s2mm_ioc     <= s2mm_packet_eof;


--***************************************************************************--
--**            Descriptor Update Logic                                    **--
--***************************************************************************--


--*****************************************************************************
--** Pointer Update Logic
--*****************************************************************************

    -----------------------------------------------------------------------
    -- Capture LSB cur descriptor on write for use on descriptor update.
    -- This will be the address the descriptor is updated to
    -----------------------------------------------------------------------
    UPDT_DESC_WRD0: process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    updt_desc_reg0 <= (others => '0');
                elsif(s2mm_new_curdesc_wren_i = '1' and C_S_AXIS_UPDPTR_TDATA_WIDTH = 32)then
                    updt_desc_reg0 <= DESC_LAST
                                      & s2mm_desc_curdesc_lsb;
                elsif(s2mm_new_curdesc_wren_i = '1' and C_S_AXIS_UPDPTR_TDATA_WIDTH = 64)then
                    updt_desc_reg0 <= DESC_LAST
                                      & s2mm_desc_curdesc_msb
                                      & s2mm_desc_curdesc_lsb;

                -- Shift data out on shift enable
             --   elsif(updt_shftenbl = '1')then
             --       updt_desc_reg0 <= updt_desc_reg1;

                end if;
            end if;
        end process UPDT_DESC_WRD0;

    ---------------------------------------------------------------------------
    -- Capture MSB cur descriptor on write for use on descriptor update.
    -- This will be the address the descriptor is updated to
    ---------------------------------------------------------------------------
--    UPDT_DESC_WRD1: process(m_axi_sg_aclk)
--        begin
--            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--                if(m_axi_sg_aresetn = '0')then
--                    updt_desc_reg1 <= (others => '0');
--                elsif(s2mm_new_curdesc_wren_i = '1')then
--                    updt_desc_reg1 <= DESC_LAST
--                                      & s2mm_desc_curdesc_msb;

--                end if;
--            end if;
--        end process UPDT_DESC_WRD1;


    -- Shift in pointer to SG engine if tvalid, tready, and not on last word
    updt_shftenbl <=  updt_data and updtptr_tvalid and s_axis_s2mm_updtptr_tready;

    -- Update data done when updating data and tlast received and target
    -- (i.e. SG Engine) is ready
    updt_data_clr <= '1' when updtptr_tvalid = '1'
                          and updtptr_tlast = '1'
                          and s_axis_s2mm_updtptr_tready = '1'
                else '0';

    ---------------------------------------------------------------------------
    -- When desc data ready for update set and hold flag until
    -- data can be updated to queue.  Note it may
    -- be held off due to update of status
    ---------------------------------------------------------------------------
    UPDT_DATA_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    updt_data   <= '0';
                -- clear flag when data update complete
                elsif(updt_data_clr = '1')then
                    updt_data <= '0';
                -- set flag when desc fetched as indicated
                -- by curdesc wren
                elsif(s2mm_new_curdesc_wren_i = '1')then
                    updt_data <= '1';
                end if;
            end if;
        end process UPDT_DATA_PROCESS;

    updtptr_tvalid  <= updt_data;
    updtptr_tlast   <= updt_desc_reg0(C_S_AXIS_UPDPTR_TDATA_WIDTH);
    updtptr_tdata   <= updt_desc_reg0(C_S_AXIS_UPDPTR_TDATA_WIDTH-1 downto 0);



    -- Pass out to sg engine
    s_axis_s2mm_updtptr_tdata    <= updtptr_tdata;
    s_axis_s2mm_updtptr_tlast    <= updtptr_tlast and updtptr_tvalid;
    s_axis_s2mm_updtptr_tvalid   <= updtptr_tvalid;


--*****************************************************************************
--** Status Update Logic - DESCRIPTOR QUEUES INCLUDED                        **
--*****************************************************************************
GEN_DESC_UPDT_QUEUE : if C_SG_INCLUDE_DESC_QUEUE = 1 generate
signal xb_fifo_reset    : std_logic := '0';
signal xb_fifo_full     : std_logic := '0';
signal id_rst : std_logic := '0';
begin
    s2mm_complete       <= '1';     -- Fixed at '1'

    -----------------------------------------------------------------------
    -- Need to flag a pending point update to prevent subsequent fetch of
    -- descriptor from stepping on the stored pointer, and buffer length
    -----------------------------------------------------------------------
    REG_PENDING_UPDT : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' or updt_data_clr = '1')then
                    s2mm_pending_pntr_updt <= '0';
                elsif(s2mm_new_curdesc_wren_i = '1')then
                    s2mm_pending_pntr_updt <= '1';
                end if;
            end if;
        end process REG_PENDING_UPDT;

    -- Pending update on pointer not updated yet or xfer'ed bytes fifo full
    s2mm_pending_update <= s2mm_pending_pntr_updt or xb_fifo_full;

    -- Clear status received flag in cmdsts_if to
    -- allow more status to be received from datamover
    s2mm_sts_received_clr <= updt_sts_clr;

    -- Generate a rising edge off status received in order to
    -- flag status update
    REG_STATUS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    sts_received_d1 <= '0';
                else
                    sts_received_d1 <= s2mm_sts_received;
                end if;
            end if;
        end process REG_STATUS;

    -- CR 566306 Status invalid during halt
    --  sts_received_re <= s2mm_sts_received and not sts_received_d1;
    sts_received_re <= s2mm_sts_received and not sts_received_d1 and not s2mm_halt_d2;

    ---------------------------------------------------------------------------
    -- When status received set and hold flag until
    -- status can be updated to queue.  Note it may
    -- be held off due to update of data
    ---------------------------------------------------------------------------
    UPDT_STS_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    updt_sts                <= '0';
    s_axis_s2mm_updtsts_id      <= (others => '0'); --channel_id;
                -- clear flag when status update done or
                -- datamover halted
                elsif(updt_sts_clr = '1')then
                    updt_sts                <= '0';
    s_axis_s2mm_updtsts_id      <= (others => '0'); -- channel_id;
                -- set flag when status received
                elsif(sts_received_re = '1')then
                    updt_sts                <= '1';
    s_axis_s2mm_updtsts_id      <= id_read_data;
                end if;
            end if;
        end process UPDT_STS_PROCESS;

        id_rst <= not (m_axi_sg_aresetn);

            ID_FIFO : entity lib_srl_fifo_v1_0_2.srl_fifo_f
              generic map(
                C_DWIDTH        => 16                              ,
                C_DEPTH         => 16                                               ,
                C_FAMILY        => C_FAMILY
                )
              port map(
                Clk             => m_axi_sg_aclk                                  ,
                Reset           => id_rst, --xb_fifo_reset                                    ,
                FIFO_Write      => s2mm_new_curdesc_wren_i                                     ,
                Data_In         => channel_id                                       ,
                FIFO_Read       => sts_received_re                                  ,
                Data_Out        => id_read_data, --s_axis_s2mm_updtsts_id, --s2mm_xferd_bytes                                 ,
                FIFO_Empty      => open                                             ,
                FIFO_Full       => open, --xb_fifo_full                                     ,
                Addr            => open
                );




    updt_sts_clr <= '1' when updt_sts = '1'
                         and updtsts_tvalid = '1'
                         and updtsts_tlast = '1'
                         and s_axis_s2mm_updtsts_tready = '1'
               else '0';


    -- for queue case used to keep track of number of datamover queued cmnds
    UPDT_DONE_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    desc_update_done <= '0';
                elsif(updt_sts_clr = '1')then
                    desc_update_done <= '1';
                else
                    desc_update_done <= '0';
                end if;
            end if;
       end process UPDT_DONE_PROCESS;


    --***********************************************************************--
    --**       Descriptor Update Logic - DESCRIPTOR QUEUES - NO STS APP    **--
    --***********************************************************************--

    ---------------------------------------------------------------------------
    -- Generate Descriptor Update Signaling for NO Status App Stream
    ---------------------------------------------------------------------------
    GEN_DESC_UPDT_NO_STSAPP : if C_SG_INCLUDE_STSCNTRL_STRM = 0 generate
    begin

        stsstrm_fifo_rden   <= '0'; -- Not used in the NO sts stream configuration
        xb_fifo_full        <= '0'; -- Not used for indeterminate BTT mode


        -- Transferred byte length from status is equal to bytes transferred field
        -- in descriptor status
        GEN_EQ_23BIT_BYTE_XFERED : if C_SG_LENGTH_WIDTH = 26 generate
        begin

            s2mm_xferd_bytes <= s2mm_brcvd;

        end generate GEN_EQ_23BIT_BYTE_XFERED;

        -- Transferred byte length from status is less than bytes transferred field
        -- in descriptor status therefore need to pad value.
        GEN_LESSTHN_23BIT_BYTE_XFERED : if C_SG_LENGTH_WIDTH < 26 generate
        constant PAD_VALUE : std_logic_vector(25 - C_SG_LENGTH_WIDTH downto 0)
                                := (others => '0');
        begin
            s2mm_xferd_bytes <= PAD_VALUE & s2mm_brcvd;

        end generate GEN_LESSTHN_23BIT_BYTE_XFERED;


        sts_shftenbl  <=  updt_sts and updtsts_tvalid and s_axis_s2mm_updtsts_tready;

        -----------------------------------------------------------------------
        -- Catpure Status.  Status is built from status word from DataMover
        -- and from transferred bytes value.
        -----------------------------------------------------------------------
        UPDT_DESC_STATUS_LATCH : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0')then
                        updt_desc_sts_l  <= (others => '0');

                    elsif(sts_received_re = '1')then
                        updt_desc_sts_l  <= "10" & s2mm_sg_side_band;
 
--                        updt_desc_sts_l  <= DESC_LAST
--                                         & s2mm_ioc
--                                         & s2mm_complete
--                                         & s2mm_decerr
--                                         & s2mm_slverr
--                                         & s2mm_interr
--                                         & sof_received -- If asserted also set SOF
--                                         & eof_received -- If asserted also set EOF
--                                         & RESERVED_STS
--                                         & s2mm_xferd_bytes;
                    end if;
                end if;
            end process UPDT_DESC_STATUS_LATCH;



        UPDT_DESC_STATUS : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0')then
                        updt_desc_sts  <= (others => '0');

                    elsif(sts_received_re = '1')then
                        updt_desc_sts <= DESC_NOT_LAST
                                         & s2mm_ioc
                                         & s2mm_complete
                                         & s2mm_decerr
                                         & s2mm_slverr
                                         & s2mm_interr
                                         & sof_received -- If asserted also set SOF
                                         & eof_received -- If asserted also set EOF
                                   --      & RESERVED_STS
                                         & s2mm_xferd_bytes;

                    elsif(sts_shftenbl='1')then
                        updt_desc_sts <= updt_desc_sts_l;
                    end if;
                end if;
            end process UPDT_DESC_STATUS;

        -- Drive TVALID
        updtsts_tvalid <= updt_sts;
        -- Drive TLast
        updtsts_tlast  <= updt_desc_sts(C_S_AXIS_UPDSTS_TDATA_WIDTH);
        -- Drive TData
        updtsts_tdata  <= updt_desc_sts(C_S_AXIS_UPDSTS_TDATA_WIDTH-1 downto 0);


    end generate GEN_DESC_UPDT_NO_STSAPP;


    --***********************************************************************--
    --**       Descriptor Update Logic - DESCRIPTOR QUEUES - STS APP       **--
    --***********************************************************************--
    ---------------------------------------------------------------------------
    -- Generate Descriptor Update Signaling for Status App Stream
    ---------------------------------------------------------------------------
    GEN_DESC_UPDT_STSAPP : if C_SG_INCLUDE_STSCNTRL_STRM = 1 generate
    begin


        -- Get rx length is identical to command written, therefor store
        -- the BTT value from the command written to be used as the xferd bytes.
        GEN_USING_STSAPP_LENGTH : if C_SG_USE_STSAPP_LENGTH = 1 generate
        begin
            -----------------------------------------------------------------------
            -- On S2MM transferred bytes equals buffer length.  Capture length
            -- on curdesc write.
            -----------------------------------------------------------------------
            XFERRED_BYTE_FIFO : entity lib_srl_fifo_v1_0_2.srl_fifo_f
              generic map(
                C_DWIDTH        => BUFFER_LENGTH_WIDTH                              ,
                C_DEPTH         => 16                                               ,
                C_FAMILY        => C_FAMILY
                )
              port map(
                Clk             => m_axi_sg_aclk                                  ,
                Reset           => xb_fifo_reset                                    ,
                FIFO_Write      => s2mm_cmnd_wr                                     ,
                Data_In         => s2mm_cmnd_data(BUFFER_LENGTH_WIDTH-1 downto 0)   ,
                FIFO_Read       => sts_received_re                                  ,
                Data_Out        => s2mm_xferd_bytes                                 ,
                FIFO_Empty      => open                                             ,
                FIFO_Full       => xb_fifo_full                                     ,
                Addr            => open
                );

            xb_fifo_reset      <= not m_axi_sg_aresetn;

        end generate GEN_USING_STSAPP_LENGTH;

        -- Not using status app length field therefore primary S2MM DataMover is
        -- configured as a store and forward channel (i.e. indeterminate BTT mode)
        -- Receive length will be reported in datamover status.
        GEN_NOT_USING_STSAPP_LENGTH : if C_SG_USE_STSAPP_LENGTH = 0 generate
        begin
            xb_fifo_full        <= '0';         -- Not used in Indeterminate BTT mode

            -- Transferred byte length from status is equal to bytes transferred field
            -- in descriptor status
            GEN_EQ_23BIT_BYTE_XFERED : if C_SG_LENGTH_WIDTH = 26 generate
            begin

                s2mm_xferd_bytes <= s2mm_brcvd;

            end generate GEN_EQ_23BIT_BYTE_XFERED;

            -- Transferred byte length from status is less than bytes transferred field
            -- in descriptor status therefore need to pad value.
            GEN_LESSTHN_23BIT_BYTE_XFERED : if C_SG_LENGTH_WIDTH < 26 generate
            constant PAD_VALUE : std_logic_vector(25 - C_SG_LENGTH_WIDTH downto 0)
                                    := (others => '0');
            begin
                s2mm_xferd_bytes <= PAD_VALUE & s2mm_brcvd;

            end generate GEN_LESSTHN_23BIT_BYTE_XFERED;

        end generate GEN_NOT_USING_STSAPP_LENGTH;

        EOF_DEL : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0')then
                        s2mm_packet_eof_del <= '0';
                    else
                        s2mm_packet_eof_del <= s2mm_packet_eof;
                    end if;
                end if;
            end process EOF_DEL;


        -----------------------------------------------------------------------
        -- For EOF Descriptor then need to update APP fields from Status
        -- Stream FIFO
        -----------------------------------------------------------------------
        WRITE_APP_PROCESS : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0' )then

                        writing_app_fields <= '0';
                    -- If writing app fields and reach LAST then stop writing
                    -- app fields
                    elsif(writing_app_fields = '1'                              -- Writing app fields
                    and stsstrm_fifo_dout(C_S_AXIS_S2MM_STS_TDATA_WIDTH) = '1'  -- Last app word (tlast=1)
                    and stsstrm_fifo_rden_i = '1')then                          -- Fifo read
                        writing_app_fields <= '0';

                    -- ON EOF Descriptor, then need to write application fields on desc
                    -- update
                    elsif(s2mm_packet_eof = '1'
                    and s2mm_xferd_bytes /= ZERO_LENGTH) then

                        writing_app_fields <= '1';
                    end if;
                end if;
            end process WRITE_APP_PROCESS;


        -- Shift in apps to SG engine if tvalid, tready, and not on last word
        sts_shftenbl  <=  updt_sts and updtsts_tvalid and s_axis_s2mm_updtsts_tready;

        -----------------------------------------------------------------------
        -- Catpure Status.  Status is built from status word from DataMover
        -- and from transferred bytes value.
        -----------------------------------------------------------------------
        UPDT_DESC_STATUS : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0')then
                        updt_desc_sts  <= (others => '0');

                    elsif(sts_received_re = '1')then
--                        updt_desc_sts  <= "00" & s2mm_sg_side_band;
                        updt_desc_sts  <= DESC_NOT_LAST
                                         & s2mm_ioc
                                         & s2mm_complete
                                         & s2mm_decerr
                                         & s2mm_slverr
                                         & s2mm_interr
                                         & sof_received -- If asserted also set SOF
                                         & eof_received -- If asserted also set EOF
                                   --      & RESERVED_STS
                                         & s2mm_xferd_bytes;

                    elsif(sts_shftenbl='1')then
                        updt_desc_sts <= updt_desc_sts_l;

                    end if;
                end if;
            end process UPDT_DESC_STATUS;

        UPDT_DESC_STATUS_LATCH : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0')then
                        updt_desc_sts_l  <= (others => '0');

                    elsif(sts_received_re = '1')then
                        updt_desc_sts_l  <= "00" & s2mm_sg_side_band;
--                        updt_desc_sts_l  <= DESC_NOT_LAST
--                                         & s2mm_ioc
--                                         & s2mm_complete
--                                         & s2mm_decerr
--                                         & s2mm_slverr
--                                         & s2mm_interr
--                                         & sof_received -- If asserted also set SOF
--                                         & eof_received -- If asserted also set EOF
--                                         & RESERVED_STS
--                                         & s2mm_xferd_bytes;
                    elsif(sts_shftenbl='1')then
                        updt_desc_sts_l <= updt_desc_reg3;
                    end if;
                end if;
            end process UPDT_DESC_STATUS_LATCH;
        -----------------------------------------------------------------------
        -- If EOF Descriptor (writing_app_fields=1) then pass data from
        -- status stream FIFO into descriptor update shift registers
        -- Else pass zeros
        -----------------------------------------------------------------------
        UPDT_REG3_MUX : process(writing_app_fields,
                                stsstrm_fifo_dout,
                                updt_zero_reg3,
                                sts_shftenbl)
                begin
                    if(writing_app_fields = '1')then
                        updt_desc_reg3      <= stsstrm_fifo_dout(C_S_AXIS_S2MM_STS_TDATA_WIDTH)              -- Update LAST setting
                                             & '0'
                                             & stsstrm_fifo_dout(C_S_AXIS_S2MM_STS_TDATA_WIDTH-1 downto 0);  -- Update Word
                        stsstrm_fifo_rden_i <= sts_shftenbl;
                    else
                        updt_desc_reg3      <= updt_zero_reg3;
                        stsstrm_fifo_rden_i <= '0';
                    end if;
                end process UPDT_REG3_MUX;

        stsstrm_fifo_rden <= stsstrm_fifo_rden_i;

        -----------------------------------------------------------------------
        -- APP 0 Register (Set to Zero for Non-EOF Descriptor)
        -----------------------------------------------------------------------
        UPDT_ZERO_WRD3  : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0' or sts_received_re = '1')then
                        updt_zero_reg3  <= DESC_NOT_LAST                -- Not last word of stream
                                         & '0'                          -- Don't set IOC
                                         & ZERO_VALUE;                  -- Remainder is zero

                    -- Shift data out on shift enable
                    elsif(sts_shftenbl = '1')then
                        updt_zero_reg3  <= updt_zero_reg4;
                    end if;
                end if;
            end process UPDT_ZERO_WRD3;

        -----------------------------------------------------------------------
        -- APP 1 Register (Set to Zero for Non-EOF Descriptor)
        -----------------------------------------------------------------------
        UPDT_ZERO_WRD4  : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0' or sts_received_re = '1')then
                        updt_zero_reg4  <= DESC_NOT_LAST                -- Not last word of stream
                                         & '0'                          -- Don't set IOC
                                         & ZERO_VALUE;                  -- Remainder is zero
                    -- Shift data out on shift enable
                    elsif(sts_shftenbl = '1')then
                        updt_zero_reg4  <= updt_zero_reg5;
                    end if;
                end if;
            end process UPDT_ZERO_WRD4;

        -----------------------------------------------------------------------
        -- APP 2 Register (Set to Zero for Non-EOF Descriptor)
        -----------------------------------------------------------------------
        UPDT_ZERO_WRD5  : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0' or sts_received_re = '1')then
                        updt_zero_reg5  <= DESC_NOT_LAST                -- Not last word of stream
                                         & '0'                          -- Don't set IOC
                                         & ZERO_VALUE;                  -- Remainder is zero

                    -- Shift data out on shift enable
                    elsif(sts_shftenbl = '1')then
                        updt_zero_reg5  <= updt_zero_reg6;
                    end if;
                end if;
            end process UPDT_ZERO_WRD5;

        -----------------------------------------------------------------------
        -- APP 3 and APP 4 Register (Set to Zero for Non-EOF Descriptor)
        -----------------------------------------------------------------------
        UPDT_ZERO_WRD6  : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0' or sts_received_re = '1')then
                        updt_zero_reg6  <= DESC_NOT_LAST                -- Not last word of stream
                                         & '0'                          -- Don't set IOC
                                         & ZERO_VALUE;                  -- Remainder is zero

                    -- Shift data out on shift enable
                    elsif(sts_shftenbl = '1')then
                        updt_zero_reg6  <= DESC_LAST                    -- Last word of stream
                                         & s2mm_ioc
                                         & ZERO_VALUE;                  -- Remainder is zero
                    end if;
                end if;
            end process UPDT_ZERO_WRD6;

        -----------------------------------------------------------------------
        -- Drive TVALID
        -- If writing app then base on stsstrm fifo empty flag
        -- If writing datamover status then base simply assert on updt_sts
        -----------------------------------------------------------------------
        TVALID_MUX : process(writing_app_fields,updt_sts,stsstrm_fifo_empty)
            begin
                if(updt_sts = '1' and writing_app_fields = '1')then
                    updtsts_tvalid <= not stsstrm_fifo_empty;
                elsif(updt_sts = '1')then
                    updtsts_tvalid <= '1';
                else
                    updtsts_tvalid <= '0';
                end if;
            end process TVALID_MUX;

        -- Drive TLAST
        updtsts_tlast  <= updt_desc_sts(C_S_AXIS_UPDSTS_TDATA_WIDTH);
        -- Drive TDATA
        updtsts_tdata  <= updt_desc_sts(C_S_AXIS_UPDSTS_TDATA_WIDTH-1 downto 0);

    end generate GEN_DESC_UPDT_STSAPP;

    -- Pass out to sg engine
    s_axis_s2mm_updtsts_tdata   <= updtsts_tdata;
    s_axis_s2mm_updtsts_tvalid  <= updtsts_tvalid;
    s_axis_s2mm_updtsts_tlast   <= updtsts_tlast and updtsts_tvalid;

end generate GEN_DESC_UPDT_QUEUE;








end implementation;



-------------------------------------------------------------------------------
-- axi_mcdma_s2mm_sm
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_mcdma_s2mm_sm.vhd
-- Description: This entity contains the S2MM DMA Controller State Machine
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.clog2;


-------------------------------------------------------------------------------
entity  axi_mcdma_s2mm_sm is
    generic (
        C_M_AXI_S2MM_ADDR_WIDTH     : integer range 32 to 64    := 32;
            -- Master AXI Memory Map Address Width for S2MM Write Port

        C_SG_INCLUDE_STSCNTRL_STRM  : integer range 0 to 1      := 1;
            -- Include or Exclude AXI Status and AXI Control Streams
            -- 0 = Exclude Status and Control Streams
            -- 1 = Include Status and Control Streams

        C_SG_USE_STSAPP_LENGTH      : integer range 0 to 1      := 1;
            -- Enable or Disable use of Status Stream Rx Length.  Only valid
            -- if C_SG_INCLUDE_STSCNTRL_STRM = 1
            -- 0 = Don't use Rx Length
            -- 1 = Use Rx Length

        C_SG_LENGTH_WIDTH           : integer range 8 to 26     := 14;
            -- Width of Buffer Length, Transferred Bytes, and BTT fields

        C_SG_INCLUDE_DESC_QUEUE     : integer range 0 to 1      := 0;
            -- Include or Exclude Scatter Gather Descriptor Queuing
            -- 0 = Exclude SG Descriptor Queuing
            -- 1 = Include SG Descriptor Queuing

        C_PRMY_CMDFIFO_DEPTH        : integer range 1 to 16     := 1
            -- Depth of DataMover command FIFO
    );
    port (
        m_axi_sg_aclk               : in  std_logic                         ;                   --
        m_axi_sg_aresetn            : in  std_logic                         ;                   --
                                                                                                --
        s2mm_stop                   : in  std_logic                         ;                   --
                                                                                                --
        -- S2MM Control and Status                                                              --
        s2mm_run_stop               : in  std_logic                         ;                   --
        s2mm_ftch_idle              : in  std_logic                         ;                   --
        s2mm_desc_flush             : in  std_logic                         ;                   --
        s2mm_cmnd_idle              : out std_logic                         ;                   --
        s2mm_sts_idle               : out std_logic                         ;                   --
        s2mm_eof_set                : out std_logic                         ;                   --
        fetch_more                  : in std_logic                          ;
                                                                                                --
        -- S2MM Descriptor Fetch Request                                                        --
        desc_fetch_req              : out std_logic                         ;                   --
        desc_fetch_done             : in  std_logic                         ;                   --
        desc_update_done            : in  std_logic                         ;                   --
        desc_available              : in  std_logic                         ;                   --
                                                                                                --
        -- S2MM Status Stream RX Length                                                         --
        s2mm_rxlength_valid         : in  std_logic                         ;                   --
        s2mm_rxlength_clr           : out std_logic                         ;                   --
        s2mm_rxlength               : in  std_logic_vector                                      --
                                        (C_SG_LENGTH_WIDTH - 1 downto 0)    ;                   --
                                                                                                --
        -- DataMover Command                                                                    --
        s2mm_cmnd_wr                : out std_logic                         ;                   --
        s2mm_cmnd_data              : out std_logic_vector                                      --
                                        ((C_M_AXI_S2MM_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);  --
        s2mm_cmnd_pending           : in  std_logic                         ;                   --
                                                                                                --
        -- Descriptor Fields                                                                    --
        s2mm_desc_baddress          : in  std_logic_vector                                      --
                                        (C_M_AXI_S2MM_ADDR_WIDTH-1 downto 0);                   --
        s2mm_desc_blength           : in  std_logic_vector                                      --
                                        (BUFFER_LENGTH_WIDTH-1 downto 0)                        --

    );

end axi_mcdma_s2mm_sm;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_s2mm_sm is

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
-- DataMover Commmand TAG
constant S2MM_CMD_TAG       : std_logic_vector(2 downto 0)  := (others => '0');
-- DataMover Command Destination Stream Offset
constant S2MM_CMD_DSA       : std_logic_vector(5 downto 0)  := (others => '0');
-- DataMover Cmnd Reserved Bits
constant S2MM_CMD_RSVD      : std_logic_vector(
                                DATAMOVER_CMD_RSVMSB_BOFST + C_M_AXI_S2MM_ADDR_WIDTH downto
                                DATAMOVER_CMD_RSVLSB_BOFST + C_M_AXI_S2MM_ADDR_WIDTH)
                                := (others => '0');
-- Queued commands counter width
constant COUNTER_WIDTH      : integer := 2; --clog2(C_PRMY_CMDFIFO_DEPTH+1);

-- Queued commands zero count
constant ZERO_COUNT         : std_logic_vector(COUNTER_WIDTH - 1 downto 0)
                                := (others => '0');
-- Zero buffer length error - compare value
constant ZERO_LENGTH        : std_logic_vector(C_SG_LENGTH_WIDTH-1 downto 0)
                                := (others => '0');

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
-- State Machine Signals
signal desc_fetch_req_cmb       : std_logic := '0';
signal write_cmnd_cmb           : std_logic := '0';
signal s2mm_rxlength_clr_cmb    : std_logic := '0';

signal rxlength                 : std_logic_vector(C_SG_LENGTH_WIDTH-1 downto 0) := (others => '0');
signal s2mm_rxlength_set        : std_logic := '0';
signal blength_grtr_rxlength    : std_logic := '0';
signal rxlength_fetched         : std_logic := '0';

--signal cmnds_queued             : std_logic_vector(COUNTER_WIDTH - 1 downto 0) := (others => '0');
signal cmnds_queued             : std_logic_vector(1 downto 0) := (others => '0');
signal count_incr               : std_logic := '0';
signal count_decr               : std_logic := '0';

signal desc_fetch_done_d1       : std_logic := '0';
signal zero_length_error        : std_logic := '0';
signal s2mm_eof_set_i           : std_logic := '0';

signal queue_more               : std_logic := '0';

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

s2mm_eof_set <= s2mm_eof_set_i;

-------------------------------------------------------------------------------
-- Not using rx length from status stream - (indeterminate length mode)
-------------------------------------------------------------------------------
GEN_SM_FOR_NO_LENGTH : if C_SG_USE_STSAPP_LENGTH = 0 or C_SG_INCLUDE_STSCNTRL_STRM = 0 generate
type SG_S2MM_STATE_TYPE      is (
                                IDLE,
                                FETCH_DESCRIPTOR,
                                EXECUTE_XFER,
                                WAIT_STATUS
                                );

signal s2mm_cs                  : SG_S2MM_STATE_TYPE;
signal s2mm_ns                  : SG_S2MM_STATE_TYPE;


begin
    -- For no status stream or not using length in status app field then eof set is
    -- generated from datamover status (see axi_mcdma_s2mm_cmdsts_if.vhd)
    s2mm_eof_set_i        <= '0';

    -------------------------------------------------------------------------------
    -- S2MM Transfer State Machine
    -------------------------------------------------------------------------------
    S2MM_MACHINE : process(s2mm_cs,
                           s2mm_run_stop,
                           desc_available,
                           desc_fetch_done,
                           desc_update_done,
                           s2mm_cmnd_pending,
                           s2mm_stop,
                           s2mm_desc_flush,
                           queue_more,
                           fetch_more
                           )
        begin

            -- Default signal assignment
            desc_fetch_req_cmb      <= '0';
            write_cmnd_cmb          <= '0';
            s2mm_cmnd_idle          <= '0';
            s2mm_ns                 <= s2mm_cs;

            case s2mm_cs is

                -------------------------------------------------------------------
                when IDLE =>
                    -- fetch descriptor if desc available, not stopped and running
                    if((s2mm_run_stop = '1' and desc_available = '1'
                    and s2mm_stop = '0' and queue_more = '1') or (fetch_more = '1' and desc_available = '1')) then
                        s2mm_ns <= FETCH_DESCRIPTOR;
                    else
                        s2mm_cmnd_idle <= '1';
                    end if;

                -------------------------------------------------------------------
                when FETCH_DESCRIPTOR =>
                    -- exit if error or descriptor flushed
                    if(s2mm_desc_flush = '1')then
                        s2mm_ns         <= IDLE;
                    -- wait until fetch complete then execute
                    elsif(desc_fetch_done = '1')then
                        desc_fetch_req_cmb  <= '0';
                        s2mm_ns             <= EXECUTE_XFER;
                    else
                        desc_fetch_req_cmb  <= '1';
                    end if;

                -------------------------------------------------------------------
                when EXECUTE_XFER =>
                    -- if error exit
                    if(s2mm_stop = '1')then
                        s2mm_ns         <= IDLE;
                    -- Write another command if there is not one already pending
                    elsif(s2mm_cmnd_pending = '0')then
                        write_cmnd_cmb  <= '1';
                        if(C_SG_INCLUDE_DESC_QUEUE = 1)then
                            s2mm_ns         <= IDLE;
                        else
                            s2mm_ns         <= WAIT_STATUS;
                        end if;
                    else
                        s2mm_ns <= EXECUTE_XFER;
                    end if;

                -------------------------------------------------------------------
                when WAIT_STATUS =>
                    -- for no Q wait until desc updated
                    if(desc_update_done = '1' or s2mm_stop = '1')then
                        s2mm_ns <= IDLE;
                    else
                        s2mm_ns <= WAIT_STATUS;
                    end if;

                -------------------------------------------------------------------
          -- coverage off
                when others =>
                    s2mm_ns <= IDLE;
          -- coverage on

            end case;
        end process S2MM_MACHINE;

    -------------------------------------------------------------------------------
    -- Register State Machine Statues
    -------------------------------------------------------------------------------
    REGISTER_STATE : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    s2mm_cs     <= IDLE;
                else
                    s2mm_cs     <= s2mm_ns;
                end if;
            end if;
        end process REGISTER_STATE;

    -------------------------------------------------------------------------------
    -- Register State Machine Signalse
    -------------------------------------------------------------------------------
    SM_SIG_REGISTER : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    desc_fetch_req      <= '0'      ;
                else
                    desc_fetch_req      <= desc_fetch_req_cmb   ;
                end if;
            end if;
        end process SM_SIG_REGISTER;

    -------------------------------------------------------------------------------
    -- Build DataMover command
    -------------------------------------------------------------------------------
    -- If Bytes To Transfer (BTT) width less than 23, need to add pad
    GEN_CMD_BTT_LESS_23 : if C_SG_LENGTH_WIDTH < 26 generate
    constant PAD_VALUE : std_logic_vector(25 - C_SG_LENGTH_WIDTH downto 0)
                            := (others => '0');
    begin
        -- When command by sm, drive command to s2mm_cmdsts_if
        GEN_DATAMOVER_CMND : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0')then
                        s2mm_cmnd_wr    <= '0';
                        s2mm_cmnd_data  <= (others => '0');

                    -- Fetch SM issued a command write
                    elsif(write_cmnd_cmb = '1')then
                        s2mm_cmnd_wr    <= '1';
                        s2mm_cmnd_data  <=  S2MM_CMD_RSVD
                                            & "0000"  -- Cat IOC to CMD TAG
                                            & s2mm_desc_baddress
                                            & '1'           -- Always reset DRE
                                            & '0'           -- For Indeterminate BTT mode do not set EOF
                                            & S2MM_CMD_DSA
                                            & '1'           -- s2mm_desc_type -- IR# 545697
                                            & PAD_VALUE
                                            & s2mm_desc_blength(C_SG_LENGTH_WIDTH-1 downto 0);
                    else
                        s2mm_cmnd_wr    <= '0';

                    end if;
                end if;
            end process GEN_DATAMOVER_CMND;

    end generate GEN_CMD_BTT_LESS_23;

    -- If Bytes To Transfer (BTT) width equal 23, no required pad
    GEN_CMD_BTT_EQL_23 : if C_SG_LENGTH_WIDTH = 26 generate
    begin
        -- When command by sm, drive command to s2mm_cmdsts_if
        GEN_DATAMOVER_CMND : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0')then
                        s2mm_cmnd_wr    <= '0';
                        s2mm_cmnd_data  <= (others => '0');

                    -- Fetch SM issued a command write
                    elsif(write_cmnd_cmb = '1')then
                        s2mm_cmnd_wr    <= '1';
                        s2mm_cmnd_data  <=  S2MM_CMD_RSVD
                                            & "0000"  -- Cat IOC to CMD TAG
                                            & s2mm_desc_baddress
                                            & '1'           -- Always reset DRE
                                            & '0'           -- For indeterminate BTT mode do not set EOF
                                            & S2MM_CMD_DSA
                                            & '1'           -- s2mm_desc_type -- IR# 545697
                                            & s2mm_desc_blength;

                    else
                        s2mm_cmnd_wr    <= '0';

                    end if;
                end if;
            end process GEN_DATAMOVER_CMND;

    end generate GEN_CMD_BTT_EQL_23;


    -- Drive unused output to zero
    s2mm_rxlength_clr   <= '0';

end generate GEN_SM_FOR_NO_LENGTH;



-------------------------------------------------------------------------------
-- Generate state machine and support logic for Using RX Length from Status
-- Stream
-------------------------------------------------------------------------------
GEN_SM_FOR_LENGTH : if C_SG_USE_STSAPP_LENGTH = 1 and C_SG_INCLUDE_STSCNTRL_STRM = 1 generate
type SG_S2MM_STATE_TYPE      is (
                                IDLE,
                                FETCH_DESCRIPTOR,
                                GET_RXLENGTH,
                                CMPR_LENGTH,
                                EXECUTE_XFER,
                                WAIT_STATUS
                                );

signal s2mm_cs                  : SG_S2MM_STATE_TYPE;
signal s2mm_ns                  : SG_S2MM_STATE_TYPE;

begin

    -------------------------------------------------------------------------------
    -- S2MM Transfer State Machine
    -------------------------------------------------------------------------------
    S2MM_MACHINE : process(s2mm_cs,
                           s2mm_run_stop,
                           desc_available,
                           desc_update_done,
                           desc_fetch_done,
                           s2mm_rxlength_valid,
                           rxlength_fetched,
                           s2mm_cmnd_pending,
                           zero_length_error,
                           s2mm_stop,
                           s2mm_desc_flush,
                           queue_more,
                           fetch_more
                           )
        begin

            -- Default signal assignment
            desc_fetch_req_cmb      <= '0';
            s2mm_rxlength_clr_cmb   <= '0';
            write_cmnd_cmb          <= '0';
            s2mm_cmnd_idle          <= '0';
            s2mm_rxlength_set       <= '0';
            --rxlength_fetched_clr    <= '0';
            s2mm_ns                 <= s2mm_cs;

            case s2mm_cs is

                -------------------------------------------------------------------
                when IDLE =>
                    if((s2mm_run_stop = '1' and desc_available = '1'
                    and s2mm_stop = '0' and queue_more = '1') or (fetch_more = '1' and desc_available = '1')) then
                        s2mm_ns <= FETCH_DESCRIPTOR;
                    else
                        s2mm_cmnd_idle <= '1';
                    end if;

                -------------------------------------------------------------------
                when FETCH_DESCRIPTOR =>
                    -- exit if error or descriptor flushed
                    if(s2mm_desc_flush = '1')then
                        s2mm_ns         <= IDLE;
                    -- Descriptor fetch complete
                    elsif(desc_fetch_done = '1')then
                        desc_fetch_req_cmb  <= '0';
                        if(rxlength_fetched = '0')then
                            s2mm_ns             <= GET_RXLENGTH;
                        else
                            s2mm_ns             <= CMPR_LENGTH;
                        end if;

                    else
                        desc_fetch_req_cmb  <= '1';
                    end if;

                -------------------------------------------------------------------
                WHEN GET_RXLENGTH =>
                    if(s2mm_stop = '1')then
                        s2mm_ns         <= IDLE;
                    -- Buffer length zero, do not compare lengths, execute
                    -- command to force datamover to issue interror
                    elsif(zero_length_error = '1')then
                        s2mm_ns                 <= EXECUTE_XFER;
                    elsif(s2mm_rxlength_valid = '1')then
                        s2mm_rxlength_set       <= '1';
                        s2mm_rxlength_clr_cmb   <= '1';
                        s2mm_ns                 <= CMPR_LENGTH;
                    else
                        s2mm_ns <= GET_RXLENGTH;
                    end if;

                -------------------------------------------------------------------
                WHEN CMPR_LENGTH    =>
                        s2mm_ns                 <= EXECUTE_XFER;

                -------------------------------------------------------------------
                when EXECUTE_XFER =>
                    if(s2mm_stop = '1')then
                        s2mm_ns         <= IDLE;
                    -- write new command if one is not already pending
                    elsif(s2mm_cmnd_pending = '0')then
                        write_cmnd_cmb  <= '1';

                        -- If descriptor queuing enabled then
                        -- do NOT need to wait for status
                        if(C_SG_INCLUDE_DESC_QUEUE = 1)then
                            s2mm_ns         <= IDLE;

                        -- No queuing therefore must wait for
                        -- status before issuing next command
                        else
                            s2mm_ns         <= WAIT_STATUS;
                        end if;
                    else
                            s2mm_ns         <= EXECUTE_XFER;
                    end if;
                -------------------------------------------------------------------
                when WAIT_STATUS =>
                    if(desc_update_done = '1' or s2mm_stop = '1')then
                        s2mm_ns <= IDLE;
                    else
                        s2mm_ns <= WAIT_STATUS;
                    end if;

                -------------------------------------------------------------------
          -- coverage off

                when others =>
                    s2mm_ns <= IDLE;
          -- coverage on


            end case;
        end process S2MM_MACHINE;

    -------------------------------------------------------------------------------
    -- Register state machine states
    -------------------------------------------------------------------------------
    REGISTER_STATE : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    s2mm_cs     <= IDLE;
                else
                    s2mm_cs     <= s2mm_ns;
                end if;
            end if;
        end process REGISTER_STATE;

    -------------------------------------------------------------------------------
    -- Register state machine signals
    -------------------------------------------------------------------------------
    SM_SIG_REGISTER : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    desc_fetch_req      <= '0'      ;
                    s2mm_rxlength_clr   <= '0'      ;
                else
                    desc_fetch_req      <= desc_fetch_req_cmb   ;
                    s2mm_rxlength_clr   <= s2mm_rxlength_clr_cmb;
                end if;
            end if;
        end process SM_SIG_REGISTER;


    -------------------------------------------------------------------------------
    -- Check for a ZERO value in descriptor buffer length.  If there is
    -- then flag an error and skip waiting for valid rxlength.  cmnd will
    -- get written to datamover with BTT=0 and datamover will flag dmaint error
    -- which will be logged in desc, reset required to clear error
    -------------------------------------------------------------------------------
    REG_ALIGN_DONE : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    desc_fetch_done_d1 <= '0';
                else
                    desc_fetch_done_d1 <= desc_fetch_done;
                end if;
            end if;
        end process REG_ALIGN_DONE;



    -------------------------------------------------------------------------------
    -- Zero length error detection - for determinate mode, detect early to prevent
    -- rxlength calcuation from first taking place.  This will force a 0 BTT
    -- command to be issued to the datamover causing an internal error.
    -------------------------------------------------------------------------------
    REG_ZERO_LNGTH_ERR : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    zero_length_error <= '0';
                elsif(desc_fetch_done_d1 = '1'
                and s2mm_desc_blength(C_SG_LENGTH_WIDTH-1 downto 0) = ZERO_LENGTH)then
                    zero_length_error <= '1';
                end if;
            end if;
        end process REG_ZERO_LNGTH_ERR;


    -------------------------------------------------------------------------------
    -- Capture/Hold receive length from status stream.  Also decrement length
    -- based on if received length is greater than descriptor buffer size. (i.e. is
    -- the case where multiple descriptors/buffers are used to describe one packet)
    -------------------------------------------------------------------------------
    REG_RXLENGTH : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    rxlength            <= (others => '0');
                -- If command register rxlength from status stream fifo
                elsif(s2mm_rxlength_set = '1')then
                    rxlength            <= s2mm_rxlength;

                -- On command write if current desc buffer size not greater
                -- than current rxlength then decrement rxlength in preperations
                -- for subsequent commands
                elsif(write_cmnd_cmb = '1' and blength_grtr_rxlength = '0')then

                    rxlength <= std_logic_vector(unsigned(rxlength(C_SG_LENGTH_WIDTH-1 downto 0))
                                               - unsigned(s2mm_desc_blength(C_SG_LENGTH_WIDTH-1 downto 0)));

                end if;
            end if;
        end process REG_RXLENGTH;

    -------------------------------------------------------------------------------
    -- Calculate if Descriptor Buffer Length is 'Greater Than' or 'Equal To'
    -- Received Length value
    -------------------------------------------------------------------------------
    REG_BLENGTH_GRTR_RXLNGTH : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    blength_grtr_rxlength <= '0';
                elsif(s2mm_desc_blength(C_SG_LENGTH_WIDTH-1 downto 0) >= rxlength)then
                    blength_grtr_rxlength <= '1';
                else
                    blength_grtr_rxlength <= '0';
                end if;
            end if;
        end process REG_BLENGTH_GRTR_RXLNGTH;

    -------------------------------------------------------------------------------
    -- On command assert rxlength fetched flag indicating length grabbed from
    -- status stream fifo
    -------------------------------------------------------------------------------
    RXLENGTH_FTCHED_PROCESS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0' or s2mm_eof_set_i = '1')then
                    rxlength_fetched    <= '0';
                elsif(s2mm_rxlength_set = '1')then
                    rxlength_fetched    <= '1';
                end if;
             end if;
         end process RXLENGTH_FTCHED_PROCESS;

    -------------------------------------------------------------------------------
    -- Build DataMover command
    -------------------------------------------------------------------------------
    -- If Bytes To Transfer (BTT) width less than 23, need to add pad
    GEN_CMD_BTT_LESS_23 : if C_SG_LENGTH_WIDTH < 26 generate
    constant PAD_VALUE : std_logic_vector(25 - C_SG_LENGTH_WIDTH downto 0)
                            := (others => '0');
    begin
        -- When command by sm, drive command to s2mm_cmdsts_if
        GEN_DATAMOVER_CMND : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0')then
                        s2mm_cmnd_wr    <= '0';
                        s2mm_cmnd_data  <= (others => '0');
                        s2mm_eof_set_i  <= '0';

                    -- Current Desc Buffer will NOT hold entire rxlength of data therefore
                    -- set EOF = based on Desc.EOF and pass buffer length for BTT
                    elsif(write_cmnd_cmb = '1' and blength_grtr_rxlength = '0')then
                        s2mm_cmnd_wr    <= '1';
                        s2mm_cmnd_data  <=  S2MM_CMD_RSVD
                                            -- Command Tag
                                            & '0'
                                            & '0'
                                            & '0'  -- Cat. EOF=0 to CMD Tag
                                            & '0'  -- Cat. IOC to CMD TAG
                                            -- Command
                                            & s2mm_desc_baddress
                                            & '1'           -- Always reset DRE
                                            & '0'           -- Not End of Frame
                                            & S2MM_CMD_DSA
                                            & '1'           -- s2mm_desc_type -- IR# 545697
                                            & PAD_VALUE
                                            & s2mm_desc_blength(C_SG_LENGTH_WIDTH-1 downto 0);
                        s2mm_eof_set_i  <= '0';


                    -- Current Desc Buffer will hold entire rxlength of data therefore
                    -- set EOF = 1 and pass rxlength for BTT
                    --
                    -- Note: change to mode where EOF generates IOC interrupt as
                    -- opposed to a IOC bit in the descriptor negated need for an
                    -- EOF and IOC tag.  Given time, these two bits could be combined
                    -- into 1.  Associated logic in SG engine would also need to be
                    -- modified as well as in s2mm_sg_if.
                    elsif(write_cmnd_cmb = '1' and blength_grtr_rxlength = '1')then
                        s2mm_cmnd_wr    <= '1';
                        s2mm_cmnd_data  <=  S2MM_CMD_RSVD
                                            -- Command Tag
                                            & '0'
                                            & '0'
                                            & '1'  -- Cat. EOF=1 to CMD Tag
                                            & '1'  -- Cat. IOC to CMD TAG
                                            -- Command
                                            & s2mm_desc_baddress
                                            & '1'           -- Always reset DRE
                                            & '1'           -- Set EOF=1
                                            & S2MM_CMD_DSA
                                            & '1'           -- s2mm_desc_type -- IR# 545697
                                            & PAD_VALUE
                                            & rxlength;
                        s2mm_eof_set_i    <= '1';

                    else
                        s2mm_cmnd_data  <= (others => '0');
                        s2mm_cmnd_wr    <= '0';
                        s2mm_eof_set_i  <= '0';

                    end if;
                end if;
            end process GEN_DATAMOVER_CMND;

    end generate GEN_CMD_BTT_LESS_23;

    -- If Bytes To Transfer (BTT) width equal 23, no required pad
    GEN_CMD_BTT_EQL_23 : if C_SG_LENGTH_WIDTH = 26 generate
    begin
        -- When command by sm, drive command to s2mm_cmdsts_if
        GEN_DATAMOVER_CMND : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0')then
                        s2mm_cmnd_wr    <= '0';
                        s2mm_cmnd_data  <= (others => '0');
                        s2mm_eof_set_i    <= '0';
                    -- Current Desc Buffer will NOT hold entire rxlength of data therefore
                    -- set EOF = based on Desc.EOF and pass buffer length for BTT
                    elsif(write_cmnd_cmb = '1' and blength_grtr_rxlength = '0')then
                        s2mm_cmnd_wr    <= '1';
                        s2mm_cmnd_data  <=  S2MM_CMD_RSVD
                                            --& S2MM_CMD_TAG & s2mm_desc_ioc  -- Cat IOC to CMD TAG
                                            -- Command Tag
                                            & '0'
                                            & '0'
                                            & '0'  -- Cat. EOF='0' to CMD Tag
                                            & '0'  -- Cat. IOC='0' to CMD TAG
                                            -- Command
                                            & s2mm_desc_baddress
                                            & '1'           -- Always reset DRE
                                            & '0'           -- Not End of Frame
                                            & S2MM_CMD_DSA
                                            & '1' -- s2mm_desc_type -- IR# 545697
                                            & s2mm_desc_blength;

                        s2mm_eof_set_i    <= '0';

                    -- Current Desc Buffer will hold entire rxlength of data therefore
                    -- set EOF = 1 and pass rxlength for BTT
                    --
                    -- Note: change to mode where EOF generates IOC interrupt as
                    -- opposed to a IOC bit in the descriptor negated need for an
                    -- EOF and IOC tag.  Given time, these two bits could be combined
                    -- into 1.  Associated logic in SG engine would also need to be
                    -- modified as well as in s2mm_sg_if.
                    elsif(write_cmnd_cmb = '1' and blength_grtr_rxlength = '1')then
                        s2mm_cmnd_wr    <= '1';
                        s2mm_cmnd_data  <=  S2MM_CMD_RSVD
                                            --& S2MM_CMD_TAG & s2mm_desc_ioc  -- Cat IOC to CMD TAG
                                            -- Command Tag
                                            & '0'
                                            & '0'
                                            & '1'  -- Cat. EOF='1' to CMD Tag
                                            & '1'  -- Cat. IOC='1' to CMD TAG
                                            -- Command
                                            & s2mm_desc_baddress
                                            & '1'           -- Always reset DRE
                                            & '1'           -- End of Frame
                                            & S2MM_CMD_DSA
                                            & '1' -- s2mm_desc_type -- IR# 545697
                                            & rxlength;
                        s2mm_eof_set_i    <= '1';
                    else
                        s2mm_cmnd_data  <= (others => '0');
                        s2mm_cmnd_wr    <= '0';
                        s2mm_eof_set_i    <= '0';

                    end if;
                end if;
            end process GEN_DATAMOVER_CMND;

    end generate GEN_CMD_BTT_EQL_23;

end generate GEN_SM_FOR_LENGTH;


-------------------------------------------------------------------------------
-- Counter for keepting track of pending commands/status in primary datamover
-- Use this to determine if primary datamover for s2mm is Idle.
-------------------------------------------------------------------------------
-- Increment queue count for each command written if not occuring at
-- same time a status from DM being updated to SG engine
count_incr  <= '1' when write_cmnd_cmb = '1' and desc_update_done = '0'
          else '0';

-- Decrement queue count for each status update to SG engine if not occuring
-- at same time as command being written to DM
count_decr  <= '1' when write_cmnd_cmb = '0' and desc_update_done = '1'
          else '0';

-- keep track of number queue commands
CMD2STS_COUNTER : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0' or s2mm_stop = '1')then
                cmnds_queued <= (others => '0');
            elsif(count_incr = '1')then
                cmnds_queued <= std_logic_vector(unsigned(cmnds_queued(COUNTER_WIDTH - 1 downto 0)) + 1);
            elsif(count_decr = '1')then
                cmnds_queued <= std_logic_vector(unsigned(cmnds_queued(COUNTER_WIDTH - 1 downto 0)) - 1);
            end if;
        end if;
    end process CMD2STS_COUNTER;

-- indicate idle when no more queued commands
s2mm_sts_idle <= '1' when  cmnds_queued = ZERO_COUNT
            else '0';
-------------------------------------------------------------------------------
-- Queue only the amount of commands that can be queued on descriptor update
-- else lock up can occur. Note datamover command fifo depth is set to number
-- of descriptors to queue.
-------------------------------------------------------------------------------
--QUEUE_MORE_PROCESS : process(m_axi_sg_aclk)
--    begin
--        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--            if(m_axi_sg_aresetn = '0')then
--                queue_more <= '0';
--            elsif(cmnds_queued < std_logic_vector(to_unsigned(C_PRMY_CMDFIFO_DEPTH,COUNTER_WIDTH)))then
--                queue_more <= '1';
--            else
--                queue_more <= '0';
--            end if;
--        end if;
--    end process QUEUE_MORE_PROCESS;

       queue_more <= '1' when (cmnds_queued < std_logic_vector(to_unsigned(1,COUNTER_WIDTH))) else '0';

end implementation;





-------------------------------------------------------------------------------
-- axi_mcdma_s2mm_cmdsts_if
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:    axi_mcdma_s2mm_cmdsts_if.vhd
-- Description: This entity is the descriptor fetch command and status inteface
--              for the Scatter Gather Engine AXI DataMover.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

library lib_fifo_v1_0_16;

-------------------------------------------------------------------------------
entity  axi_mcdma_s2mm_cmdsts_if is
    generic (
        C_M_AXI_S2MM_ADDR_WIDTH       : integer range 32 to 64          := 32;
            -- Master AXI Memory Map Address Width for S2MM Write Port

        C_DM_STATUS_WIDTH               : integer range 8 to 35         := 8;
            -- Width of DataMover status word
            -- 8  for Determinate BTT Mode
            -- 32 for Indterminate BTT Mode

        C_INCLUDE_SG                : integer range 0 to 1          := 1;
            -- Include or Exclude the Scatter Gather Engine
            -- 0 = Exclude SG Engine - Enables Simple DMA Mode
            -- 1 = Include SG Engine - Enables Scatter Gather Mode

        C_SG_INCLUDE_STSCNTRL_STRM      : integer range 0 to 1          := 1;
            -- Include or Exclude AXI Status and AXI Control Streams
            -- 0 = Exclude Status and Control Streams
            -- 1 = Include Status and Control Streams

        C_SG_USE_STSAPP_LENGTH      : integer range 0 to 1              := 1;
            -- Enable or Disable use of Status Stream Rx Length.  Only valid
            -- if C_SG_INCLUDE_STSCNTRL_STRM = 1
            -- 0 = Don't use Rx Length
            -- 1 = Use Rx Length

        C_SG_LENGTH_WIDTH           : integer range 8 to 26             := 14;
            -- Descriptor Buffer Length, Transferred Bytes, and Status Stream
            -- Rx Length Width.  Indicates the least significant valid bits of
            -- descriptor buffer length, transferred bytes, or Rx Length value
            -- in the status word coincident with tlast.
        C_ASYNC                     : integer range 0 to 1              := 0;
        C_FAMILY                     : string            := "virtex5"

    );
    port (
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               : in  std_logic                         ;                    --
        m_axi_sg_aresetn            : in  std_logic                         ;                    --
        m_axi_s2mm_aclk               : in  std_logic                         ;                    --
        m_axi_s2mm_aresetn            : in  std_logic                         ;                    --
                                                                                                 --
        -- Command write interface from mm2s sm                                                  --
        s2mm_cmnd_wr                : in  std_logic                         ;                    --
        s2mm_cmnd_data              : in  std_logic_vector                                       --
                                        ((C_M_AXI_S2MM_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);   --
        s2mm_cmnd_pending           : out std_logic                         ;                    --
                                                                                                 --
        s2mm_packet_eof             : out std_logic                         ;                    --
                                                                                                 --
        s2mm_sts_received_clr       : in  std_logic                         ;                    --
        s2mm_sts_received           : out std_logic                         ;                    --
        s2mm_tailpntr_enble         : in  std_logic                         ;                    --
        s2mm_desc_cmplt             : in  std_logic                         ;                    --
                                                                                                 --
        -- User Command Interface Ports (AXI Stream)                                             --
        s_axis_s2mm_cmd_tvalid      : out std_logic                         ;                    --
        s_axis_s2mm_cmd_tready      : in  std_logic                         ;                    --
        s_axis_s2mm_cmd_tdata       : out std_logic_vector                                       --
                                        ((C_M_AXI_S2MM_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);   --
                                                                                                 --
        -- User Status Interface Ports (AXI Stream)                                              --
        m_axis_s2mm_sts_tvalid      : in  std_logic                         ;                    --
        m_axis_s2mm_sts_tready      : out std_logic                         ;                    --
        m_axis_s2mm_sts_tdata       : in  std_logic_vector                                       --
                                        (C_DM_STATUS_WIDTH - 1 downto 0)    ;                    --
        m_axis_s2mm_sts_tkeep       : in  std_logic_vector((C_DM_STATUS_WIDTH/8)-1 downto 0);    --
        m_axis_s2mm_sg_side_band    : in  std_logic_vector(11 downto 0);    --
        m_axis_s2mm_sg_side_band_valid    : in  std_logic;    --
        m_axis_s2mm_sg_side_band_s2mm_tuser : in std_logic_vector (15 downto 0);
        m_axis_s2mm_sg_side_band_tuser_valid  : in std_logic;

                                                                                                 --
        -- Scatter Gather Fetch Status                                                           --
        s2mm_err                    : in  std_logic                         ;                    --
        s2mm_sg_side_band           : out std_logic_vector (31 downto 0);
        s2mm_brcvd                  : out std_logic_vector                                       --
                                        (C_SG_LENGTH_WIDTH-1 downto 0)      ;                    --
        s2mm_done                   : out std_logic                         ;                    --
        s2mm_error                  : out std_logic                         ;                    --
        s2mm_interr                 : out std_logic                         ;                    --
        s2mm_slverr                 : out std_logic                         ;                    --
        s2mm_decerr                 : out std_logic                         ;                    --
        s2mm_tag                    : out std_logic_vector(3 downto 0)                           --
    );

end axi_mcdma_s2mm_cmdsts_if;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_s2mm_cmdsts_if is

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal sts_tready           : std_logic := '0';
signal sts_received_i       : std_logic := '0';
signal stale_desc           : std_logic := '0';
signal log_status           : std_logic := '0';

signal s2mm_slverr_i        : std_logic := '0';
signal s2mm_decerr_i        : std_logic := '0';
signal s2mm_interr_i        : std_logic := '0';
signal s2mm_error_or        : std_logic := '0';

signal s2mm_packet_eof_i    : std_logic := '0';
signal smpl_dma_overflow    : std_logic := '0';

signal fifo_rst             : std_logic := '0';
signal fifo_rden_tuser            : std_logic := '0';
signal fifo_rden_tid            : std_logic := '0';
signal fifo_dout  : std_logic_vector (31 downto 0) := (others => '0');
signal fifo_dout_tuser  : std_logic_vector (15 downto 0) := (others => '0');
signal fifo_dout_tid  : std_logic_vector (11 downto 0) := (others => '0');
signal fifo_full  : std_logic := '0';
signal fifo_empty : std_logic := '0';






-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin
s2mm_slverr     <= s2mm_slverr_i;
s2mm_decerr     <= s2mm_decerr_i;
s2mm_interr     <= s2mm_interr_i or smpl_dma_overflow;


s2mm_packet_eof <= s2mm_packet_eof_i;

-- Stale descriptor if complete bit already set and in tail pointer mode.
stale_desc <= '1' when s2mm_desc_cmplt = '1' and s2mm_tailpntr_enble = '1'
         else '0';

-------------------------------------------------------------------------------
-- DataMover Command Interface
-------------------------------------------------------------------------------

fifo_rst <= not m_axi_s2mm_aresetn;

SYNC_FIFO: if C_ASYNC = 0 generate
begin
        -- Generate Synchronous FIFO
    I_STSSTRM_FIFO_TID_TDEST : entity lib_fifo_v1_0_16.sync_fifo_fg
        generic map (
            C_FAMILY                =>  C_FAMILY                ,
            C_MEMORY_TYPE           =>  0, --USE_LOGIC_FIFOS,
            C_WRITE_DATA_WIDTH      =>  12, --C_S_AXIS_S2MM_STS_TDATA_WIDTH + 1,
            C_WRITE_DEPTH           =>  16, --STSSTRM_FIFO_DEPTH       ,
            C_READ_DATA_WIDTH       =>  12, --C_S_AXIS_S2MM_STS_TDATA_WIDTH + 1,
            C_READ_DEPTH            =>  16, --STSSTRM_FIFO_DEPTH       ,
            C_PORTS_DIFFER          =>  0,
            C_HAS_DCOUNT            =>  1, --req for proper fifo operation
            C_DCOUNT_WIDTH          =>  4, --STSSTRM_FIFO_CNT_WIDTH,
            C_HAS_ALMOST_FULL       =>  0,
            C_HAS_RD_ACK            =>  0,
            C_HAS_RD_ERR            =>  0,
            C_HAS_WR_ACK            =>  0,
            C_HAS_WR_ERR            =>  0,
            C_RD_ACK_LOW            =>  0,
            C_RD_ERR_LOW            =>  0,
            C_WR_ACK_LOW            =>  0,
            C_WR_ERR_LOW            =>  0,
            C_PRELOAD_REGS          =>  1,-- 1 = first word fall through
            C_PRELOAD_LATENCY       =>  0 -- 0 = first word fall through

        )
        port map (

            Clk             =>  m_axi_sg_aclk       ,
            Sinit           =>  fifo_rst          ,
            Din             =>  m_axis_s2mm_sg_side_band            ,
            Wr_en           =>  m_axis_s2mm_sg_side_band_valid           ,
            Rd_en           =>  fifo_rden_tid   ,
            Dout            =>  fifo_dout_tid   ,
            Full            =>  fifo_full           ,
            Empty           =>  fifo_empty  ,
            Almost_full     =>  open                ,
            Data_count      =>  open                ,
            Rd_ack          =>  open                ,
            Rd_err          =>  open                ,
            Wr_ack          =>  open                ,
            Wr_err          =>  open

        );


    I_STSSTRM_FIFO_TUSER : entity lib_fifo_v1_0_16.sync_fifo_fg
        generic map (
            C_FAMILY                =>  C_FAMILY                ,
            C_MEMORY_TYPE           =>  0, --USE_LOGIC_FIFOS,
            C_WRITE_DATA_WIDTH      =>  16, --C_S_AXIS_S2MM_STS_TDATA_WIDTH + 1,
            C_WRITE_DEPTH           =>  16, --STSSTRM_FIFO_DEPTH       ,
            C_READ_DATA_WIDTH       =>  16, --C_S_AXIS_S2MM_STS_TDATA_WIDTH + 1,
            C_READ_DEPTH            =>  16, --STSSTRM_FIFO_DEPTH       ,
            C_PORTS_DIFFER          =>  0,
            C_HAS_DCOUNT            =>  1, --req for proper fifo operation
            C_DCOUNT_WIDTH          =>  4, --STSSTRM_FIFO_CNT_WIDTH,
            C_HAS_ALMOST_FULL       =>  0,
            C_HAS_RD_ACK            =>  0,
            C_HAS_RD_ERR            =>  0,
            C_HAS_WR_ACK            =>  0,
            C_HAS_WR_ERR            =>  0,
            C_RD_ACK_LOW            =>  0,
            C_RD_ERR_LOW            =>  0,
            C_WR_ACK_LOW            =>  0,
            C_WR_ERR_LOW            =>  0,
            C_PRELOAD_REGS          =>  1,-- 1 = first word fall through
            C_PRELOAD_LATENCY       =>  0 -- 0 = first word fall through

        )
        port map (

            Clk             =>  m_axi_sg_aclk       ,
            Sinit           =>  fifo_rst          ,
            Din             =>  m_axis_s2mm_sg_side_band_s2mm_tuser            ,
            Wr_en           =>  m_axis_s2mm_sg_side_band_tuser_valid           ,
            Rd_en           =>  fifo_rden_tuser   ,
            Dout            =>  fifo_dout_tuser   ,
            Full            =>  open,
            Empty           =>  open,
            Almost_full     =>  open                ,
            Data_count      =>  open                ,
            Rd_ack          =>  open                ,
            Rd_err          =>  open                ,
            Wr_ack          =>  open                ,
            Wr_err          =>  open

        );

end generate SYNC_FIFO;


ASYNC_FIFO: if C_ASYNC = 1 generate
begin

    -- Generate Asynchronous FIFO
    I_STSSTRM_FIFO_TID_TDEST : entity axi_mcdma_v1_1_8.axi_mcdma_afifo_autord
      generic map(
         C_DWIDTH        => 12, --C_S_AXIS_S2MM_STS_TDATA_WIDTH + 1    ,
--         C_DEPTH         => STSSTRM_FIFO_DEPTH                  ,
--         C_CNT_WIDTH     => STSSTRM_FIFO_CNT_WIDTH              ,
         C_DEPTH         => 16                  ,
         C_CNT_WIDTH     => 5                   ,
         C_USE_BLKMEM    => 0, --USE_LOGIC_FIFOS                     ,
         C_FAMILY        => C_FAMILY
        )
      port map(
        -- Inputs
         AFIFO_Ainit                => fifo_rst               ,
         AFIFO_Wr_clk               => m_axi_s2mm_aclk           ,
         AFIFO_Wr_en                => m_axis_s2mm_sg_side_band_valid                ,
         AFIFO_Din                  => m_axis_s2mm_sg_side_band                 ,
         AFIFO_Rd_clk               => m_axi_sg_aclk            ,
         AFIFO_Rd_en                => fifo_rden_tid        ,
         AFIFO_Clr_Rd_Data_Valid    => '0'                      ,

        -- Outputs
         AFIFO_DValid               => open                     ,
         AFIFO_Dout                 => fifo_dout_tid        ,
         AFIFO_Full                 => fifo_full                ,
         AFIFO_Empty                => fifo_empty       ,
         AFIFO_Almost_full          => open                     ,
         AFIFO_Almost_empty         => open                     ,
         AFIFO_Wr_count             => open                     ,
         AFIFO_Rd_count             => open                     ,
         AFIFO_Corr_Rd_count        => open                     ,
         AFIFO_Corr_Rd_count_minus1 => open                     ,
         AFIFO_Rd_ack               => open
        );

    I_STSSTRM_FIFO_TUSER : entity axi_mcdma_v1_1_8.axi_mcdma_afifo_autord
      generic map(
         C_DWIDTH        => 16, --C_S_AXIS_S2MM_STS_TDATA_WIDTH + 1    ,
--         C_DEPTH         => STSSTRM_FIFO_DEPTH                  ,
--         C_CNT_WIDTH     => STSSTRM_FIFO_CNT_WIDTH              ,
         C_DEPTH         => 16                  ,
         C_CNT_WIDTH     => 5                   ,
         C_USE_BLKMEM    => 0, --USE_LOGIC_FIFOS                     ,
         C_FAMILY        => C_FAMILY
        )
      port map(
        -- Inputs
         AFIFO_Ainit                => fifo_rst               ,
         AFIFO_Wr_clk               => m_axi_s2mm_aclk           ,
         AFIFO_Wr_en                => m_axis_s2mm_sg_side_band_tuser_valid,
         AFIFO_Din                  => m_axis_s2mm_sg_side_band_s2mm_tuser,
         AFIFO_Rd_clk               => m_axi_sg_aclk            ,
         AFIFO_Rd_en                => fifo_rden_tuser        ,
         AFIFO_Clr_Rd_Data_Valid    => '0'                      ,

        -- Outputs
         AFIFO_DValid               => open                     ,
         AFIFO_Dout                 => fifo_dout_tuser        ,
         AFIFO_Full                 => open,
         AFIFO_Empty                => open,
         AFIFO_Almost_full          => open                     ,
         AFIFO_Almost_empty         => open                     ,
         AFIFO_Wr_count             => open                     ,
         AFIFO_Rd_count             => open                     ,
         AFIFO_Corr_Rd_count        => open                     ,
         AFIFO_Corr_Rd_count_minus1 => open                     ,
         AFIFO_Rd_ack               => open
        );

end generate ASYNC_FIFO;

-------------------------------------------------------------------------------
-- When command by fetch sm, drive descriptor fetch command to data mover.
-- Hold until data mover indicates ready.
-------------------------------------------------------------------------------
GEN_DATAMOVER_CMND : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                s_axis_s2mm_cmd_tvalid  <= '0';
                s_axis_s2mm_cmd_tdata   <= (others => '0');
                s2mm_cmnd_pending       <= '0';
            -- new command and descriptor not flagged as stale
            elsif(s2mm_cmnd_wr = '1' and stale_desc = '0')then
                s_axis_s2mm_cmd_tvalid  <= '1';
                s_axis_s2mm_cmd_tdata   <= s2mm_cmnd_data;
                s2mm_cmnd_pending       <= '1';
            -- clear flag on datamover acceptance of command
            elsif(s_axis_s2mm_cmd_tready = '1')then
                s_axis_s2mm_cmd_tvalid  <= '0';
                s_axis_s2mm_cmd_tdata   <= (others => '0');
                s2mm_cmnd_pending       <= '0';
            end if;
        end if;
    end process GEN_DATAMOVER_CMND;


-------------------------------------------------------------------------------
-- DataMover Status Interface
-------------------------------------------------------------------------------
-- Drive ready low during reset to indicate not ready
REG_STS_READY : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                sts_tready <= '0';
            elsif(sts_tready = '1' and m_axis_s2mm_sts_tvalid = '1')then
                sts_tready <= '0';
            elsif(sts_received_i = '0') then
                sts_tready <= '1';
            end if;
        end if;
    end process REG_STS_READY;

-- Pass to DataMover
m_axis_s2mm_sts_tready <= sts_tready;

log_status <= '1' when m_axis_s2mm_sts_tvalid = '1' and sts_received_i = '0'
         else '0';


-- Status stream is included, and using the rxlength from the status stream and in Scatter Gather Mode
DETERMINATE_BTT_MODE : if C_SG_INCLUDE_STSCNTRL_STRM = 1 and C_SG_USE_STSAPP_LENGTH = 1
                       and C_INCLUDE_SG = 1 generate
begin
    -- Bytes received not available in determinate byte mode
    s2mm_brcvd          <= (others => '0');
    -- Simple DMA overflow not used in Scatter Gather Mode
    smpl_dma_overflow   <= '0';

    -------------------------------------------------------------------------------
    -- Log status bits out of data mover.
    -------------------------------------------------------------------------------
    DATAMOVER_STS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    s2mm_done       <= '0';
                    s2mm_slverr_i   <= '0';
                    s2mm_decerr_i   <= '0';
                    s2mm_interr_i   <= '0';
                    s2mm_tag        <= (others => '0');
                -- Status valid, therefore capture status
                elsif(m_axis_s2mm_sts_tvalid = '1' and sts_received_i = '0')then
                    s2mm_done       <= m_axis_s2mm_sts_tdata(DATAMOVER_STS_CMDDONE_BIT);
                    s2mm_slverr_i   <= m_axis_s2mm_sts_tdata(DATAMOVER_STS_SLVERR_BIT);
                    s2mm_decerr_i   <= m_axis_s2mm_sts_tdata(DATAMOVER_STS_DECERR_BIT);
                    s2mm_interr_i   <= m_axis_s2mm_sts_tdata(DATAMOVER_STS_INTERR_BIT);
                    s2mm_tag        <= m_axis_s2mm_sts_tdata(DATAMOVER_STS_TAGMSB_BIT downto DATAMOVER_STS_TAGLSB_BIT);
                -- Only assert when valid
                else
                    s2mm_done      <= '0';
                    s2mm_slverr_i  <= '0';
                    s2mm_decerr_i  <= '0';
                    s2mm_interr_i  <= '0';
                    s2mm_tag       <= (others => '0');
                end if;
            end if;
        end process DATAMOVER_STS;

fifo_rden_tuser <=  '1' when (m_axis_s2mm_sts_tvalid = '1' and sts_received_i = '0' and (m_axis_s2mm_sts_tdata(DATAMOVER_STS_TAGEOF_BIT) = '1' or m_axis_s2mm_sts_tdata(DATAMOVER_STS_INTERR_BIT) = '1')) else '0';
fifo_rden_tid <=  '1' when (m_axis_s2mm_sts_tvalid = '1' and sts_received_i = '0' and (m_axis_s2mm_sts_tdata(DATAMOVER_STS_TAGEOF_BIT) = '1' or m_axis_s2mm_sts_tdata(DATAMOVER_STS_INTERR_BIT) = '1') and fifo_empty = '0') else '0';

    DATAMOVER_STS_SB : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    s2mm_sg_side_band(15 downto 0) <= (others => '0');
                -- Status valid, therefore capture status
                --elsif(m_axis_s2mm_sts_tvalid = '1' and sts_received_i = '0' and (m_axis_s2mm_sts_tdata(DATAMOVER_STS_TAGEOF_BIT) = '1' or m_axis_s2mm_sts_tdata(DATAMOVER_STS_INTERR_BIT) = '1'))then
                elsif(m_axis_s2mm_sts_tvalid = '1' and sts_received_i = '0' and (m_axis_s2mm_sts_tdata(DATAMOVER_STS_TAGEOF_BIT) = '1' or m_axis_s2mm_sts_tdata(DATAMOVER_STS_INTERR_BIT) = '1'))then
                    s2mm_sg_side_band (15 downto 0) <= fifo_dout_tuser;  --put tuser bit
                -- Only assert when valid
                else
                    s2mm_sg_side_band  (15 downto 0)<= (others => '0');
                end if;
            end if;
        end process DATAMOVER_STS_SB;

    DATAMOVER_STS_SB1 : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    s2mm_sg_side_band (31 downto 16) <= (others => '0');
                -- Status valid, therefore capture status
                --elsif(m_axis_s2mm_sts_tvalid = '1' and sts_received_i = '0' and (m_axis_s2mm_sts_tdata(DATAMOVER_STS_TAGEOF_BIT) = '1' or m_axis_s2mm_sts_tdata(DATAMOVER_STS_INTERR_BIT) = '1'))then
                elsif(m_axis_s2mm_sts_tvalid = '1' and sts_received_i = '0')then
                    s2mm_sg_side_band (31 downto 16) <= fifo_dout_tid (11 downto 4) & "0000" & fifo_dout_tid (3 downto 0); -- put tid and tdest
                -- Only assert when valid
                else
                    s2mm_sg_side_band  (31 downto 16)<= (others => '0');
                end if;
            end if;
        end process DATAMOVER_STS_SB1;

    -- End Of Frame (EOF = 1) detected on status received. Used
    -- for interrupt delay timer
    REG_RX_EOF : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    s2mm_packet_eof_i <= '0';
                elsif(log_status = '1')then
                    s2mm_packet_eof_i <=  m_axis_s2mm_sts_tdata(DATAMOVER_STS_TAGEOF_BIT)
                                       or m_axis_s2mm_sts_tdata(DATAMOVER_STS_INTERR_BIT);
                else
                    s2mm_packet_eof_i <= '0';
                end if;
            end if;
        end process REG_RX_EOF;


end generate DETERMINATE_BTT_MODE;

-- No Status Stream or not using rxlength from status stream or in Simple DMA Mode
INDETERMINATE_BTT_MODE : if C_SG_INCLUDE_STSCNTRL_STRM = 0 or C_SG_USE_STSAPP_LENGTH = 0
                         or C_INCLUDE_SG = 0 generate

-- Bytes received MSB index bit
constant BRCVD_MSB_BIT : integer := (C_DM_STATUS_WIDTH - 2) - (BUFFER_LENGTH_WIDTH - C_SG_LENGTH_WIDTH);
-- Bytes received LSB index bit
constant BRCVD_LSB_BIT : integer := (C_DM_STATUS_WIDTH - 2) - (BUFFER_LENGTH_WIDTH - 1);

begin

    -------------------------------------------------------------------------------
    -- Log status bits out of data mover.
    -------------------------------------------------------------------------------
    DATAMOVER_STS : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    s2mm_brcvd      <= (others => '0');
                    s2mm_done       <= '0';
                    s2mm_slverr_i   <= '0';
                    s2mm_decerr_i   <= '0';
                    s2mm_interr_i   <= '0';
                    s2mm_tag        <= (others => '0');
    --                s2mm_sg_side_band <= (others => '0');
                -- Status valid, therefore capture status
                elsif(m_axis_s2mm_sts_tvalid = '1' and sts_received_i = '0')then
                    s2mm_brcvd      <= m_axis_s2mm_sts_tdata(BRCVD_MSB_BIT downto BRCVD_LSB_BIT);
                    s2mm_done       <= m_axis_s2mm_sts_tdata(DATAMOVER_STS_CMDDONE_BIT);
                    s2mm_slverr_i   <= m_axis_s2mm_sts_tdata(DATAMOVER_STS_SLVERR_BIT);
                    s2mm_decerr_i   <= m_axis_s2mm_sts_tdata(DATAMOVER_STS_DECERR_BIT);
                    s2mm_interr_i   <= m_axis_s2mm_sts_tdata(DATAMOVER_STS_INTERR_BIT);
                    s2mm_tag        <= m_axis_s2mm_sts_tdata(DATAMOVER_STS_TAGMSB_BIT downto DATAMOVER_STS_TAGLSB_BIT);
    --                s2mm_sg_side_band <= m_axis_s2mm_sg_side_band;
                -- Only assert when valid
                else
                    s2mm_brcvd     <= (others => '0');
                    s2mm_done      <= '0';
                    s2mm_slverr_i  <= '0';
                    s2mm_decerr_i  <= '0';
                    s2mm_interr_i  <= '0';
                    s2mm_tag       <= (others => '0');
    --                s2mm_sg_side_band <= (others => '0');
                end if;
            end if;
        end process DATAMOVER_STS;

fifo_rden_tuser <= '1' when (m_axis_s2mm_sts_tvalid = '1' and sts_received_i = '0' and (m_axis_s2mm_sts_tdata(DATAMOVER_STS_TLAST_BIT) = '1' or m_axis_s2mm_sts_tdata(DATAMOVER_STS_INTERR_BIT) = '1')) else '0';
fifo_rden_tid <= '1' when (m_axis_s2mm_sts_tvalid = '1' and sts_received_i = '0' and (m_axis_s2mm_sts_tdata(DATAMOVER_STS_TLAST_BIT) = '1' or m_axis_s2mm_sts_tdata(DATAMOVER_STS_INTERR_BIT) = '1') and fifo_empty = '0') else '0';

    DATAMOVER_STS_SB : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    s2mm_sg_side_band  (15 downto 0)<= (others => '0');
                -- Status valid, therefore capture status
                elsif(m_axis_s2mm_sts_tvalid = '1' and sts_received_i = '0' and (m_axis_s2mm_sts_tdata(DATAMOVER_STS_TLAST_BIT) = '1' or m_axis_s2mm_sts_tdata(DATAMOVER_STS_INTERR_BIT) = '1'))then
                    s2mm_sg_side_band (15 downto 0) <= fifo_dout_tuser; --m_axis_s2mm_sg_side_band;
                -- Only assert when valid
                else
                    s2mm_sg_side_band  (15 downto 0)<= (others => '0');
                end if;
            end if;
        end process DATAMOVER_STS_SB;

    DATAMOVER_STS_SB1 : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    s2mm_sg_side_band  (31 downto 16)<= (others => '0');
                -- Status valid, therefore capture status
                elsif(m_axis_s2mm_sts_tvalid = '1' and sts_received_i = '0')then
                    s2mm_sg_side_band (31 downto 16) <= fifo_dout_tid (11 downto 4) & "0000" & fifo_dout_tid (3 downto 0); -- put tid and tdest
                -- Only assert when valid
                else
                    s2mm_sg_side_band  (31 downto 16)<= (others => '0');
                end if;
            end if;
        end process DATAMOVER_STS_SB1;

    -- End Of Frame (EOF = 1) detected on statis received. Used
    -- for interrupt delay timer
    REG_RX_EOF : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    s2mm_packet_eof_i <= '0';
                elsif(log_status = '1')then
                    s2mm_packet_eof_i <=  m_axis_s2mm_sts_tdata(DATAMOVER_STS_TLAST_BIT)
                                       or m_axis_s2mm_sts_tdata(DATAMOVER_STS_INTERR_BIT);
                else
                    s2mm_packet_eof_i <= '0';
                end if;
            end if;
        end process REG_RX_EOF;

    -- If in Simple DMA mode then generate overflow flag
    GEN_OVERFLOW_SMPL_DMA : if C_INCLUDE_SG = 0 generate
        REG_OVERFLOW : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0')then
                        smpl_dma_overflow <= '0';
                    -- If status received and TLAST bit is NOT set then packet is bigger than
                    -- BTT value commanded which is an invalid command
                    elsif(log_status = '1' and m_axis_s2mm_sts_tdata(DATAMOVER_STS_TLAST_BIT) = '0')then
                        smpl_dma_overflow <= '1';
                    end if;
                end if;
            end process REG_OVERFLOW;
    end generate GEN_OVERFLOW_SMPL_DMA;

    -- If in Scatter Gather Mode then do NOT generate simple dma mode overflow flag
    GEN_NO_OVERFLOW_SMPL_DMA : if C_INCLUDE_SG = 1 generate
    begin
        smpl_dma_overflow <= '0';
    end generate GEN_NO_OVERFLOW_SMPL_DMA;

end generate INDETERMINATE_BTT_MODE;





-- Flag when status is received.  Used to hold status until sg if
-- can use status.  This only has meaning when SG Engine Queues are turned
-- on
STS_RCVD_FLAG : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0' or s2mm_sts_received_clr = '1')then
                sts_received_i  <= '0';
            -- Status valid, therefore capture status
            elsif(m_axis_s2mm_sts_tvalid = '1' and sts_received_i = '0')then
                sts_received_i  <= '1';
            end if;
        end if;
    end process STS_RCVD_FLAG;

s2mm_sts_received    <= sts_received_i;

-------------------------------------------------------------------------------
-- Register global error from data mover.
-------------------------------------------------------------------------------
s2mm_error_or <= s2mm_slverr_i or s2mm_decerr_i or s2mm_interr_i or smpl_dma_overflow;

-- Log errors into a global error output
S2MM_ERROR_PROCESS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                s2mm_error <= '0';
            -- If Datamover issues error on the transfer or if a stale descriptor is
            -- detected when in tailpointer mode then issue an error
            elsif((s2mm_error_or = '1')
               or (stale_desc = '1' and s2mm_cmnd_wr='1'))then
                s2mm_error <= '1';
            end if;
        end if;
    end process S2MM_ERROR_PROCESS;



end implementation;




--  (c) Copyright 2012 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
------------------------------------------------------------
-------------------------------------------------------------------------------
-- Filename:    axi_mcdma_s2mm_sts_mngr.vhd
-- Description: This entity mangages 'halt' and 'idle' status for the S2MM
--              channel
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library lib_cdc_v1_0_2;
library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_mcdma_s2mm_sts_mngr is
    generic (
        C_PRMRY_IS_ACLK_ASYNC        : integer range 0 to 1          := 0
            -- Primary MM2S/S2MM sync/async mode
            -- 0 = synchronous mode     - all clocks are synchronous
            -- 1 = asynchronous mode    - Any one of the 4 clock inputs is not
            --                            synchronous to the other
    );
    port (
        -----------------------------------------------------------------------
        -- AXI Scatter Gather Interface
        -----------------------------------------------------------------------
        m_axi_sg_aclk               : in  std_logic                         ;          --
        m_axi_sg_aresetn            : in  std_logic                         ;          --
                                                                                       --
        -- system state                                                                --
        s2mm_run_stop               : in  std_logic                         ;          --
        s2mm_ftch_idle              : in  std_logic                         ;          --
        s2mm_updt_idle              : in  std_logic                         ;          --
        s2mm_cmnd_idle              : in  std_logic                         ;          --
        s2mm_sts_idle               : in  std_logic                         ;          --
                                                                                       --
        -- stop and halt control/status                                                --
        s2mm_stop                   : in  std_logic                         ;          --
        s2mm_halt_cmplt             : in  std_logic                         ;          --
                                                                                       --
        -- system control                                                              --
        s2mm_all_idle               : out std_logic                         ;          --
        s2mm_halted_clr             : out std_logic                         ;          --
        s2mm_halted_set             : out std_logic                         ;          --
        s2mm_idle_set               : out std_logic                         ;          --
        s2mm_idle_clr               : out std_logic                                    --

    );

end axi_mcdma_s2mm_sts_mngr;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_s2mm_sts_mngr is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";


  ATTRIBUTE async_reg                      : STRING;

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------

signal all_is_idle          : std_logic := '0';
signal all_is_idle_d1       : std_logic := '0';
signal all_is_idle_re       : std_logic := '0';
signal all_is_idle_fe       : std_logic := '0';
signal s2mm_datamover_idle  : std_logic := '0';

signal s2mm_halt_cmpt_d1_cdc_tig    : std_logic := '0';
signal s2mm_halt_cmpt_cdc_d2    : std_logic := '0';
signal s2mm_halt_cmpt_d2    : std_logic := '0';
  --ATTRIBUTE async_reg OF s2mm_halt_cmpt_d1_cdc_tig  : SIGNAL IS "true";
  --ATTRIBUTE async_reg OF s2mm_halt_cmpt_cdc_d2  : SIGNAL IS "true";

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin
-- all is idle when all is idle
all_is_idle <=  s2mm_ftch_idle
            and s2mm_updt_idle
            and s2mm_cmnd_idle
            and s2mm_sts_idle;


s2mm_all_idle   <= all_is_idle;

-------------------------------------------------------------------------------
-- For data mover halting look at halt complete to determine when halt
-- is done and datamover has completly halted.  If datamover not being
-- halted then can ignore flag thus simply flag as idle.
-------------------------------------------------------------------------------
GEN_FOR_ASYNC : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
begin
    -- Double register to secondary clock domain.  This is sufficient
    -- because halt_cmplt will remain asserted until detected in
    -- reset module in secondary clock domain.
REG_TO_SECONDARY : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => s2mm_halt_cmplt,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => s2mm_halt_cmpt_cdc_d2,
        scndry_vect_out            => open
    );

--    REG_TO_SECONDARY : process(m_axi_sg_aclk)
--        begin
--            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
----                if(m_axi_sg_aresetn = '0')then
----                    s2mm_halt_cmpt_d1_cdc_tig <= '0';
----                    s2mm_halt_cmpt_d2 <= '0';
----                else
--                    s2mm_halt_cmpt_d1_cdc_tig <= s2mm_halt_cmplt;
--                    s2mm_halt_cmpt_cdc_d2 <= s2mm_halt_cmpt_d1_cdc_tig;
----                end if;
--            end if;
--        end process REG_TO_SECONDARY;

                    s2mm_halt_cmpt_d2 <= s2mm_halt_cmpt_cdc_d2;

end generate GEN_FOR_ASYNC;

GEN_FOR_SYNC : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
begin
    -- No clock crossing required therefore simple pass through
    s2mm_halt_cmpt_d2 <= s2mm_halt_cmplt;

end generate GEN_FOR_SYNC;

s2mm_datamover_idle  <= '1' when (s2mm_stop = '1' and s2mm_halt_cmpt_d2 = '1')
                              or (s2mm_stop = '0')
                   else '0';

-------------------------------------------------------------------------------
-- Set halt bit if run/stop cleared and all processes are idle
-------------------------------------------------------------------------------
HALT_PROCESS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                s2mm_halted_set <= '0';
            elsif(s2mm_run_stop = '0' and all_is_idle = '1' and s2mm_datamover_idle = '1')then
                s2mm_halted_set <= '1';
            else
                s2mm_halted_set <=  '0';
            end if;
        end if;
    end process HALT_PROCESS;

-------------------------------------------------------------------------------
-- Clear halt bit if run/stop is set and SG engine begins to fetch descriptors
-------------------------------------------------------------------------------
NOT_HALTED_PROCESS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                s2mm_halted_clr <= '0';
            elsif(s2mm_run_stop = '1')then
                s2mm_halted_clr <= '1';
            else
                s2mm_halted_clr <= '0';
            end if;
        end if;
    end process NOT_HALTED_PROCESS;

-------------------------------------------------------------------------------
-- Register ALL is Idle to create rising and falling edges on idle flag
-------------------------------------------------------------------------------
IDLE_REG_PROCESS : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
                all_is_idle_d1 <= '0';
            else
                all_is_idle_d1 <= all_is_idle;
            end if;
        end if;
    end process IDLE_REG_PROCESS;

all_is_idle_re  <= all_is_idle and not all_is_idle_d1;
all_is_idle_fe  <= not all_is_idle and all_is_idle_d1;

-- Set or Clear IDLE bit in DMASR
s2mm_idle_set <= all_is_idle_re and s2mm_run_stop;
s2mm_idle_clr <= all_is_idle_fe;


end implementation;


-------------------------------------------------------------------------------
-- axi_mcdma_s2mm_sts_strm.vhd
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_mcdma_s2mm_sts_strm.vhd.vhd
-- Description: This entity is the AXI Status Stream Interface
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.all;

library lib_fifo_v1_0_16;
library lib_cdc_v1_0_2;

-------------------------------------------------------------------------------
entity  axi_mcdma_s2mm_sts_strm is
    generic (

        C_PRMRY_IS_ACLK_ASYNC           : integer range 0 to 1         := 0;
            -- Primary MM2S/S2MM sync/async mode
            -- 0 = synchronous mode     - all clocks are synchronous
            -- 1 = asynchronous mode    - Primary data path channels (MM2S and S2MM)
            --                            run asynchronous to AXI Lite, DMA Control,
            --                            and SG.

        -----------------------------------------------------------------------
        -- Scatter Gather Parameters
        -----------------------------------------------------------------------
        C_S_AXIS_S2MM_STS_TDATA_WIDTH   : integer range 32 to 32        := 32;
            -- Slave AXI Status Stream Data Width

        C_SG_USE_STSAPP_LENGTH          : integer range 0 to 1          := 1;
            -- Enable or Disable use of Status Stream Rx Length.  Only valid
            -- if C_SG_INCLUDE_STSCNTRL_STRM = 1
            -- 0 = Don't use Rx Length
            -- 1 = Use Rx Length

        C_SG_LENGTH_WIDTH               : integer range 8 to 26         := 14;
            -- Descriptor Buffer Length, Transferred Bytes, and Status Stream
            -- Rx Length Width.  Indicates the least significant valid bits of
            -- descriptor buffer length, transferred bytes, or Rx Length value
            -- in the status word coincident with tlast.

        C_FAMILY                        : string            := "virtex5"
            -- Target FPGA Device Family

    );
    port (

        m_axi_sg_aclk               : in  std_logic                         ;                  --
        m_axi_sg_aresetn            : in  std_logic                         ;                  --
                                                                                               --
        axi_prmry_aclk              : in  std_logic                         ;                  --
        p_reset_n                   : in  std_logic                         ;                  --
                                                                                               --
        s2mm_stop                   : in  std_logic                         ;                  --
                                                                                               --
        s2mm_rxlength_valid         : out std_logic                         ;                  --
        s2mm_rxlength_clr           : in  std_logic                         ;                  --
        s2mm_rxlength               : out std_logic_vector                                     --
                                        (C_SG_LENGTH_WIDTH - 1 downto 0)    ;                  --
        accept_sts                  : in std_logic;
        reject_sts                  : in std_logic;
        sts_busy                    : out std_logic;
                                                                                               --
        stsstrm_fifo_rden           : in  std_logic                         ;                  --
        stsstrm_fifo_empty          : out std_logic                         ;                  --
        stsstrm_fifo_dout           : out std_logic_vector                                     --
                                        (C_S_AXIS_S2MM_STS_TDATA_WIDTH downto 0);              --
                                                                                               --
        -- Stream to Memory Map Status Stream Interface                                        --
        s_axis_s2mm_sts_tdata       : in  std_logic_vector                                     --
                                        (C_S_AXIS_S2MM_STS_TDATA_WIDTH-1 downto 0);            --
        s_axis_s2mm_sts_tkeep       : in  std_logic_vector                                     --
                                        ((C_S_AXIS_S2MM_STS_TDATA_WIDTH/8)-1 downto 0);        --
        s_axis_s2mm_sts_tvalid      : in  std_logic                         ;                  --
        s_axis_s2mm_sts_tready      : out std_logic                         ;                  --
        s_axis_s2mm_sts_tlast       : in  std_logic                                            --
    );

end axi_mcdma_s2mm_sts_strm;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_s2mm_sts_strm is

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
-- Status Stream FIFO Depth
constant STSSTRM_FIFO_DEPTH     : integer := 16;
-- Status Stream FIFO Data Count Width (Unsused)
constant STSSTRM_FIFO_CNT_WIDTH : integer := clog2(STSSTRM_FIFO_DEPTH+1);

constant USE_LOGIC_FIFOS        : integer   := 0; -- Use Logic FIFOs
constant USE_BRAM_FIFOS         : integer   := 1; -- Use BRAM FIFOs

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal fifo_full        : std_logic := '0';
signal fifo_din         : std_logic_vector(C_S_AXIS_S2MM_STS_TDATA_WIDTH downto 0) := (others => '0');
signal fifo_wren        : std_logic := '0';
signal fifo_sinit       : std_logic := '0';

signal rxlength         : std_logic_vector(C_SG_LENGTH_WIDTH-1 downto 0) := (others => '0');
signal rxlength_valid   : std_logic := '0';

signal rxlength_cdc_from         : std_logic_vector(C_SG_LENGTH_WIDTH-1 downto 0) := (others => '0');
signal rxlength_valid_cdc_from   : std_logic := '0';

    signal rxlength_valid_trdy : std_logic := '0';


--signal sts_tvalid_re    : std_logic := '0';-- CR565502
--signal sts_tvalid_d1    : std_logic := '0';-- CR565502

signal sts_tvalid       : std_logic := '0';
signal sts_tready       : std_logic := '0';
signal sts_tdata        : std_logic_vector(C_S_AXIS_S2MM_STS_TDATA_WIDTH-1 downto 0) := (others => '0');
signal sts_tkeep        : std_logic_vector((C_S_AXIS_S2MM_STS_TDATA_WIDTH/8)-1 downto 0) := (others => '0');
signal sts_tlast        : std_logic := '0';

signal m_tvalid         : std_logic := '0';
signal m_tready         : std_logic := '0';
signal m_tdata          : std_logic_vector(C_S_AXIS_S2MM_STS_TDATA_WIDTH-1 downto 0) := (others => '0');
signal m_tkeep          : std_logic_vector((C_S_AXIS_S2MM_STS_TDATA_WIDTH/8)-1 downto 0) := (others => '0');
signal m_tlast          : std_logic := '0';



signal tag_stripped     : std_logic := '0';
signal mask_tag_write   : std_logic := '0';
--signal mask_tag_hold    : std_logic := '0';-- CR565502

signal skid_rst         : std_logic := '0';

signal accepted : std_logic;
signal trdy_ctrl : std_logic;
signal beat_count : std_logic_vector (3 downto 0);
signal s_axis_s2mm_sts_tready_i : std_logic;
signal s_axis_s2mm_sts_tready_int : std_logic;
signal s_axis_s2mm_sts_tvalid_i : std_logic;
signal drop_trdy : std_logic;
signal tlast_received : std_logic;

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

sts_busy <= accepted or drop_trdy;

-- tready has to be controlled based on the packet_drop
-- the STS stream for packet that is being dropped should also be dropped
-- it is expected that S2mm data and STS strm are asserted at the same time.
-- After every packet is accepted the tready will be held high for 5 beats and data not written 
-- After every packet is rejected the tready will be held high for 5 beats and data not written
-- accept_sts means tready have to accepted and data written
-- reject_sts means tready have to accepted and data not written

s_axis_s2mm_sts_tready <= drop_trdy when (trdy_ctrl = '1') else s_axis_s2mm_sts_tready_i; 
s_axis_s2mm_sts_tready_int <= drop_trdy when (trdy_ctrl = '1') else s_axis_s2mm_sts_tready_i; 
s_axis_s2mm_sts_tvalid_i <= s_axis_s2mm_sts_tvalid when (accepted = '1') else '0';

process (axi_prmry_aclk)
begin
     if (axi_prmry_aclk'event and axi_prmry_aclk = '1') then
        if (p_reset_n = '0' or tlast_received = '1') then
           trdy_ctrl <= '1';
        elsif (reject_sts = '1') then
           trdy_ctrl <= '1';   
        elsif (accept_sts = '1') then
           trdy_ctrl <= '0';   
        end if;
     end if;
end process;

process (axi_prmry_aclk)
begin
     if (axi_prmry_aclk'event and axi_prmry_aclk = '1') then
        if (p_reset_n = '0') then
           accepted <= '0';
        elsif (accept_sts = '1') then
           accepted <= '1';   
        elsif (tlast_received = '1') then
           accepted <= '0';   
        end if;
     end if;
end process;

process (axi_prmry_aclk)
begin
     if (axi_prmry_aclk'event and axi_prmry_aclk = '1') then
        if (p_reset_n = '0' or tlast_received = '1') then
           drop_trdy <= '0';
        elsif (reject_sts = '1') then
           drop_trdy <= '1';   
        end if;
     end if;
end process;

tlast_received <= s_axis_s2mm_sts_tvalid and s_axis_s2mm_sts_tready_int and s_axis_s2mm_sts_tlast;



-- Primary Clock is synchronous to Secondary Clock therfore
-- instantiate a sync fifo.
GEN_SYNC_FIFO : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
signal s2mm_stop_d1 : std_logic := '0';
signal s2mm_stop_re : std_logic := '0';
begin
        -- Generate Synchronous FIFO
    I_STSSTRM_FIFO : entity lib_fifo_v1_0_16.sync_fifo_fg
        generic map (
            C_FAMILY                =>  C_FAMILY                ,
            C_MEMORY_TYPE           =>  USE_LOGIC_FIFOS,
            C_WRITE_DATA_WIDTH      =>  C_S_AXIS_S2MM_STS_TDATA_WIDTH + 1,
            C_WRITE_DEPTH           =>  STSSTRM_FIFO_DEPTH       ,
            C_READ_DATA_WIDTH       =>  C_S_AXIS_S2MM_STS_TDATA_WIDTH + 1,
            C_READ_DEPTH            =>  STSSTRM_FIFO_DEPTH       ,
            C_PORTS_DIFFER          =>  0,
            C_HAS_DCOUNT            =>  1, --req for proper fifo operation
            C_DCOUNT_WIDTH          =>  STSSTRM_FIFO_CNT_WIDTH,
            C_HAS_ALMOST_FULL       =>  0,
            C_HAS_RD_ACK            =>  0,
            C_HAS_RD_ERR            =>  0,
            C_HAS_WR_ACK            =>  0,
            C_HAS_WR_ERR            =>  0,
            C_RD_ACK_LOW            =>  0,
            C_RD_ERR_LOW            =>  0,
            C_WR_ACK_LOW            =>  0,
            C_WR_ERR_LOW            =>  0,
            C_PRELOAD_REGS          =>  1,-- 1 = first word fall through
            C_PRELOAD_LATENCY       =>  0, -- 0 = first word fall through
            C_XPM_FIFO              =>  1

        )
        port map (

            Clk             =>  m_axi_sg_aclk       ,
            Sinit           =>  fifo_sinit          ,
            Din             =>  fifo_din            ,
            Wr_en           =>  fifo_wren           ,
            Rd_en           =>  stsstrm_fifo_rden   ,
            Dout            =>  stsstrm_fifo_dout   ,
            Full            =>  fifo_full           ,
            Empty           =>  stsstrm_fifo_empty  ,
            Almost_full     =>  open                ,
            Data_count      =>  open                ,
            Rd_ack          =>  open                ,
            Rd_err          =>  open                ,
            Wr_ack          =>  open                ,
            Wr_err          =>  open

        );

    fifo_sinit              <= not m_axi_sg_aresetn;
    fifo_din                <= sts_tlast & sts_tdata;
    fifo_wren               <= sts_tvalid and not fifo_full and not rxlength_valid and not mask_tag_write;
    sts_tready              <= not fifo_sinit and not fifo_full and not rxlength_valid;


-- CR565502 - particular throttle condition caused masking of tag write to not occur
-- simplified logic will provide more robust handling of tag write mask
--    -- Create register delay of status tvalid in order to create a
--    -- rising edge pulse.  note xx_re signal will hold at 1 if
--    -- fifo full on rising edge of tvalid.
--    REG_TVALID : process(axi_prmry_aclk)
--        begin
--            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--                if(m_axi_sg_aresetn = '0')then
--                    sts_tvalid_d1 <= '0';
--                elsif(fifo_full = '0')then
--                    sts_tvalid_d1 <= sts_tvalid;
--                end if;
--            end if;
--        end process REG_TVALID;
--
--    -- rising edge on tvalid used to gate off status tag from being
--    -- writen into fifo.
--    sts_tvalid_re <= sts_tvalid and not sts_tvalid_d1;

    REG_TAG_STRIPPED : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    tag_stripped <= '0';
                -- Reset on write of last word
                elsif(fifo_wren = '1' and sts_tlast = '1')then
                    tag_stripped <= '0';
                -- Set on beginning of new status stream
                elsif(sts_tready = '1' and sts_tvalid = '1')then
                    tag_stripped <= '1';
                end if;
            end if;
        end process REG_TAG_STRIPPED;

-- CR565502 - particular throttle condition caused masking of tag write to not occur
-- simplified logic will provide more robust handling of tag write mask
--    REG_MASK_TAG : process(m_axi_sg_aclk)
--        begin
--            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--                if(m_axi_sg_aresetn = '0')then
--                    mask_tag_hold <= '0';
--                elsif((sts_tvalid_re = '1' and tag_stripped = '0')
--                   or (fifo_wren = '1' and sts_tlast = '1'))then
--                    mask_tag_hold <= '1';
--                elsif(tag_stripped = '1')then
--                    mask_tag_hold <= '0';
--                end if;
--            end if;
--        end process;
--
--    -- Mask TAG if not already masked and rising edge of tvalid
--    mask_tag_write <= not tag_stripped and (sts_tvalid_re or mask_tag_hold);
    mask_tag_write <= not tag_stripped and sts_tready and sts_tvalid;

    -- Generate logic to capture receive length when Use Receive Length is
    -- enabled
    GEN_STS_APP_LENGTH : if C_SG_USE_STSAPP_LENGTH = 1 generate
    begin
        -- Register receive length on assertion of last and valid
        -- Mark rxlength as valid for higher processes
        REG_RXLENGTH : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0' or s2mm_rxlength_clr = '1')then
                        rxlength       <= (others => '0');
                        rxlength_valid <= '0';
                    elsif(sts_tlast = '1' and sts_tvalid = '1' and sts_tready = '1')then
                        rxlength       <= sts_tdata(C_SG_LENGTH_WIDTH-1 downto 0);
                        rxlength_valid <= '1';
                    end if;
                end if;
            end process REG_RXLENGTH;

        s2mm_rxlength_valid <= rxlength_valid;
        s2mm_rxlength       <= rxlength;

    end generate GEN_STS_APP_LENGTH;

    -- Do NOT generate logic to capture receive length when option disabled
    GEN_NO_STS_APP_LENGTH : if C_SG_USE_STSAPP_LENGTH = 0 generate
    begin
        s2mm_rxlength_valid <= '0';
        s2mm_rxlength       <= (others => '0');
    end generate GEN_NO_STS_APP_LENGTH;

    -- register stop to create re pulse
    REG_STOP : process(axi_prmry_aclk)
        begin
            if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
                if(p_reset_n = '0')then
                    s2mm_stop_d1 <= '0';
                else
                    s2mm_stop_d1 <= s2mm_stop;
                end if;
            end if;
        end process REG_STOP;

    s2mm_stop_re <= s2mm_stop and not s2mm_stop_d1;

    skid_rst   <= not m_axi_sg_aresetn;

    ---------------------------------------------------------------------------
    -- Buffer AXI Signals
    ---------------------------------------------------------------------------
    STS_SKID_BUF_I : entity axi_mcdma_v1_1_8.axi_mcdma_skid_buf
        generic map(
            C_WDATA_WIDTH       => C_S_AXIS_S2MM_STS_TDATA_WIDTH
        )
        port map(
            -- System Ports
            ACLK                => m_axi_sg_aclk                            ,
            ARST                => skid_rst                                 ,

            skid_stop           => s2mm_stop_re                             ,

            -- Slave Side (Stream Data Input)
            S_VALID             => s_axis_s2mm_sts_tvalid_i                   ,
            S_READY             => s_axis_s2mm_sts_tready_i                   ,
            S_Data              => s_axis_s2mm_sts_tdata                    ,
            S_STRB              => s_axis_s2mm_sts_tkeep                    ,
            S_Last              => s_axis_s2mm_sts_tlast                    ,

            -- Master Side (Stream Data Output
            M_VALID             => sts_tvalid                               ,
            M_READY             => sts_tready                               ,
            M_Data              => sts_tdata                                ,
            M_STRB              => sts_tkeep                                ,
            M_Last              => sts_tlast
        );

end generate GEN_SYNC_FIFO;


-- Primary Clock is asynchronous to Secondary Clock therfore
-- instantiate an async fifo.
GEN_ASYNC_FIFO : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
signal s2mm_stop_reg   : std_logic := '0'; -- CR605883
signal p_s2mm_stop_cdc_to  : std_logic := '0';
signal p_s2mm_stop_d2  : std_logic := '0';
signal p_s2mm_stop_d3  : std_logic := '0';
signal p_s2mm_stop_d4  : std_logic := '0';
signal p_s2mm_stop_re  : std_logic := '0';
ATTRIBUTE async_reg                           : STRING;
ATTRIBUTE async_reg OF p_s2mm_stop_cdc_to                       : signal IS "true";
ATTRIBUTE async_reg OF p_s2mm_stop_d2                       : signal IS "true";

begin



    -- Generate Asynchronous FIFO
    I_STSSTRM_FIFO : entity axi_mcdma_v1_1_8.axi_mcdma_afifo_autord
      generic map(
         C_DWIDTH        => C_S_AXIS_S2MM_STS_TDATA_WIDTH + 1    ,
--         C_DEPTH         => STSSTRM_FIFO_DEPTH                  ,
--         C_CNT_WIDTH     => STSSTRM_FIFO_CNT_WIDTH              ,
         C_DEPTH         => 16                  ,
         C_CNT_WIDTH     => 5                   ,
         C_USE_BLKMEM    => USE_LOGIC_FIFOS                     ,
         C_FAMILY        => C_FAMILY
        )
      port map(
        -- Inputs
         AFIFO_Ainit                => fifo_sinit               ,
         AFIFO_Wr_clk               => axi_prmry_aclk           ,
         AFIFO_Wr_en                => fifo_wren                ,
         AFIFO_Din                  => fifo_din                 ,
         AFIFO_Rd_clk               => m_axi_sg_aclk            ,
         AFIFO_Rd_en                => stsstrm_fifo_rden        ,
         AFIFO_Clr_Rd_Data_Valid    => '0'                      ,

        -- Outputs
         AFIFO_DValid               => open                     ,
         AFIFO_Dout                 => stsstrm_fifo_dout        ,
         AFIFO_Full                 => fifo_full                ,
         AFIFO_Empty                => stsstrm_fifo_empty       ,
         AFIFO_Almost_full          => open                     ,
         AFIFO_Almost_empty         => open                     ,
         AFIFO_Wr_count             => open                     ,
         AFIFO_Rd_count             => open                     ,
         AFIFO_Corr_Rd_count        => open                     ,
         AFIFO_Corr_Rd_count_minus1 => open                     ,
         AFIFO_Rd_ack               => open
        );

    fifo_sinit              <= not p_reset_n;

    fifo_din                <= sts_tlast & sts_tdata;
    fifo_wren               <= sts_tvalid               -- valid data
                                and not fifo_full       -- fifo has room
                                and not rxlength_valid_trdy --rxlength_valid_cdc_from  -- not holding a valid length
                                and not mask_tag_write; -- not masking off tag word

    sts_tready              <= not fifo_sinit and not fifo_full and not rxlength_valid_trdy; --rxlength_valid_cdc_from;

-- CR565502 - particular throttle condition caused masking of tag write to not occur
-- simplified logic will provide more robust handling of tag write mask
--    -- Create register delay of status tvalid in order to create a
--    -- rising edge pulse.  note xx_re signal will hold at 1 if
--    -- fifo full on rising edge of tvalid.
--    REG_TVALID : process(axi_prmry_aclk)
--        begin
--            if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
--                if(m_axi_sg_aresetn = '0')then
--                    sts_tvalid_d1 <= '0';
--                elsif(fifo_full = '0')then
--                    sts_tvalid_d1 <= sts_tvalid;
--                end if;
--            end if;
--        end process REG_TVALID;
--    -- rising edge on tvalid used to gate off status tag from being
--    -- writen into fifo.
--    sts_tvalid_re <= sts_tvalid and not sts_tvalid_d1;

    REG_TAG_STRIPPED : process(axi_prmry_aclk)
        begin
            if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
                if(p_reset_n = '0')then
                    tag_stripped <= '0';
                -- Reset on write of last word
                elsif(fifo_wren = '1' and sts_tlast = '1')then
                    tag_stripped <= '0';
                -- Set on beginning of new status stream
                elsif(sts_tready = '1' and sts_tvalid = '1')then
                    tag_stripped <= '1';
                end if;
            end if;
        end process REG_TAG_STRIPPED;

-- CR565502 - particular throttle condition caused masking of tag write to not occur
-- simplified logic will provide more robust handling of tag write mask
--    REG_MASK_TAG : process(axi_prmry_aclk)
--        begin
--            if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
--                if(m_axi_sg_aresetn = '0')then
--                    mask_tag_hold <= '0';
--                elsif(tag_stripped = '1')then
--                    mask_tag_hold <= '0';
--
--                elsif(sts_tvalid_re = '1'
--                or (fifo_wren = '1' and sts_tlast = '1'))then
--                    mask_tag_hold <= '1';
--                end if;
--            end if;
--        end process;
--
--    -- Mask TAG if not already masked and rising edge of tvalid
--    mask_tag_write <= not tag_stripped and (sts_tvalid_re or mask_tag_hold);

    mask_tag_write <= not tag_stripped and sts_tready and sts_tvalid;

    -- Generate logic to capture receive length when Use Receive Length is
    -- enabled
    GEN_STS_APP_LENGTH : if C_SG_USE_STSAPP_LENGTH = 1 generate
    signal rxlength_clr_d1      : std_logic := '0';

    signal rxlength_d1          : std_logic_vector(C_SG_LENGTH_WIDTH-1 downto 0) := (others => '0');
    signal rxlength_valid_d1    : std_logic := '0';
    signal rxlength_valid_d2    : std_logic := '0';

    signal rxlength_clr_d1_cdc_tig      : std_logic := '0';
    signal rxlength_clr_d2      : std_logic := '0';

    signal rxlength_d1_cdc_to          : std_logic_vector(C_SG_LENGTH_WIDTH-1 downto 0) := (others => '0');
    signal rxlength_d2          : std_logic_vector(C_SG_LENGTH_WIDTH-1 downto 0) := (others => '0');
    signal rxlength_valid_d1_cdc_to    : std_logic := '0';
    signal rxlength_valid_d2_cdc_from    : std_logic := '0';
    signal rxlength_valid_d3    : std_logic := '0';
    signal rxlength_valid_d4    : std_logic := '0';
    signal rxlength_valid_d1_back_cdc_to, rxlength_valid_d2_back : std_logic := '0';


    begin
        -- Double register from secondary clock domain to primary
--        S2P_CLK_CROSS : process(axi_prmry_aclk)
--            begin
--                if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
--                    if(p_reset_n = '0')then
--                        rxlength_clr_d1 <= '0';
--                        rxlength_clr_d2 <= '0';
--                    else
--                        rxlength_clr_d1 <= s2mm_rxlength_clr;
--                        rxlength_clr_d2 <= rxlength_clr_d1;
--                    end if;
--                end if;
--            end process S2P_CLK_CROSS;

S2P_CLK_CROSS : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => s2mm_rxlength_clr,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => axi_prmry_aclk,
        scndry_resetn              => '0',
        scndry_out                 => rxlength_clr_d2,
        scndry_vect_out            => open
    );

        TRDY_RXLENGTH : process(axi_prmry_aclk)
            begin
                if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
                    if(p_reset_n = '0' or rxlength_clr_d2 = '1')then
                        rxlength_valid_trdy <= '0';
                    elsif(sts_tlast = '1' and sts_tvalid = '1' and sts_tready = '1')then
                        rxlength_valid_trdy <= '1';
                    end if;
                end if;
            end process TRDY_RXLENGTH;


        REG_RXLENGTH : process(axi_prmry_aclk)
            begin
                if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
                    if(p_reset_n = '0') then -- or rxlength_clr_d2 = '1')then
                        rxlength_cdc_from       <= (others => '0');
                        rxlength_valid_cdc_from <= '0';
                    elsif(sts_tlast = '1' and sts_tvalid = '1' and sts_tready = '1')then
                        rxlength_cdc_from       <= sts_tdata(C_SG_LENGTH_WIDTH-1 downto 0);
                        rxlength_valid_cdc_from <= '1';
                    elsif (rxlength_valid_d2_back = '1') then
                        rxlength_valid_cdc_from <= '0';
                    end if;
                end if;
            end process REG_RXLENGTH;

SYNC_RXLENGTH : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => rxlength_valid_d2_cdc_from,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => axi_prmry_aclk,
        scndry_resetn              => '0',
        scndry_out                 => rxlength_valid_d2_back,
        scndry_vect_out            => open
    );

P2S_CLK_CROSS : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => rxlength_valid_cdc_from,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => rxlength_valid_d2_cdc_from,
        scndry_vect_out            => open
    );


P2S_CLK_CROSS2 : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 0,
        C_VECTOR_WIDTH             => C_SG_LENGTH_WIDTH,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => '0',
        prmry_vect_in              => rxlength_cdc_from,

        scndry_aclk                => m_axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => open,
        scndry_vect_out            => rxlength_d2
    );

        P2S_CLK_CROSS1 : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0') then -- or s2mm_rxlength_clr = '1') then
--                        rxlength_d1_cdc_to         <= (others => '0');
--                        rxlength_d2         <= (others => '0');
--                        rxlength_valid_d1_cdc_to   <= '0';
--                        rxlength_valid_d2_cdc_from   <= '0';
                        rxlength_valid_d3   <= '0';
                    else
--                        rxlength_d1_cdc_to         <= rxlength_cdc_from;
--                        rxlength_d2         <= rxlength_d1_cdc_to;
--                        rxlength_valid_d1_cdc_to   <= rxlength_valid_cdc_from;
--                        rxlength_valid_d2_cdc_from   <= rxlength_valid_d1_cdc_to;
                        rxlength_valid_d3   <= rxlength_valid_d2_cdc_from;
                    end if;
                end if;
            end process P2S_CLK_CROSS1;

           process (m_axi_sg_aclk)
           begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0' or s2mm_rxlength_clr = '1')then
                        rxlength_valid_d4 <= '0';
                    elsif (rxlength_valid_d3 = '1' and rxlength_valid_d2_cdc_from = '0') then
                        rxlength_valid_d4 <= '1';
                    end if;
                 end if;
           end process;

        s2mm_rxlength       <= rxlength_d2;
       -- s2mm_rxlength_valid <= rxlength_valid_d2;
        s2mm_rxlength_valid <= rxlength_valid_d4;


--        -- Register receive length on assertion of last and valid
--        -- Mark rxlength as valid for higher processes
--        REG_RXLENGTH : process(axi_prmry_aclk)
--            begin
--                if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
--                    if(p_reset_n = '0' or rxlength_clr_d2 = '1')then
--                        rxlength       <= (others => '0');
--                        rxlength_valid <= '0';
--                    elsif(sts_tlast = '1' and sts_tvalid = '1' and sts_tready = '1')then
--                        rxlength       <= sts_tdata(C_SG_LENGTH_WIDTH-1 downto 0);
--                        rxlength_valid <= '1';
--                    end if;
--                end if;
--            end process REG_RXLENGTH;
--
--        -- Double register from primary clock domain to secondary
--        P2S_CLK_CROSS : process(m_axi_sg_aclk)
--            begin
--                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
--                    if(m_axi_sg_aresetn = '0')then
--                        rxlength_d1         <= (others => '0');
--                        rxlength_d2         <= (others => '0');
--                        rxlength_valid_d1   <= '0';
--                        rxlength_valid_d2   <= '0';
--                    else
--                        rxlength_d1         <= rxlength;
--                        rxlength_d2         <= rxlength_d1;
--                        rxlength_valid_d1   <= rxlength_valid;
--                        rxlength_valid_d2   <= rxlength_valid_d1;
--                    end if;
--                end if;
--            end process P2S_CLK_CROSS;
--
--        s2mm_rxlength       <= rxlength_d2;
--        s2mm_rxlength_valid <= rxlength_valid_d2;

    end generate GEN_STS_APP_LENGTH;

    -- Do NOT generate logic to capture receive length when option disabled
    GEN_NO_STS_APP_LENGTH : if C_SG_USE_STSAPP_LENGTH = 0 generate
        s2mm_rxlength_valid <= '0';
        s2mm_rxlength       <= (others => '0');
    end generate GEN_NO_STS_APP_LENGTH;

    -- CR605883
    -- Register stop to provide pure FF output for synchronizer
    REG_STOP : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    s2mm_stop_reg <= '0';
                else
                    s2mm_stop_reg <= s2mm_stop;
                end if;
            end if;
        end process REG_STOP;


    -- double register s2mm error into primary clock domain
    REG_ERR2PRMRY : process(axi_prmry_aclk)
        begin
            if(axi_prmry_aclk'EVENT and axi_prmry_aclk = '1')then
                if(p_reset_n = '0')then
                    p_s2mm_stop_cdc_to <= '0';
                    p_s2mm_stop_d2 <= '0';
                    p_s2mm_stop_d3 <= '0';
                    p_s2mm_stop_d4 <= '0';
                else
                    p_s2mm_stop_cdc_to <= s2mm_stop_reg;
                    p_s2mm_stop_d2 <= p_s2mm_stop_cdc_to;
                    p_s2mm_stop_d3 <= p_s2mm_stop_d2;
                    p_s2mm_stop_d4 <= p_s2mm_stop_d4;
                end if;
            end if;
        end process REG_ERR2PRMRY;

    p_s2mm_stop_re <= p_s2mm_stop_d3 and not p_s2mm_stop_d4;

    skid_rst   <= not p_reset_n;

    ---------------------------------------------------------------------------
    -- Buffer AXI Signals
    ---------------------------------------------------------------------------
    STS_SKID_BUF_I : entity axi_mcdma_v1_1_8.axi_mcdma_skid_buf
        generic map(
            C_WDATA_WIDTH       => C_S_AXIS_S2MM_STS_TDATA_WIDTH
        )
        port map(
            -- System Ports
            ACLK                => axi_prmry_aclk                           ,
            ARST                => skid_rst                                 ,

            skid_stop           => p_s2mm_stop_re                           ,

            -- Slave Side (Stream Data Input)
            S_VALID             => s_axis_s2mm_sts_tvalid_i                   ,
            S_READY             => s_axis_s2mm_sts_tready_i                   ,
            S_Data              => s_axis_s2mm_sts_tdata                    ,
            S_STRB              => s_axis_s2mm_sts_tkeep                    ,
            S_Last              => s_axis_s2mm_sts_tlast                    ,

            -- Master Side (Stream Data Output
            M_VALID             => sts_tvalid                               ,
            M_READY             => sts_tready                               ,
            M_Data              => sts_tdata                                ,
            M_STRB              => sts_tkeep                                ,
            M_Last              => sts_tlast
        );


end generate GEN_ASYNC_FIFO;




end implementation;



-------------------------------------------------------------------------------
-- axi_mcdma_s2mm_mngr
-------------------------------------------------------------------------------
--
-- *************************************************************************
--
-- (c) Copyright 2010, 2011 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--
-- *************************************************************************
--
-------------------------------------------------------------------------------
-- Filename:          axi_mcdma_s2mm_mngr.vhd
-- Description: This entity is the top level entity for the AXI DMA S2MM
--              manager.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

-------------------------------------------------------------------------------
entity  axi_mcdma_s2mm_mngr is
    generic(

        C_PRMRY_IS_ACLK_ASYNC           : integer range 0 to 1         := 0;
            -- Primary MM2S/S2MM sync/async mode
            -- 0 = synchronous mode     - all clocks are synchronous
            -- 1 = asynchronous mode    - Primary data path channels (MM2S and S2MM)
            --                            run asynchronous to AXI Lite, DMA Control,
            --                            and SG.

        C_PRMY_CMDFIFO_DEPTH            : integer range 1 to 16         := 1;
            -- Depth of DataMover command FIFO

        C_DM_STATUS_WIDTH               : integer range 8 to 35         := 8;
            -- Width of DataMover status word
            -- 8  for Determinate BTT Mode
            -- 32 for Indterminate BTT Mode

        -----------------------------------------------------------------------
        -- Scatter Gather Parameters
        -----------------------------------------------------------------------
        C_INCLUDE_SG                : integer range 0 to 1          := 1;
            -- Include or Exclude the Scatter Gather Engine
            -- 0 = Exclude SG Engine - Enables Simple DMA Mode
            -- 1 = Include SG Engine - Enables Scatter Gather Mode

        C_SG_INCLUDE_STSCNTRL_STRM      : integer range 0 to 1      := 1;
            -- Include or Exclude AXI Status and AXI Control Streams
            -- 0 = Exclude Status and Control Streams
            -- 1 = Include Status and Control Streams

        C_SG_INCLUDE_DESC_QUEUE     : integer range 0 to 1          := 0;
            -- Include or Exclude Scatter Gather Descriptor Queuing
            -- 0 = Exclude SG Descriptor Queuing
            -- 1 = Include SG Descriptor Queuing

        C_SG_USE_STSAPP_LENGTH      : integer range 0 to 1          := 1;
            -- Enable or Disable use of Status Stream Rx Length.  Only valid
            -- if C_SG_INCLUDE_STSCNTRL_STRM = 1
            -- 0 = Don't use Rx Length
            -- 1 = Use Rx Length

        C_SG_LENGTH_WIDTH               : integer range 8 to 26     := 14;
            -- Descriptor Buffer Length, Transferred Bytes, and Status Stream
            -- Rx Length Width.  Indicates the least significant valid bits of
            -- descriptor buffer length, transferred bytes, or Rx Length value
            -- in the status word coincident with tlast.


        C_M_AXI_SG_ADDR_WIDTH           : integer range 32 to 64    := 32;
            -- Master AXI Memory Map Address Width for Scatter Gather R/W Port

        C_M_AXIS_SG_TDATA_WIDTH          : integer range 32 to 32    := 32;
            -- AXI Master Stream in for descriptor fetch

        C_S_AXIS_UPDPTR_TDATA_WIDTH : integer range 32 to 64        := 32;
            -- 32 Update Status Bits

        C_S_AXIS_UPDSTS_TDATA_WIDTH : integer range 33 to 33        := 33;
            -- 1 IOC bit + 32 Update Status Bits

        C_S_AXIS_S2MM_STS_TDATA_WIDTH : integer range 32 to 32    := 32;
            -- Slave AXI Status Stream Data Width

        -----------------------------------------------------------------------
        -- Stream to Memory Map (S2MM) Parameters
        -----------------------------------------------------------------------
        C_INCLUDE_S2MM                  : integer range 0 to 1      := 1;
            -- Include or exclude S2MM primary data path
            -- 0 = Exclude S2MM primary data path
            -- 1 = Include S2MM primary data path

        C_M_AXI_S2MM_ADDR_WIDTH         : integer range 32 to 64    := 32;
            -- Master AXI Memory Map Address Width for S2MM Write Port
        C_MAX_CHANNELS                  : integer range 1 to 16     := 1;
        C_FAMILY                        : string            := "virtex5"
            -- Target FPGA Device Family
    );
    port (

        -- Secondary Clock and Reset
        m_axi_sg_aclk               : in  std_logic                         ;                      --
        m_axi_sg_aresetn            : in  std_logic                         ;                      --
                                                                                                   --
        -- Primary Clock and Reset                                                                 --
        axi_prmry_aclk              : in  std_logic                         ;                      --
        p_reset_n                   : in  std_logic                         ;                      --
                                                                                                   --
        soft_reset                  : in  std_logic                         ;                      --
        -- MM2S Control and Status                                                                 --
        s2mm_run_stop               : in  std_logic                         ;                      --
        s2mm_halted                 : in  std_logic                         ;                      --
        s2mm_ftch_idle              : in  std_logic                         ;                      --
        s2mm_updt_idle              : in  std_logic                         ;                      --
        s2mm_tailpntr_enble         : in  std_logic                         ;                      --
        s2mm_ftch_err_early         : in  std_logic                         ;                      --
        s2mm_ftch_stale_desc        : in  std_logic                         ;                      --
        s2mm_halt                   : in  std_logic                         ;                      --
        s2mm_halt_cmplt             : in  std_logic                         ;                      --
        s2mm_halted_clr             : out std_logic                         ;                      --
        s2mm_halted_set             : out std_logic                         ;                      --
        s2mm_idle_set               : out std_logic                         ;                      --
        s2mm_idle_clr               : out std_logic                         ;                      --
        s2mm_channel_id_reg_update  : out std_logic_vector (C_MAX_CHANNELS-1 downto 0);
        s2mm_new_curdesc            : out std_logic_vector                                         --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;                      --
        s2mm_new_curdesc_wren       : out std_logic                         ;                      --
        s2mm_stop                   : out std_logic                         ;                      --
        s2mm_desc_flush             : out std_logic                         ;                      --
        s2mm_all_idle               : out std_logic                         ;                      --
        s2mm_error                  : out std_logic                         ;                      --
        mm2s_error                  : in  std_logic                         ;                      --
        fetch_more                  : in std_logic                          ;

                                                                                                   --
        -- SG S2MM Descriptor Fetch AXI Stream In                                                  --
        m_axis_s2mm_ftch_tdata      : in  std_logic_vector                                         --
                                        (C_M_AXIS_SG_TDATA_WIDTH-1 downto 0);                      --
        m_axis_s2mm_ftch_tvalid     : in  std_logic                         ;                      --
        m_axis_s2mm_ftch_data_valid     : in  std_logic                         ;                      --
        m_axis_s2mm_ftch_tready     : out std_logic                         ;                      --
        m_axis_s2mm_ftch_tlast      : in  std_logic                         ;                      --
        m_axis_s2mm_ftch_id         : in  std_logic_vector (C_MAX_CHANNELS-1 downto 0);                      --
                                                                                                   --
                                                                                                   --
        -- SG S2MM Descriptor Update AXI Stream Out                                                --
        s_axis_s2mm_updtptr_tdata   : out std_logic_vector                                         --
                                        (C_S_AXIS_UPDPTR_TDATA_WIDTH-1 downto 0) ;                 --
        s_axis_s2mm_updtptr_tvalid  : out std_logic                         ;                      --
        s_axis_s2mm_updtptr_tready  : in  std_logic                         ;                      --
        s_axis_s2mm_updtptr_tlast   : out std_logic                         ;                      --
                                                                                                   --
        s_axis_s2mm_updtsts_tdata   : out std_logic_vector                                         --
                                        (C_S_AXIS_UPDSTS_TDATA_WIDTH-1 downto 0) ;                 --
        s_axis_s2mm_updtsts_tvalid  : out std_logic                         ;                      --
        s_axis_s2mm_updtsts_tready  : in  std_logic                         ;                      --
        s_axis_s2mm_updtsts_tlast   : out std_logic                         ;                      --
        s_axis_s2mm_updtsts_id      : out std_logic_vector (C_MAX_CHANNELS-1 downto 0)                         ;                      --
                                                                                                   --
        -- User Command Interface Ports (AXI Stream)                                               --
        s_axis_s2mm_cmd_tvalid      : out std_logic                         ;                      --
        s_axis_s2mm_cmd_tready      : in  std_logic                         ;                      --
        s_axis_s2mm_cmd_tdata       : out std_logic_vector                                         --
                                        ((C_M_AXI_S2MM_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0);     --
                                                                                                   --
        -- User Status Interface Ports (AXI Stream)                                                --
        m_axis_s2mm_sts_tvalid      : in  std_logic                         ;                      --
        m_axis_s2mm_sts_tready      : out std_logic                         ;                      --
        m_axis_s2mm_sts_tdata       : in  std_logic_vector                                         --
                                        (C_DM_STATUS_WIDTH - 1 downto 0)    ;                      --
        m_axis_s2mm_sts_tkeep       : in  std_logic_vector((C_DM_STATUS_WIDTH/8-1) downto 0);      --
        m_axis_s2mm_sg_side_band    : in  std_logic_vector (11 downto 0);
        m_axis_s2mm_sg_side_band_valid    : in  std_logic;
        m_axis_s2mm_sg_side_band_s2mm_tuser : in std_logic_vector (15 downto 0);
        m_axis_s2mm_sg_side_band_tuser_valid  : in std_logic;
        s2mm_err                    : in  std_logic                         ;                      --
        updt_error                  : in  std_logic                         ;                      --
        ftch_error                  : in  std_logic                         ;                      --
                                                                                                   --
        -- Stream to Memory Map Status Stream Interface                                            --
        accept_sts                  : in std_logic;
        reject_sts                  : in std_logic;
        sts_busy                    : out std_logic;
        s_axis_s2mm_sts_tdata       : in  std_logic_vector                                         --
                                        (C_S_AXIS_S2MM_STS_TDATA_WIDTH-1 downto 0);                --
        s_axis_s2mm_sts_tkeep       : in  std_logic_vector                                         --
                                        ((C_S_AXIS_S2MM_STS_TDATA_WIDTH/8)-1 downto 0);            --
        s_axis_s2mm_sts_tvalid      : in  std_logic                         ;                      --
        s_axis_s2mm_sts_tready      : out std_logic                         ;                      --
        s_axis_s2mm_sts_tlast       : in  std_logic                                                --
    );

end axi_mcdma_s2mm_mngr;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma_s2mm_mngr is

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------

-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------

-- No Constants Declared

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
-- Primary DataMover Command signals
signal s2mm_cmnd_wr                 : std_logic := '0';
signal s2mm_cmnd_data               : std_logic_vector
                                        ((C_M_AXI_S2MM_ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0) := (others => '0');
signal s2mm_cmnd_pending            : std_logic := '0';
-- Primary DataMover Status signals
signal s2mm_done                    : std_logic := '0';
signal s2mm_stop_i                  : std_logic := '0';
signal s2mm_interr                  : std_logic := '0';
signal s2mm_slverr                  : std_logic := '0';
signal s2mm_decerr                  : std_logic := '0';
signal s2mm_tag                     : std_logic_vector(3 downto 0) := (others => '0');
signal s2mm_brcvd                   : std_logic_vector(C_SG_LENGTH_WIDTH-1 downto 0) := (others => '0');
signal s2mm_sg_side_band            : std_logic_vector (31 downto 0);
signal dma_s2mm_error               : std_logic := '0';
signal soft_reset_d1                : std_logic := '0';
signal soft_reset_d2                : std_logic := '0';
signal soft_reset_re                : std_logic := '0';
signal s2mm_error_i                 : std_logic := '0';
signal sts_strm_stop                : std_logic := '0';
signal s2mm_halted_set_i            : std_logic := '0';

signal s2mm_sts_received_clr        : std_logic := '0';
signal s2mm_sts_received            : std_logic := '0';

signal s2mm_cmnd_idle               : std_logic := '0';
signal s2mm_sts_idle                : std_logic := '0';
signal s2mm_eof_set                 : std_logic := '0';
signal s2mm_packet_eof              : std_logic := '0';

-- Scatter Gather Interface signals
signal desc_fetch_req               : std_logic := '0';
signal desc_fetch_done              : std_logic := '0';
signal desc_update_req              : std_logic := '0';
signal desc_update_done             : std_logic := '0';
signal desc_available               : std_logic := '0';

signal s2mm_desc_baddress           : std_logic_vector(C_M_AXI_S2MM_ADDR_WIDTH-1 downto 0)  := (others => '0');
signal s2mm_desc_blength            : std_logic_vector(BUFFER_LENGTH_WIDTH-1 downto 0)    := (others => '0');
signal s2mm_desc_cmplt              : std_logic := '0';
signal s2mm_desc_app0               : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH-1 downto 0)    := (others => '0');
signal s2mm_desc_app1               : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH-1 downto 0)    := (others => '0');
signal s2mm_desc_app2               : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH-1 downto 0)    := (others => '0');
signal s2mm_desc_app3               : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH-1 downto 0)    := (others => '0');
signal s2mm_desc_app4               : std_logic_vector(C_M_AXIS_SG_TDATA_WIDTH-1 downto 0)    := (others => '0');


-- S2MM Status Stream Signals
signal s2mm_rxlength_valid          : std_logic := '0';
signal s2mm_rxlength_clr            : std_logic := '0';
signal s2mm_rxlength                : std_logic_vector(C_SG_LENGTH_WIDTH - 1 downto 0) := (others => '0');
signal stsstrm_fifo_rden            : std_logic := '0';
signal stsstrm_fifo_empty           : std_logic := '0';
signal stsstrm_fifo_dout            : std_logic_vector(C_S_AXIS_S2MM_STS_TDATA_WIDTH downto 0) := (others => '0');
signal s2mm_desc_flush_i            : std_logic := '0';

signal s2mm_run_stop_re               : std_logic := '0';
signal s2mm_run_stop_fe               : std_logic := '0';
signal s2mm_run_stop_del               : std_logic := '0';
signal flush_bd                       : std_logic := '0';


-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

-------------------------------------------------------------------------------
-- Include S2MM (Received) Channel
-------------------------------------------------------------------------------
GEN_S2MM_DMA_CONTROL : if C_INCLUDE_S2MM = 1 generate
begin

    -- pass out to register module
    s2mm_halted_set <= s2mm_halted_set_i;

    -------------------------------------------------------------------------------
    -- Graceful shut down logic
    -------------------------------------------------------------------------------

    -- Error from DataMover (DMAIntErr, DMADecErr, or DMASlvErr) or SG Update error
    -- or SG Fetch error, or Stale Descriptor Error
    s2mm_error_i    <= dma_s2mm_error                -- Primary data mover reports error
                        or updt_error                -- SG Update engine reports error
                        or ftch_error                -- SG Fetch engine reports error
                        or s2mm_ftch_err_early       -- SG Fetch engine reports early error on S2MM
                        or s2mm_ftch_stale_desc;     -- SG Fetch stale descriptor error

    -- pass out to shut down mm2s
    s2mm_error <= s2mm_error_i;

    -- Clear run/stop and stop state machines due to errors or soft reset
    -- Error based on datamover error report or sg update error or sg fetch error
    -- SG update error and fetch error included because need to shut down, no way
    -- to update descriptors on sg update error and on fetch error descriptor
    -- data is corrupt therefor do not want to issue the xfer command to primary datamover

--CR#566306 status for both mm2s and s2mm datamover are masked during shutdown therefore
-- need to stop all processes regardless of the source of the error.
--    s2mm_stop_i    <= s2mm_error                -- Error
--                   or soft_reset;               -- Soft Reset issued
    s2mm_stop_i    <= s2mm_error_i              -- Error on s2mm
                   or mm2s_error                -- Error on mm2s
                   or soft_reset;               -- Soft Reset issued


    -- Register signals out
    REG_OUT : process(m_axi_sg_aclk)
        begin
            if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                if(m_axi_sg_aresetn = '0')then
                    s2mm_stop           <= '0';
                    s2mm_desc_flush_i   <= '0';
                else
                    s2mm_stop           <= s2mm_stop_i;
                    -- Flush any fetch descriptors if error or if run stop cleared
                    s2mm_desc_flush_i   <= s2mm_stop_i or flush_bd; --not s2mm_run_stop;
                end if;
            end if;
        end process REG_OUT;


BD_QUEUE_STATE : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
               s2mm_run_stop_del <= '0';
            else
               s2mm_run_stop_del <= s2mm_run_stop;
            end if;
        end if;
    end process BD_QUEUE_STATE;

s2mm_run_stop_re <= s2mm_run_stop and (not s2mm_run_stop_del);
s2mm_run_stop_fe <= s2mm_run_stop_del and (not s2mm_run_stop);


FLUSH_BD_QUEUE_STATE : process(m_axi_sg_aclk)
    begin
        if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
            if(m_axi_sg_aresetn = '0')then
               flush_bd <= '0';
            elsif (s2mm_run_stop_fe = '1') then
               flush_bd <= '1';
            elsif (s2mm_run_stop_re = '1') then
               flush_bd <= '0';
            end if;
        end if;
    end process FLUSH_BD_QUEUE_STATE;



    -- Generate DMA Controller For Scatter Gather Mode
    GEN_SCATTER_GATHER_MODE : if C_INCLUDE_SG = 1 generate
    begin
        -- Not used in Scatter Gather mode

        -- Flush descriptors
        s2mm_desc_flush <= s2mm_desc_flush_i;

        ---------------------------------------------------------------------------
        -- S2MM Primary DMA Controller State Machine
        ---------------------------------------------------------------------------
        I_S2MM_SM : entity  axi_mcdma_v1_1_8.axi_mcdma_s2mm_sm
            generic map(
                C_M_AXI_S2MM_ADDR_WIDTH     => C_M_AXI_S2MM_ADDR_WIDTH          ,
                C_SG_LENGTH_WIDTH           => C_SG_LENGTH_WIDTH                ,
                C_SG_INCLUDE_DESC_QUEUE     => C_SG_INCLUDE_DESC_QUEUE          ,
                C_SG_INCLUDE_STSCNTRL_STRM  => C_SG_INCLUDE_STSCNTRL_STRM       ,
                C_SG_USE_STSAPP_LENGTH      => C_SG_USE_STSAPP_LENGTH           ,
                C_PRMY_CMDFIFO_DEPTH        => C_PRMY_CMDFIFO_DEPTH
            )
            port map(
                m_axi_sg_aclk               => m_axi_sg_aclk                    ,
                m_axi_sg_aresetn            => m_axi_sg_aresetn                 ,

                s2mm_stop                   => s2mm_stop_i                      ,

                -- Channel 1 Control and Status
                s2mm_run_stop               => s2mm_run_stop                    ,
                s2mm_ftch_idle              => s2mm_ftch_idle                   ,
                s2mm_desc_flush             => s2mm_desc_flush_i                ,
                s2mm_cmnd_idle              => s2mm_cmnd_idle                   ,
                s2mm_sts_idle               => s2mm_sts_idle                    ,
                s2mm_eof_set                => s2mm_eof_set                     ,
                fetch_more                  => fetch_more                       ,

                -- S2MM Status Stream RX Length
                s2mm_rxlength_valid         => s2mm_rxlength_valid              ,
                s2mm_rxlength_clr           => s2mm_rxlength_clr                ,
                s2mm_rxlength               => s2mm_rxlength                    ,

                -- S2MM Descriptor Fetch Request (from s2mm_sm)
                desc_fetch_req              => desc_fetch_req                   ,
                desc_fetch_done             => desc_fetch_done                  ,
                desc_update_done            => desc_update_done                 ,
                desc_available              => desc_available                   ,

                -- DataMover Command
                s2mm_cmnd_wr                => s2mm_cmnd_wr                     ,
                s2mm_cmnd_data              => s2mm_cmnd_data                   ,
                s2mm_cmnd_pending           => s2mm_cmnd_pending                ,

                -- Descriptor Fields
                s2mm_desc_baddress          => s2mm_desc_baddress               ,
                s2mm_desc_blength           => s2mm_desc_blength
            );

        ---------------------------------------------------------------------------
        -- S2MM Scatter Gather State Machine
        ---------------------------------------------------------------------------
        I_S2MM_SG_IF : entity  axi_mcdma_v1_1_8.axi_mcdma_s2mm_sg_if
            generic map(

                -------------------------------------------------------------------
                -- Scatter Gather Parameters
                -------------------------------------------------------------------
                C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC            ,
                C_SG_INCLUDE_STSCNTRL_STRM  => C_SG_INCLUDE_STSCNTRL_STRM       ,
                C_SG_INCLUDE_DESC_QUEUE     => C_SG_INCLUDE_DESC_QUEUE          ,
                C_SG_USE_STSAPP_LENGTH      => C_SG_USE_STSAPP_LENGTH           ,
                C_SG_LENGTH_WIDTH           => C_SG_LENGTH_WIDTH                ,
                C_M_AXIS_SG_TDATA_WIDTH     => C_M_AXIS_SG_TDATA_WIDTH          ,
                C_S_AXIS_UPDPTR_TDATA_WIDTH => C_S_AXIS_UPDPTR_TDATA_WIDTH      ,
                C_S_AXIS_UPDSTS_TDATA_WIDTH => C_S_AXIS_UPDSTS_TDATA_WIDTH      ,
                C_M_AXI_SG_ADDR_WIDTH       => C_M_AXI_SG_ADDR_WIDTH            ,
                C_M_AXI_S2MM_ADDR_WIDTH     => C_M_AXI_S2MM_ADDR_WIDTH          ,
                C_S_AXIS_S2MM_STS_TDATA_WIDTH=> C_S_AXIS_S2MM_STS_TDATA_WIDTH   ,
                C_MAX_CHANNELS              => C_MAX_CHANNELS                   ,
                C_FAMILY                    => C_FAMILY
            )
            port map(

                m_axi_sg_aclk               => m_axi_sg_aclk                    ,
                m_axi_sg_aresetn            => m_axi_sg_aresetn                 ,

                -- SG S2MM Descriptor Fetch AXI Stream In
                m_axis_s2mm_ftch_tdata      => m_axis_s2mm_ftch_tdata           ,
                m_axis_s2mm_ftch_tvalid     => m_axis_s2mm_ftch_tvalid          ,
                m_axis_s2mm_ftch_data_valid     => m_axis_s2mm_ftch_data_valid          ,
                m_axis_s2mm_ftch_tready     => m_axis_s2mm_ftch_tready          ,
                m_axis_s2mm_ftch_tlast      => m_axis_s2mm_ftch_tlast           ,
                m_axis_s2mm_ftch_id         => m_axis_s2mm_ftch_id              ,

                -- SG S2MM Descriptor Update AXI Stream Out
                s_axis_s2mm_updtptr_tdata   => s_axis_s2mm_updtptr_tdata        ,
                s_axis_s2mm_updtptr_tvalid  => s_axis_s2mm_updtptr_tvalid       ,
                s_axis_s2mm_updtptr_tready  => s_axis_s2mm_updtptr_tready       ,
                s_axis_s2mm_updtptr_tlast   => s_axis_s2mm_updtptr_tlast        ,

                s_axis_s2mm_updtsts_tdata   => s_axis_s2mm_updtsts_tdata        ,
                s_axis_s2mm_updtsts_tvalid  => s_axis_s2mm_updtsts_tvalid       ,
                s_axis_s2mm_updtsts_tready  => s_axis_s2mm_updtsts_tready       ,
                s_axis_s2mm_updtsts_tlast   => s_axis_s2mm_updtsts_tlast        ,
                s_axis_s2mm_updtsts_id      => s_axis_s2mm_updtsts_id           ,

                -- S2MM Descriptor Fetch Request (from s2mm_sm)
                desc_available              => desc_available                   ,
                desc_fetch_req              => desc_fetch_req                   ,
                desc_fetch_done             => desc_fetch_done                  ,

                -- S2MM Status Stream Interface
                stsstrm_fifo_rden           => stsstrm_fifo_rden                ,
                stsstrm_fifo_empty          => stsstrm_fifo_empty               ,
                stsstrm_fifo_dout           => stsstrm_fifo_dout                ,

                -- Update command write interface from s2mm sm
                s2mm_cmnd_wr                => s2mm_cmnd_wr                     ,
                s2mm_cmnd_data              => s2mm_cmnd_data                   ,


                -- S2MM Descriptor Update Request (from s2mm_sm)
                desc_update_done            => desc_update_done                 ,

                s2mm_sts_received_clr       => s2mm_sts_received_clr            ,
                s2mm_sts_received           => s2mm_sts_received                ,
                s2mm_desc_cmplt             => s2mm_desc_cmplt                  ,
                s2mm_done                   => s2mm_done                        ,
                s2mm_interr                 => s2mm_interr                      ,
                s2mm_slverr                 => s2mm_slverr                      ,
                s2mm_decerr                 => s2mm_decerr                      ,
                s2mm_tag                    => s2mm_tag                         ,
                s2mm_brcvd                  => s2mm_brcvd                       ,
                s2mm_sg_side_band           => s2mm_sg_side_band                ,
                s2mm_eof_set                => s2mm_eof_set                     ,
                s2mm_packet_eof             => s2mm_packet_eof                  ,
                s2mm_halt                   => s2mm_halt                        ,

                -- S2MM Descriptor Field Output
                s2mm_channel_id_reg_update  => s2mm_channel_id_reg_update       ,
                s2mm_new_curdesc            => s2mm_new_curdesc                 ,
                s2mm_new_curdesc_wren       => s2mm_new_curdesc_wren            ,
                s2mm_desc_baddress          => s2mm_desc_baddress               ,
                s2mm_desc_blength           => s2mm_desc_blength                ,
                s2mm_desc_app0              => s2mm_desc_app0                   ,
                s2mm_desc_app1              => s2mm_desc_app1                   ,
                s2mm_desc_app2              => s2mm_desc_app2                   ,
                s2mm_desc_app3              => s2mm_desc_app3                   ,
                s2mm_desc_app4              => s2mm_desc_app4
            );
    end generate GEN_SCATTER_GATHER_MODE;

GEN_NO_SCATTER_GATHER_MODE : if C_INCLUDE_SG = 0 generate
    begin
	s2mm_cmnd_wr <= '0';
	s2mm_desc_cmplt <= '0';
	s2mm_sts_received_clr <=  '0';
	s2mm_cmnd_data <= (others => '0');
	s2mm_new_curdesc_wren <= '0';
	s2mm_channel_id_reg_update <= (others => '0');
	s2mm_cmnd_idle <=  '0';
	s2mm_sts_idle <=  '0';

    end generate GEN_NO_SCATTER_GATHER_MODE;





    -------------------------------------------------------------------------------
    -- S2MM DataMover Command / Status Interface
    -------------------------------------------------------------------------------
    I_S2MM_CMDSTS : entity  axi_mcdma_v1_1_8.axi_mcdma_s2mm_cmdsts_if
        generic map(
            C_M_AXI_S2MM_ADDR_WIDTH     => C_M_AXI_S2MM_ADDR_WIDTH          ,
            C_DM_STATUS_WIDTH           => C_DM_STATUS_WIDTH                ,
            C_SG_INCLUDE_STSCNTRL_STRM  => C_SG_INCLUDE_STSCNTRL_STRM       ,
            C_SG_USE_STSAPP_LENGTH      => C_SG_USE_STSAPP_LENGTH           ,
            C_SG_LENGTH_WIDTH           => C_SG_LENGTH_WIDTH                ,
            C_INCLUDE_SG                => C_INCLUDE_SG ,
            C_ASYNC                     => C_PRMRY_IS_ACLK_ASYNC,
                C_FAMILY                    => C_FAMILY
        )
        port map(
            m_axi_sg_aclk               => m_axi_sg_aclk                    ,
            m_axi_sg_aresetn            => m_axi_sg_aresetn                 ,

            m_axi_s2mm_aclk               => axi_prmry_aclk                    ,
            m_axi_s2mm_aresetn            => p_reset_n                 ,

            -- Update command write interface from s2mm sm
            s2mm_cmnd_wr                => s2mm_cmnd_wr                     ,
            s2mm_cmnd_data              => s2mm_cmnd_data                   ,
            s2mm_cmnd_pending           => s2mm_cmnd_pending                ,
            s2mm_packet_eof             => s2mm_packet_eof                  , -- EOF Detected
            s2mm_sts_received_clr       => s2mm_sts_received_clr            ,
            s2mm_sts_received           => s2mm_sts_received                ,
            s2mm_tailpntr_enble         => s2mm_tailpntr_enble              ,
            s2mm_desc_cmplt             => s2mm_desc_cmplt                  ,

            -- User Command Interface Ports (AXI Stream)
            s_axis_s2mm_cmd_tvalid      => s_axis_s2mm_cmd_tvalid           ,
            s_axis_s2mm_cmd_tready      => s_axis_s2mm_cmd_tready           ,
            s_axis_s2mm_cmd_tdata       => s_axis_s2mm_cmd_tdata            ,

            -- User Status Interface Ports (AXI Stream)
            m_axis_s2mm_sts_tvalid      => m_axis_s2mm_sts_tvalid           ,
            m_axis_s2mm_sts_tready      => m_axis_s2mm_sts_tready           ,
            m_axis_s2mm_sts_tdata       => m_axis_s2mm_sts_tdata            ,
            m_axis_s2mm_sts_tkeep       => m_axis_s2mm_sts_tkeep            ,
            m_axis_s2mm_sg_side_band    => m_axis_s2mm_sg_side_band         ,
            m_axis_s2mm_sg_side_band_valid    => m_axis_s2mm_sg_side_band_valid         ,
            m_axis_s2mm_sg_side_band_s2mm_tuser => m_axis_s2mm_sg_side_band_s2mm_tuser, 
            m_axis_s2mm_sg_side_band_tuser_valid => m_axis_s2mm_sg_side_band_tuser_valid, 

            -- S2MM Primary DataMover Status
            s2mm_brcvd                  => s2mm_brcvd                       ,
            s2mm_sg_side_band           => s2mm_sg_side_band                ,
            s2mm_err                    => s2mm_err                         ,
            s2mm_done                   => s2mm_done                        ,
            s2mm_error                  => dma_s2mm_error                   ,
            s2mm_interr                 => s2mm_interr                      ,
            s2mm_slverr                 => s2mm_slverr                      ,
            s2mm_decerr                 => s2mm_decerr                      ,
            s2mm_tag                    => s2mm_tag
        );


    ---------------------------------------------------------------------------
    -- Halt / Idle Status Manager
    ---------------------------------------------------------------------------
    I_S2MM_STS_MNGR : entity  axi_mcdma_v1_1_8.axi_mcdma_s2mm_sts_mngr
        generic map(
            C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC
        )
        port map(
            m_axi_sg_aclk               => m_axi_sg_aclk                    ,
            m_axi_sg_aresetn            => m_axi_sg_aresetn                 ,

            -- dma control and sg engine status signals
            s2mm_run_stop               => s2mm_run_stop                    ,
            s2mm_ftch_idle              => s2mm_ftch_idle                   ,
            s2mm_updt_idle              => s2mm_updt_idle                   ,
            s2mm_cmnd_idle              => s2mm_cmnd_idle                   ,
            s2mm_sts_idle               => s2mm_sts_idle                    ,

            -- stop and halt control/status
            s2mm_stop                   => s2mm_stop_i                      ,
            s2mm_halt_cmplt             => s2mm_halt_cmplt                  ,

            -- system state and control
            s2mm_all_idle               => s2mm_all_idle                    ,
            s2mm_halted_clr             => s2mm_halted_clr                  ,
            s2mm_halted_set             => s2mm_halted_set_i                ,
            s2mm_idle_set               => s2mm_idle_set                    ,
            s2mm_idle_clr               => s2mm_idle_clr
        );


    -- S2MM Status Stream Included
    GEN_STS_STREAM : if C_SG_INCLUDE_STSCNTRL_STRM = 1 and C_INCLUDE_SG = 1 generate
    begin
        -- Register soft reset to create rising edge pulse to use for shut down.
        -- soft_reset from DMACR does not clear until after all reset processes
        -- are done.  This causes stop to assert too long causing issue with
        -- status stream skid buffer.
        REG_SFT_RST : process(m_axi_sg_aclk)
            begin
                if(m_axi_sg_aclk'EVENT and m_axi_sg_aclk = '1')then
                    if(m_axi_sg_aresetn = '0')then
                        soft_reset_d1   <= '0';
                        soft_reset_d2   <= '0';
                    else
                        soft_reset_d1   <= soft_reset;
                        soft_reset_d2   <= soft_reset_d1;
                    end if;
                end if;
            end process REG_SFT_RST;

        -- Rising edge soft reset pulse
        soft_reset_re <= soft_reset_d1 and not soft_reset_d2;

        -- Status Stream module stop requires rising edge of soft reset to
        -- shut down due to DMACR.SoftReset does not deassert on internal hard reset
        -- It clears after therefore do not want to issue another stop to sts strm
        -- skid buffer.
        sts_strm_stop <= s2mm_error_i               -- Error
                      or soft_reset_re;             -- Soft Reset issued

        I_S2MM_STS_STREAM : entity axi_mcdma_v1_1_8.axi_mcdma_s2mm_sts_strm
            generic map(

                C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC            ,
                C_S_AXIS_S2MM_STS_TDATA_WIDTH=> C_S_AXIS_S2MM_STS_TDATA_WIDTH   ,
                C_SG_USE_STSAPP_LENGTH      => C_SG_USE_STSAPP_LENGTH           ,
                C_SG_LENGTH_WIDTH           => C_SG_LENGTH_WIDTH                ,
                C_FAMILY                    => C_FAMILY
            )
            port map(

                m_axi_sg_aclk               => m_axi_sg_aclk                    ,
                m_axi_sg_aresetn            => m_axi_sg_aresetn                 ,

                axi_prmry_aclk              => axi_prmry_aclk                   ,
                p_reset_n                   => p_reset_n                        ,

                s2mm_stop                   => sts_strm_stop                    ,
                accept_sts                  => accept_sts,
                reject_sts                  => reject_sts,
                sts_busy                    => sts_busy,

                s2mm_rxlength_valid         => s2mm_rxlength_valid              ,
                s2mm_rxlength_clr           => s2mm_rxlength_clr                ,
                s2mm_rxlength               => s2mm_rxlength                    ,
                stsstrm_fifo_rden           => stsstrm_fifo_rden                ,
                stsstrm_fifo_empty          => stsstrm_fifo_empty               ,
                stsstrm_fifo_dout           => stsstrm_fifo_dout                ,

                -- Stream to Memory Map Status Stream Interface                 ,
                s_axis_s2mm_sts_tdata       => s_axis_s2mm_sts_tdata            ,
                s_axis_s2mm_sts_tkeep       => s_axis_s2mm_sts_tkeep            ,
                s_axis_s2mm_sts_tvalid      => s_axis_s2mm_sts_tvalid           ,
                s_axis_s2mm_sts_tready      => s_axis_s2mm_sts_tready           ,
                s_axis_s2mm_sts_tlast       => s_axis_s2mm_sts_tlast
            );
    end generate GEN_STS_STREAM;

    -- S2MM Status Stream Not Included
    GEN_NO_STS_STREAM : if C_SG_INCLUDE_STSCNTRL_STRM = 0 or C_INCLUDE_SG = 0 generate
    begin
        s2mm_rxlength_valid     <= '0';
        s2mm_rxlength           <= (others => '0');
        stsstrm_fifo_empty      <= '1';
        stsstrm_fifo_dout       <= (others => '0');
        s_axis_s2mm_sts_tready  <= '0';
        sts_busy                <= '0';
    end generate GEN_NO_STS_STREAM;


end generate GEN_S2MM_DMA_CONTROL;



-------------------------------------------------------------------------------
-- Do Not Include S2MM Channel
-------------------------------------------------------------------------------
GEN_NO_S2MM_DMA_CONTROL : if C_INCLUDE_S2MM = 0 generate
begin
        m_axis_s2mm_ftch_tready     <= '0';
        s_axis_s2mm_updtptr_tdata   <= (others =>'0');
        s_axis_s2mm_updtptr_tvalid  <= '0';
        s_axis_s2mm_updtptr_tlast   <= '0';
        s_axis_s2mm_updtsts_tdata   <= (others =>'0');
        s_axis_s2mm_updtsts_id      <= (others =>'0');
        s_axis_s2mm_updtsts_tvalid  <= '0';
        s_axis_s2mm_updtsts_tlast   <= '0';
        s2mm_new_curdesc            <= (others =>'0');
        s2mm_new_curdesc_wren       <= '0';
        s_axis_s2mm_cmd_tvalid      <= '0';
        s_axis_s2mm_cmd_tdata       <= (others =>'0');
        m_axis_s2mm_sts_tready      <= '0';
        s2mm_halted_clr             <= '0';
        s2mm_halted_set             <= '0';
        s2mm_idle_set               <= '0';
        s2mm_idle_clr               <= '0';
        s_axis_s2mm_sts_tready      <= '0';
        s2mm_stop                   <= '0';
        s2mm_desc_flush             <= '0';
        s2mm_all_idle               <= '1';
        s2mm_error                  <= '0'; -- CR#570587

end generate GEN_NO_S2MM_DMA_CONTROL;

end implementation;




--  (c) Copyright 2012 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;


library unisim;
use unisim.vcomponents.all;

library lib_cdc_v1_0_2;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;


 
entity axi_mcdma_cmd_split is
     generic (
             C_ADDR_WIDTH  : integer range 32 to 64    := 32;
             C_DM_STATUS_WIDTH               : integer range 8 to 32         := 8;
             C_INCLUDE_S2MM : integer range 0 to 1     := 0 
             );
     port (
           clock : in std_logic;
           sgresetn : in std_logic;
           clock_sec : in std_logic;
           aresetn : in std_logic;

   -- command coming from _MNGR 
           s_axis_cmd_tvalid : in std_logic;
           s_axis_cmd_tready : out std_logic;
           s_axis_cmd_tdata  : in std_logic_vector ((C_ADDR_WIDTH-32+2*32+CMD_BASE_WIDTH+46)-1 downto 0);

   -- split command to DM
           s_axis_cmd_tvalid_s : out std_logic;
           s_axis_cmd_tready_s : in std_logic;
           s_axis_cmd_tdata_s  : out std_logic_vector ((C_ADDR_WIDTH+CMD_BASE_WIDTH+8)-1 downto 0);
   -- Tvalid from Datamover
           tvalid_from_datamover    : in std_logic;
           status_in                : in std_logic_vector (C_DM_STATUS_WIDTH-1 downto 0);
           tvalid_unsplit           : out std_logic;
           status_out               : out std_logic_vector (C_DM_STATUS_WIDTH-1 downto 0);

   -- Tlast of stream data from Datamover
           tlast_stream_data        : in std_logic;
           tready_stream_data        : in std_logic;
           tlast_unsplit            : out std_logic;  
           tlast_unsplit_user       : out std_logic  

          );
end entity axi_mcdma_cmd_split;

architecture implementation of axi_mcdma_cmd_split is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";


type SPLIT_MM2S_STATE_TYPE      is (
                                IDLE,
                                SEND,
                                SPLIT
                                );

signal mm2s_cs                  : SPLIT_MM2S_STATE_TYPE;
signal mm2s_ns                  : SPLIT_MM2S_STATE_TYPE;

signal mm2s_cmd    : std_logic_vector (C_ADDR_WIDTH-32+2*32+CMD_BASE_WIDTH+46-1 downto 0);
signal command_ns    : std_logic_vector (C_ADDR_WIDTH-32+2*32+CMD_BASE_WIDTH-1 downto 0);
signal command    : std_logic_vector (C_ADDR_WIDTH-32+2*32+CMD_BASE_WIDTH-1 downto 0);

signal cache_info  : std_logic_vector (31 downto 0);
signal vsize_data  : std_logic_vector (22 downto 0);
signal vsize_data_int  : std_logic_vector (22 downto 0);
signal vsize       : std_logic_vector (22 downto 0);
signal counter     : std_logic_vector (22 downto 0);
signal counter_tlast     : std_logic_vector (22 downto 0);
signal split_cmd   : std_logic_vector (31+(C_ADDR_WIDTH-32) downto 0);
signal stride_data : std_logic_vector (22 downto 0);
signal vsize_over   : std_logic;

signal cmd_proc_cdc_from    : std_logic;
signal cmd_proc_cdc_to    : std_logic;
signal cmd_proc_cdc    : std_logic;
signal cmd_proc_ns    : std_logic;
  ATTRIBUTE async_reg                      : STRING;
--  ATTRIBUTE async_reg OF cmd_proc_cdc_to  : SIGNAL IS "true";
--  ATTRIBUTE async_reg OF cmd_proc_cdc  : SIGNAL IS "true";


signal cmd_out    : std_logic;
signal cmd_out_ns    : std_logic;

signal split_out    : std_logic;
signal split_out_ns    : std_logic;

signal command_valid : std_logic;
signal command_valid_ns : std_logic;
signal command_ready : std_logic;
signal reset_lock : std_logic;
signal reset_lock_tlast : std_logic;


signal tvalid_unsplit_int : std_logic;
signal tlast_stream_data_int : std_logic;

signal ready_for_next_cmd : std_logic;
signal ready_for_next_cmd_tlast : std_logic;
signal ready_for_next_cmd_tlast_cdc_from : std_logic;
signal ready_for_next_cmd_tlast_cdc_to : std_logic;
signal ready_for_next_cmd_tlast_cdc : std_logic;

--  ATTRIBUTE async_reg OF ready_for_next_cmd_tlast_cdc_to  : SIGNAL IS "true";
--  ATTRIBUTE async_reg OF ready_for_next_cmd_tlast_cdc  : SIGNAL IS "true";

signal tmp1, tmp2, tmp3, tmp4 : std_logic;
signal tlast_int : std_logic;

signal eof_bit : std_logic;
signal eof_bit_cdc_from : std_logic;
signal eof_bit_cdc_to : std_logic;
signal eof_bit_cdc : std_logic;
signal eof_set : std_logic;
signal over_ns, over : std_logic;

signal cmd_in : std_logic;

signal status_out_int : std_logic_vector (C_DM_STATUS_WIDTH-1 downto 0);

begin

s_axis_cmd_tvalid_s <= command_valid;
command_ready <= s_axis_cmd_tready_s;
s_axis_cmd_tdata_s <= command (103+(C_ADDR_WIDTH-32) downto 96+(C_ADDR_WIDTH-32)) & command (71+(C_ADDR_WIDTH-32) downto 0);


REGISTER_STATE_MM2S : process(clock)
    begin
        if(clock'EVENT and clock = '1')then
            if(sgresetn = '0')then
                mm2s_cs     <= IDLE;
                cmd_proc_cdc_from <= '0';
                cmd_out <= '0';
                command <= (others => '0');
                command_valid <= '0';
                split_out <= '0';
                over <= '0';
            else
                mm2s_cs     <= mm2s_ns;
                cmd_proc_cdc_from <= cmd_proc_ns;
                cmd_out <= cmd_out_ns;
                command <= command_ns;
                command_valid <= command_valid_ns;
                split_out <= split_out_ns;
                over <= over_ns;
            end if;
        end if;
    end process REGISTER_STATE_MM2S;


-- grab the MM2S command coming from MM2S_mngr
REGISTER_MM2S_CMD : process(clock)
    begin
        if(clock'EVENT and clock = '1')then
            if(sgresetn = '0')then
                mm2s_cmd <= (others => '0');
                s_axis_cmd_tready <= '0';
                cache_info <= (others => '0');
                vsize_data <= (others => '0');
                vsize_data_int <= (others => '0');
                stride_data <= (others => '0');
                eof_bit_cdc_from <= '0';
                cmd_in <= '0';
            elsif (s_axis_cmd_tvalid = '1' and ready_for_next_cmd = '1' and cmd_proc_cdc_from = '0' and ready_for_next_cmd_tlast_cdc = '1') then  -- when there is no processing being done, means it is ready to accept
                mm2s_cmd     <= s_axis_cmd_tdata;
                s_axis_cmd_tready <= '1';
                cache_info <= s_axis_cmd_tdata (149+(C_ADDR_WIDTH-32) downto 118+(C_ADDR_WIDTH-32));
                vsize_data <= s_axis_cmd_tdata (117+(C_ADDR_WIDTH-32) downto 95+(C_ADDR_WIDTH-32));
                vsize_data_int <= s_axis_cmd_tdata (117+(C_ADDR_WIDTH-32) downto 95+(C_ADDR_WIDTH-32)) - '1';
                stride_data <= s_axis_cmd_tdata (94+(C_ADDR_WIDTH-32) downto 72+(C_ADDR_WIDTH-32));
                eof_bit_cdc_from <= s_axis_cmd_tdata (30);
                cmd_in <= '1';
            else
                mm2s_cmd     <= mm2s_cmd; --split_cmd;
                vsize_data   <= vsize_data;
                vsize_data_int   <= vsize_data_int;
                stride_data   <= stride_data;
                cache_info <= cache_info;
                s_axis_cmd_tready <= '0';
                eof_bit_cdc_from <= eof_bit_cdc_from;
                cmd_in <= '0';
            end if;
        end if;
    end process REGISTER_MM2S_CMD;


REGISTER_DECR_VSIZE : process(clock)
    begin
        if(clock'EVENT and clock = '1')then
            if(sgresetn = '0')then
                vsize <= "00000000000000000000000";
            elsif (command_valid = '1' and command_ready = '1' and (vsize < vsize_data_int)) then  -- sending a cmd out to DM
                vsize <= vsize + '1';
            elsif (cmd_proc_cdc_from = '0') then  -- idle or when all cmd are sent to DM
                vsize <= "00000000000000000000000";
            else 
                vsize <= vsize;    
            end if;
        end if;
    end process REGISTER_DECR_VSIZE;

    vsize_over <= '1' when (vsize = vsize_data_int) else '0';
  --  eof_set <= eof_bit when (vsize = vsize_data_int) else '0';


 REGISTER_SPLIT : process(clock)
     begin
         if(clock'EVENT and clock = '1')then
             if(sgresetn = '0')then
                 split_cmd <= (others => '0');
             elsif (s_axis_cmd_tvalid = '1' and cmd_proc_cdc_from = '0' and ready_for_next_cmd = '1' and ready_for_next_cmd_tlast_cdc = '1') then
                 split_cmd <= s_axis_cmd_tdata (63+(C_ADDR_WIDTH-32) downto 32);          -- capture the ba when a new cmd arrives
             elsif (split_out = '1') then  -- add stride to previous ba
                 split_cmd <= split_cmd + stride_data;
             else 
                 split_cmd <= split_cmd;
             end if;

         end if;
     end process REGISTER_SPLIT;



MM2S_MACHINE : process(mm2s_cs,
                       s_axis_cmd_tvalid,
                       cmd_proc_cdc_from, 
                       vsize_over, command_ready,
                       cache_info, mm2s_cmd,
                       split_cmd, eof_set,
                       cmd_in, command
                       )
    begin
         over_ns <= '0'; 
                       cmd_proc_ns <= '0';      -- ready to receive new command 
                       split_out_ns <= '0';
                       command_valid_ns <= '0';
         mm2s_ns <= mm2s_cs;
         command_ns <= command;  
        -- Default signal assignment
        case mm2s_cs is

            -------------------------------------------------------------------
            when IDLE => 
                       command_ns <=  cache_info & mm2s_cmd (72+(C_ADDR_WIDTH-32) downto 65+(C_ADDR_WIDTH-32)) & split_cmd & mm2s_cmd (31) & eof_set & mm2s_cmd (29 downto 0); -- buf length remains the same
                  --     command_ns <=  cache_info & mm2s_cmd (72 downto 65) & split_cmd & mm2s_cmd (31 downto 0); -- buf length remains the same
                   if (cmd_in = '1' and cmd_proc_cdc_from = '0') then
                       cmd_proc_ns <= '1';      -- new command has come in and i need to start processing
                       mm2s_ns <= SEND;
                       over_ns <= '0'; 
                       split_out_ns <= '1'; 
                       command_valid_ns <= '1';
                   else 
                       mm2s_ns <= IDLE; 
                       over_ns <= '0'; 
                       cmd_proc_ns <= '0';      -- ready to receive new command 
                       split_out_ns <= '0'; 
                       command_valid_ns <= '0';
                   end if;

            -------------------------------------------------------------------
            when SEND =>
                       cmd_out_ns <= '1';
                       command_ns <=  command;

                       if (vsize_over = '1' and command_ready = '1') then
                         mm2s_ns <= IDLE; 
                         cmd_proc_ns <= '1';
                         command_valid_ns <= '0';
                         split_out_ns <= '0'; 
                         over_ns <= '1'; 
                       elsif  (command_ready = '0') then --(command_valid = '1' and command_ready = '0') then
                         mm2s_ns <= SEND;
                         command_valid_ns <= '1';
                         cmd_proc_ns <= '1'; 
                         split_out_ns <= '0'; 
                         over_ns <= '0';
                       else 
                         mm2s_ns <= SPLIT;
                         command_valid_ns <= '0';
                         cmd_proc_ns <= '1';
                         over_ns <= '0'; 
                         split_out_ns <= '0'; 
                       end if;
                  
            -------------------------------------------------------------------
            when SPLIT =>
                         cmd_proc_ns <= '1';
                         mm2s_ns <= SEND; 
                         command_ns <=  cache_info & mm2s_cmd (72+(C_ADDR_WIDTH-32) downto 65+(C_ADDR_WIDTH-32)) & split_cmd & mm2s_cmd (31) & eof_set & mm2s_cmd (29 downto 0); -- buf length remains the same
        --                 command_ns <=  cache_info & mm2s_cmd (72 downto 65) & split_cmd & mm2s_cmd (31 downto 0); -- buf length remains the same
                         cmd_out_ns <= '0';
                         split_out_ns <= '1'; 
                         command_valid_ns <= '1';

            -------------------------------------------------------------------
          -- coverage off
            when others =>
                mm2s_ns <= IDLE;
          -- coverage on

        end case;
    end process MM2S_MACHINE;


SWALLOW_TVALID : process(clock)
    begin
        if(clock'EVENT and clock = '1')then
            if(sgresetn = '0')then
                counter <= (others => '0');
           --     tvalid_unsplit_int <= '0';
                reset_lock <= '1';
                ready_for_next_cmd <= '0';
            elsif (vsize_data_int = "00000000000000000000000") then
           --     tvalid_unsplit_int <= '0';
                ready_for_next_cmd <= '1';
                reset_lock <= '0';
            elsif ((tvalid_from_datamover = '1') and (counter < vsize_data_int)) then
                counter <= counter + '1';
           --     tvalid_unsplit_int <= '0';
                ready_for_next_cmd <= '0';
                reset_lock <= '0';
            elsif ((counter = vsize_data_int) and (reset_lock = '0') and (tvalid_from_datamover = '1')) then
                counter <= (others => '0');
          --      tvalid_unsplit_int <= '1';
                ready_for_next_cmd <= '1';
            else
                counter <= counter;
           --     tvalid_unsplit_int <= '0';
                if (cmd_proc_cdc_from = '1') then
                   ready_for_next_cmd <= '0';
                else
                   ready_for_next_cmd <= ready_for_next_cmd;
                end if;
            end if;
        end if;
    end process SWALLOW_TVALID;

                tvalid_unsplit_int <= tvalid_from_datamover when (counter = vsize_data_int) else '0'; --tvalid_unsplit_int;

SWALLOW_TDATA : process(clock)
    begin
        if(clock'EVENT and clock = '1')then
            if (sgresetn = '0' or cmd_in = '1') then
               tvalid_unsplit <= '0';
               status_out_int <= (others => '0');
            else
               tvalid_unsplit <= tvalid_unsplit_int;
               if (tvalid_from_datamover = '1') then 
                  status_out_int (C_DM_STATUS_WIDTH-2 downto 0) <= status_in (C_DM_STATUS_WIDTH-2 downto 0) or status_out_int (C_DM_STATUS_WIDTH-2 downto 0); 
               else
                  status_out_int <= status_out_int;
               end if;

               if (tvalid_unsplit_int = '1') then
                  status_out_int (C_DM_STATUS_WIDTH-1) <= status_in (C_DM_STATUS_WIDTH-1);
               end if;
            end if;
        end if;
    end process SWALLOW_TDATA;


        status_out <= status_out_int;

SWALLOW_TLAST_GEN : if C_INCLUDE_S2MM = 0 generate
begin


    eof_set <= '1'; --eof_bit when (vsize = vsize_data_int) else '0';

CDC_CMD_PROC1 : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => cmd_proc_cdc_from,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => clock_sec,
        scndry_resetn              => '0',
        scndry_out                 => cmd_proc_cdc,
        scndry_vect_out            => open
    );

CDC_CMD_PROC2 : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => eof_bit_cdc_from,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => clock_sec,
        scndry_resetn              => '0',
        scndry_out                 => eof_bit_cdc,
        scndry_vect_out            => open
    );


CDC_CMD_PROC : process (clock_sec)
   begin
        if (clock_sec'EVENT and clock_sec = '1') then
           if (aresetn = '0') then
--              cmd_proc_cdc_to <= '0';
--              cmd_proc_cdc <= '0';
--              eof_bit_cdc_to <= '0';
--              eof_bit_cdc <= '0';
              ready_for_next_cmd_tlast_cdc_from <= '0';
           else
--              cmd_proc_cdc_to <= cmd_proc_cdc_from;
--              cmd_proc_cdc <= cmd_proc_cdc_to;
--              eof_bit_cdc_to <= eof_bit_cdc_from;
--              eof_bit_cdc <= eof_bit_cdc_to;
              ready_for_next_cmd_tlast_cdc_from <= ready_for_next_cmd_tlast;
           end if;
        end if;
end process CDC_CMD_PROC;

CDC_CMDTLAST_PROC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => ready_for_next_cmd_tlast_cdc_from,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => clock,
        scndry_resetn              => '0',
        scndry_out                 => ready_for_next_cmd_tlast_cdc,
        scndry_vect_out            => open
    );

--CDC_CMDTLAST_PROC : process (clock)
--   begin
--        if (clock'EVENT and clock = '1') then
--           if (sgresetn = '0') then
--              ready_for_next_cmd_tlast_cdc_to <= '0';
--              ready_for_next_cmd_tlast_cdc <= '0';
--           else
--              ready_for_next_cmd_tlast_cdc_to <= ready_for_next_cmd_tlast_cdc_from;
--              ready_for_next_cmd_tlast_cdc <= ready_for_next_cmd_tlast_cdc_to;
--           end if;
--         end if;  
--end process CDC_CMDTLAST_PROC;

SWALLOW_TLAST : process(clock_sec)
    begin
        if(clock_sec'EVENT and clock_sec = '1')then
            if(aresetn = '0')then
                counter_tlast <= (others => '0');
                tlast_stream_data_int <= '0';
                reset_lock_tlast <= '1';
                ready_for_next_cmd_tlast <= '1';
            elsif ((tlast_stream_data = '1' and tready_stream_data = '1') and vsize_data_int = "00000000000000000000000") then
                tlast_stream_data_int <= '0';
                ready_for_next_cmd_tlast <= '1';
                reset_lock_tlast <= '0';
            elsif ((tlast_stream_data = '1' and tready_stream_data = '1') and (counter_tlast < vsize_data_int)) then
                counter_tlast <= counter_tlast + '1';
                tlast_stream_data_int <= '0';
                ready_for_next_cmd_tlast <= '0';
                reset_lock_tlast <= '0';
            elsif ((counter_tlast = vsize_data_int) and (reset_lock_tlast = '0') and (tlast_stream_data = '1' and tready_stream_data = '1')) then
                counter_tlast <= (others => '0');
                tlast_stream_data_int <= '1';
                ready_for_next_cmd_tlast <= '1';
            else
                counter_tlast <= counter_tlast;
                tlast_stream_data_int <= '0';
                if (cmd_proc_cdc = '1') then
                   ready_for_next_cmd_tlast <= '0';
                else
                   ready_for_next_cmd_tlast <= ready_for_next_cmd_tlast;
                end if;
            end if;
        end if;
    end process SWALLOW_TLAST;
                
          tlast_unsplit <= tlast_stream_data when (counter_tlast = vsize_data_int and eof_bit_cdc = '1') else '0';
          tlast_unsplit_user <= tlast_stream_data when (counter_tlast = vsize_data_int) else '0';
       --   tlast_unsplit <= tlast_stream_data; -- when (counter_tlast = vsize_data_int) else '0';


end generate SWALLOW_TLAST_GEN;

SWALLOW_TLAST_GEN_S2MM : if C_INCLUDE_S2MM = 1 generate
begin

    eof_set <= eof_bit_cdc_from;
ready_for_next_cmd_tlast_cdc <= '1';

end generate SWALLOW_TLAST_GEN_S2MM;


end implementation;


--  (c) Copyright 2012 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES. 
------------------------------------------------------------
-------------------------------------------------------------------------------
-- Filename:          axi_mcdma.vhd
-- Description: This entity is the top level entity for the AXI DMA core.
--
-- VHDL-Standard:   VHDL'93
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_misc.all;

library unisim;
use unisim.vcomponents.all;

library axi_mcdma_v1_1_8;
use axi_mcdma_v1_1_8.axi_mcdma_pkg.all;

library axi_msg_v1_0_8;
use axi_msg_v1_0_8.all;

library axi_datamover_v5_1_29;
use axi_datamover_v5_1_29.all;

library lib_pkg_v1_0_2;
use lib_pkg_v1_0_2.lib_pkg.max2;

library lib_fifo_v1_0_16;
library lib_cdc_v1_0_2;

library lib_srl_fifo_v1_0_2;
use lib_srl_fifo_v1_0_2.srl_fifo_f;

-------------------------------------------------------------------------------
entity  axi_mcdma is
    generic(
        C_S_AXI_LITE_ADDR_WIDTH          : integer range 2 to 32    := 12;
            -- Address width of the AXI Lite Interface

        C_S_AXI_LITE_DATA_WIDTH          : integer range 32 to 32    := 32;
            -- Data width of the AXI Lite Interface

        C_DLYTMR_RESOLUTION         : integer range 1 to 100000      := 125;
            -- Interrupt Delay Timer resolution in usec

        C_PRMRY_IS_ACLK_ASYNC        : integer range 0 to 1          := 0;
            -- Primary MM2S/S2MM sync/async mode
            -- 0 = synchronous mode     - all clocks are synchronous
            -- 1 = asynchronous mode    - Any one of the 4 clock inputs is not
            --                            synchronous to the other
        -----------------------------------------------------------------------
        -- Scatter Gather Parameters
        -----------------------------------------------------------------------
        C_INCLUDE_SG                : integer range 0 to 1          := 1;
            -- Include or Exclude the Scatter Gather Engine
            -- 0 = Exclude SG Engine - Enables Simple DMA Mode
            -- 1 = Include SG Engine - Enables Scatter Gather Mode

  --      C_SG_INCLUDE_DESC_QUEUE     : integer range 0 to 1          := 0;
            -- Include or Exclude Scatter Gather Descriptor Queuing
            -- 0 = Exclude SG Descriptor Queuing
            -- 1 = Include SG Descriptor Queuing

        C_SG_INCLUDE_STSCNTRL_STRM  : integer range 0 to 1          := 1;
            -- Include or Exclude AXI Status and AXI Control Streams
            -- 0 = Exclude Status and Control Streams
            -- 1 = Include Status and Control Streams

        C_SG_USE_STSAPP_LENGTH      : integer range 0 to 1          := 1;
            -- Enable or Disable use of Status Stream Rx Length.  Only valid
            -- if C_SG_INCLUDE_STSCNTRL_STRM = 1
            -- 0 = Don't use Rx Length
            -- 1 = Use Rx Length

        C_SG_LENGTH_WIDTH           : integer range 8 to 26         := 14;
            -- Descriptor Buffer Length, Transferred Bytes, and Status Stream
            -- Rx Length Width.  Indicates the least significant valid bits of
            -- descriptor buffer length, transferred bytes, or Rx Length value
            -- in the status word coincident with tlast.

        C_M_AXI_SG_ADDR_WIDTH       : integer range 32 to 64        := 32;
            -- Master AXI Memory Map Address Width for Scatter Gather R/W Port

        C_M_AXI_SG_DATA_WIDTH       : integer range 32 to 32        := 32;
            -- Master AXI Memory Map Data Width for Scatter Gather R/W Port

        C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH : integer range 32 to 32    := 32;
            -- Master AXI Control Stream Data Width

        C_S_AXIS_S2MM_STS_TDATA_WIDTH   : integer range 32 to 32    := 32;
            -- Slave AXI Status Stream Data Width

        -----------------------------------------------------------------------
        -- Memory Map to Stream (MM2S) Parameters
        -----------------------------------------------------------------------
        C_INCLUDE_MM2S                  : integer range 0 to 1      := 1;
            -- Include or exclude MM2S primary data path
            -- 0 = Exclude MM2S primary data path
            -- 1 = Include MM2S primary data path

        C_INCLUDE_MM2S_SF               : integer range 0 to 1      := 1;
          -- This parameter specifies the inclusion/omission of the
          -- MM2S (Read) Store and Forward function
          -- 0 = Omit MM2S Store and Forward
          -- 1 = Include MM2S Store and Forward

        C_INCLUDE_MM2S_DRE              : integer range 0 to 1      := 0;
            -- Include or exclude MM2S data realignment engine (DRE)
            -- 0 = Exclude MM2S DRE
            -- 1 = Include MM2S DRE

        C_MM2S_BURST_SIZE               : integer range 2 to 256   := 16;
            -- Maximum burst size per burst request on MM2S Read Port


        C_M_AXI_MM2S_ADDR_WIDTH         : integer range 32 to 64    := 32;
            -- Master AXI Memory Map Address Width for MM2S Read Port

        C_M_AXI_MM2S_DATA_WIDTH         : integer range 32 to 1024  := 32;
            -- Master AXI Memory Map Data Width for MM2S Read Port

        C_M_AXIS_MM2S_TDATA_WIDTH       : integer range 8 to 1024    := 32;
            -- Master AXI Stream Data Width for MM2S Channel

        -----------------------------------------------------------------------
        -- Stream to Memory Map (S2MM) Parameters
        -----------------------------------------------------------------------
        C_INCLUDE_S2MM                  : integer range 0 to 1      := 1;
            -- Include or exclude S2MM primary data path
            -- 0 = Exclude S2MM primary data path
            -- 1 = Include S2MM primary data path

        C_INCLUDE_S2MM_SF               : integer range 0 to 1      := 1;
          -- This parameter specifies the inclusion/omission of the
          -- S2MM (Write) Store and Forward function
          -- 0 = Omit S2MM Store and Forward
          -- 1 = Include S2MM Store and Forward


        C_INCLUDE_S2MM_DRE              : integer range 0 to 1      := 0;
            -- Include or exclude S2MM data realignment engine (DRE)
            -- 0 = Exclude S2MM DRE
            -- 1 = Include S2MM DRE

        C_S2MM_BURST_SIZE               : integer range 2 to 256   := 16;
            -- Maximum burst size per burst request on S2MM Write Port

        C_M_AXI_S2MM_ADDR_WIDTH         : integer range 32 to 64    := 32;
            -- Master AXI Memory Map Address Width for S2MM Write Port

        C_M_AXI_S2MM_DATA_WIDTH         : integer range 32 to 1024  := 32;
            -- Master AXI Memory Map Data Width for MM2SS2MMWrite Port

        C_S_AXIS_S2MM_TDATA_WIDTH       : integer range 8 to 1024    := 32;
            -- Slave AXI Stream Data Width for S2MM Channel
        C_NUM_S2MM_CHANNELS             : integer range 1 to 16 := 1;
            -- Number of S2MM channels, primarily for MCDMA
        C_NUM_MM2S_CHANNELS             : integer range 1 to 16 := 1;
            -- Number of MM2S channels, primarily for MCDMA

        C_FAMILY                        : string            := "virtex7";
        C_ENABLE_SINGLE_INTR            : integer range 0 to 1 := 1;
        C_MM2S_SCHEDULER                 : integer range 0 to 3 := 3;
        C_GROUP1_MM2S                   : string := "1111111111111111";
        C_GROUP2_MM2S                   : string := "0000000000000000";
        C_GROUP3_MM2S                   : string := "0000000000000000";
        C_GROUP4_MM2S                   : string := "0000000000000000";
        C_GROUP5_MM2S                   : string := "0000000000000000";
        C_GROUP6_MM2S                   : string := "0000000000000000";
        C_GROUP1_S2MM                   : string := "1111111111111111";
        C_GROUP2_S2MM                   : string := "0000000000000000";
        C_GROUP3_S2MM                   : string := "0000000000000000";
        C_GROUP4_S2MM                   : string := "0000000000000000";
        C_GROUP5_S2MM                   : string := "0000000000000000";
        C_GROUP6_S2MM                   : string := "0000000000000000";
            -- Target FPGA Device Family
        C_INSTANCE                      : string   := "axi_mcdma"
    );
    port (
        s_axi_lite_aclk             : in  std_logic   := '0'                      ;              --
        s_axi_aclk             : in  std_logic   := '0'                      ;              --
        m_axi_sg_aclk               : in  std_logic   := '0'                      ;              --
        m_axi_mm2s_aclk             : in  std_logic   := '0'                      ;              --
        m_axi_s2mm_aclk             : in  std_logic   := '0'                      ;              --
    -----------------------------------------------------------------------
    -- Primary Clock CDMA
    -----------------------------------------------------------------------
        axi_resetn                  : in  std_logic   := '0'                      ;              --
                                                                                           --
        -----------------------------------------------------------------------            --
        -- AXI Lite Control Interface                                                      --
        -----------------------------------------------------------------------            --
        -- AXI Lite Write Address Channel                                                  --
        s_axi_lite_awvalid          : in  std_logic   := '0'                      ;              --
        s_axi_lite_awready          : out std_logic                         ;              --
        s_axi_lite_awaddr           : in  std_logic_vector                                 --
                                        (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0) := (others => '0');              --
                                                                                           --
        -- AXI Lite Write Data Channel                                                     --
        s_axi_lite_wvalid           : in  std_logic     := '0'                    ;              --
        s_axi_lite_wready           : out std_logic                         ;              --
        s_axi_lite_wdata            : in  std_logic_vector                                 --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0) := (others => '0');              --
                                                                                           --
        -- AXI Lite Write Response Channel                                                 --
        s_axi_lite_bresp            : out std_logic_vector(1 downto 0)      ;              --
        s_axi_lite_bvalid           : out std_logic                         ;              --
        s_axi_lite_bready           : in  std_logic     := '0'                    ;              --
                                                                                           --
        -- AXI Lite Read Address Channel                                                   --
        s_axi_lite_arvalid          : in  std_logic     := '0'                    ;              --
        s_axi_lite_arready          : out std_logic                         ;              --
        s_axi_lite_araddr           : in  std_logic_vector                                 --
                                        (C_S_AXI_LITE_ADDR_WIDTH-1 downto 0) := (others => '0');              --
        s_axi_lite_rvalid           : out std_logic                         ;              --
        s_axi_lite_rready           : in  std_logic     := '0'                    ;              --
        s_axi_lite_rdata            : out std_logic_vector                                 --
                                        (C_S_AXI_LITE_DATA_WIDTH-1 downto 0);              --
        s_axi_lite_rresp            : out std_logic_vector(1 downto 0)      ;              --
                                                                                           --
        -----------------------------------------------------------------------            --
        -- AXI Scatter Gather Interface                                                    --
        -----------------------------------------------------------------------            --
        -- Scatter Gather Write Address Channel                                            --
        m_axi_sg_awaddr             : out std_logic_vector                                 --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;              --
        m_axi_sg_awlen              : out std_logic_vector(7 downto 0)      ;              --
        m_axi_sg_awsize             : out std_logic_vector(2 downto 0)      ;              --
        m_axi_sg_awburst            : out std_logic_vector(1 downto 0)      ;              --
        m_axi_sg_awprot             : out std_logic_vector(2 downto 0)      ;              --
        m_axi_sg_awcache            : out std_logic_vector(3 downto 0)      ;              --
        m_axi_sg_awuser             : out std_logic_vector(3 downto 0)      ;              --
        m_axi_sg_awvalid            : out std_logic                         ;              --
        m_axi_sg_awready            : in  std_logic      := '0'                   ;              --
                                                                                           --
        -- Scatter Gather Write Data Channel                                               --
        m_axi_sg_wdata              : out std_logic_vector                                 --
                                        (C_M_AXI_SG_DATA_WIDTH-1 downto 0)  ;              --
        m_axi_sg_wstrb              : out std_logic_vector                                 --
                                        ((C_M_AXI_SG_DATA_WIDTH/8)-1 downto 0);            --
        m_axi_sg_wlast              : out std_logic                         ;              --
        m_axi_sg_wvalid             : out std_logic                         ;              --
        m_axi_sg_wready             : in  std_logic      := '0'                   ;              --
                                                                                           --
        -- Scatter Gather Write Response Channel                                           --
        m_axi_sg_bresp              : in  std_logic_vector(1 downto 0)  := "00"    ;              --
        m_axi_sg_bvalid             : in  std_logic       := '0'                  ;              --
        m_axi_sg_bready             : out std_logic                         ;              --
                                                                                           --
        -- Scatter Gather Read Address Channel                                             --
        m_axi_sg_araddr             : out std_logic_vector                                 --
                                        (C_M_AXI_SG_ADDR_WIDTH-1 downto 0)  ;              --
        m_axi_sg_arlen              : out std_logic_vector(7 downto 0)      ;              --
        m_axi_sg_arsize             : out std_logic_vector(2 downto 0)      ;              --
        m_axi_sg_arburst            : out std_logic_vector(1 downto 0)      ;              --
        m_axi_sg_arprot             : out std_logic_vector(2 downto 0)      ;              --
        m_axi_sg_arcache            : out std_logic_vector(3 downto 0)      ;              --
        m_axi_sg_aruser             : out std_logic_vector(3 downto 0)      ;              --
        m_axi_sg_arvalid            : out std_logic                         ;              --
        m_axi_sg_arready            : in  std_logic       := '0'                  ;              --
                                                                                           --
        -- Memory Map to Stream Scatter Gather Read Data Channel                           --
        m_axi_sg_rdata              : in  std_logic_vector                                 --
                                        (C_M_AXI_SG_DATA_WIDTH-1 downto 0)  := (others => '0');              --
        m_axi_sg_rresp              : in  std_logic_vector(1 downto 0)      := "00";              --
        m_axi_sg_rlast              : in  std_logic                         := '0';              --
        m_axi_sg_rvalid             : in  std_logic                         := '0';              --
        m_axi_sg_rready             : out std_logic                         ;              --
                                                                                           --
                                                                                           --
        -----------------------------------------------------------------------            --
        -- AXI MM2S Channel                                                                --
        -----------------------------------------------------------------------            --
        -- Memory Map To Stream Read Address Channel                                       --
        m_axi_mm2s_araddr           : out std_logic_vector                                 --
                                        (C_M_AXI_MM2S_ADDR_WIDTH-1 downto 0);              --
        m_axi_mm2s_arlen            : out std_logic_vector(7 downto 0)      ;              --
        m_axi_mm2s_arsize           : out std_logic_vector(2 downto 0)      ;              --
        m_axi_mm2s_arburst          : out std_logic_vector(1 downto 0)      ;              --
        m_axi_mm2s_arprot           : out std_logic_vector(2 downto 0)      ;              --
        m_axi_mm2s_arcache          : out std_logic_vector(3 downto 0)      ;              --
        m_axi_mm2s_aruser           : out std_logic_vector(3 downto 0)      ;              --
        m_axi_mm2s_arvalid          : out std_logic                         ;              --
        m_axi_mm2s_arready          : in  std_logic                         := '0';              --
                                                                                           --
        -- Memory Map  to Stream Read Data Channel                                         --
        m_axi_mm2s_rdata            : in  std_logic_vector                                 --
                                        (C_M_AXI_MM2S_DATA_WIDTH-1 downto 0) := (others => '0');              --
        m_axi_mm2s_rresp            : in  std_logic_vector(1 downto 0)      := "00";              --
        m_axi_mm2s_rlast            : in  std_logic                         := '0';              --
        m_axi_mm2s_rvalid           : in  std_logic                         := '0';              --
        m_axi_mm2s_rready           : out std_logic                         ;              --
                                                                                           --
        -- Memory Map to Stream Stream Interface                                           --
        mm2s_prmry_reset_out_n      : out std_logic                         ;              -- CR573702
        m_axis_mm2s_tdata           : out std_logic_vector                                 --
                                        (C_M_AXIS_MM2S_TDATA_WIDTH-1 downto 0);            --
        m_axis_mm2s_tkeep           : out std_logic_vector                                 --
                                        ((C_M_AXIS_MM2S_TDATA_WIDTH/8)-1 downto 0);        --
        m_axis_mm2s_tvalid          : out std_logic                         ;              --
        m_axis_mm2s_tready          : in  std_logic                         := '0';              --
        m_axis_mm2s_tlast           : out std_logic                         ;              --
        m_axis_mm2s_tuser           : out std_logic_vector (15 downto 0)     ;              --
        m_axis_mm2s_tid             : out std_logic_vector (7 downto 0)     ;              --
        m_axis_mm2s_tdest           : out std_logic_vector (3 downto 0)     ;              --
                                                                                           --
        -- Memory Map to Stream Control Stream Interface                                   --
        mm2s_cntrl_reset_out_n      : out std_logic                         ;              -- CR573702
        m_axis_mm2s_cntrl_tdata     : out std_logic_vector                                 --
                                        (C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH-1 downto 0);      --
        m_axis_mm2s_cntrl_tkeep     : out std_logic_vector                                 --
                                        ((C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH/8)-1 downto 0);  --
        m_axis_mm2s_cntrl_tvalid    : out std_logic                         ;              --
        m_axis_mm2s_cntrl_tready    : in  std_logic                         := '0';              --
        m_axis_mm2s_cntrl_tlast     : out std_logic                         ;              --
                                                                                           --
                                                                                           --
        -----------------------------------------------------------------------            --
        -- AXI S2MM Channel                                                                --
        -----------------------------------------------------------------------            --
        -- Stream to Memory Map Write Address Channel                                      --
        m_axi_s2mm_awaddr           : out std_logic_vector                                 --
                                        (C_M_AXI_S2MM_ADDR_WIDTH-1 downto 0);              --
        m_axi_s2mm_awlen            : out std_logic_vector(7 downto 0)      ;              --
        m_axi_s2mm_awsize           : out std_logic_vector(2 downto 0)      ;              --
        m_axi_s2mm_awburst          : out std_logic_vector(1 downto 0)      ;              --
        m_axi_s2mm_awprot           : out std_logic_vector(2 downto 0)      ;              --
        m_axi_s2mm_awcache          : out std_logic_vector(3 downto 0)      ;              --
        m_axi_s2mm_awuser           : out std_logic_vector(3 downto 0)      ;              --
        m_axi_s2mm_awvalid          : out std_logic                         ;              --
        m_axi_s2mm_awready          : in  std_logic                         := '0';              --
                                                                                           --
        -- Stream to Memory Map Write Data Channel                                         --
        m_axi_s2mm_wdata            : out std_logic_vector                                 --
                                        (C_M_AXI_S2MM_DATA_WIDTH-1 downto 0);              --
        m_axi_s2mm_wstrb            : out std_logic_vector                                 --
                                        ((C_M_AXI_S2MM_DATA_WIDTH/8)-1 downto 0);          --
        m_axi_s2mm_wlast            : out std_logic                         ;              --
        m_axi_s2mm_wvalid           : out std_logic                         ;              --
        m_axi_s2mm_wready           : in  std_logic                         := '0';              --
                                                                                           --
        -- Stream to Memory Map Write Response Channel                                     --
        m_axi_s2mm_bresp            : in  std_logic_vector(1 downto 0)      := "00";              --
        m_axi_s2mm_bvalid           : in  std_logic                         := '0';              --
        m_axi_s2mm_bready           : out std_logic                         ;              --
                                                                                           --
        -- Stream to Memory Map Steam Interface                                            --
        s2mm_prmry_reset_out_n      : out std_logic                         ;              -- CR573702
        s_axis_s2mm_tdata           : in  std_logic_vector                                 --
                                        (C_S_AXIS_S2MM_TDATA_WIDTH-1 downto 0) := (others => '0');            --
        s_axis_s2mm_tkeep           : in  std_logic_vector                                 --
                                        ((C_S_AXIS_S2MM_TDATA_WIDTH/8)-1 downto 0) := (others => '1');        --
        s_axis_s2mm_tvalid          : in  std_logic                         := '0';              --
        s_axis_s2mm_tready          : out std_logic                         ;              --
        s_axis_s2mm_tlast           : in  std_logic                         := '0';              --
        s_axis_s2mm_tuser           : in std_logic_vector (15 downto 0) := (others => '0')     ;              --
        s_axis_s2mm_tid             : in std_logic_vector (7 downto 0) := (others => '0')    ;              --
        s_axis_s2mm_tdest           : in std_logic_vector (3 downto 0) := (others => '0')    ;               --
                                                                                           --
        -- Stream to Memory Map Status Steam Interface                                     --
        s2mm_sts_reset_out_n        : out std_logic                         ;              -- CR573702
        s_axis_s2mm_sts_tdata       : in  std_logic_vector                                 --
                                        (C_S_AXIS_S2MM_STS_TDATA_WIDTH-1 downto 0) := (others => '0');        --
        s_axis_s2mm_sts_tkeep       : in  std_logic_vector                                 --
                                        ((C_S_AXIS_S2MM_STS_TDATA_WIDTH/8)-1 downto 0) := (others => '1');    --
        s_axis_s2mm_sts_tvalid      : in  std_logic                         := '0';              --
        s_axis_s2mm_sts_tready      : out std_logic                         ;              --
        s_axis_s2mm_sts_tlast       : in  std_logic                         := '0';              --

        -- MM2S and S2MM Channel Interrupts                                                --
        mm2s_introut                : out std_logic                         ;              --
        mm2s_ch1_introut                : out std_logic                         ;              --
        mm2s_ch2_introut                : out std_logic                         ;              --
        mm2s_ch3_introut                : out std_logic                         ;              --
        mm2s_ch4_introut                : out std_logic                         ;              --
        mm2s_ch5_introut                : out std_logic                         ;              --
        mm2s_ch6_introut                : out std_logic                         ;              --
        mm2s_ch7_introut                : out std_logic                         ;              --
        mm2s_ch8_introut                : out std_logic                         ;              --
        mm2s_ch9_introut                : out std_logic                         ;              --
        mm2s_ch10_introut                : out std_logic                         ;              --
        mm2s_ch11_introut                : out std_logic                         ;              --
        mm2s_ch12_introut                : out std_logic                         ;              --
        mm2s_ch13_introut                : out std_logic                         ;              --
        mm2s_ch14_introut                : out std_logic                         ;              --
        mm2s_ch15_introut                : out std_logic                         ;              --
        mm2s_ch16_introut                : out std_logic                         ;              --
        s2mm_introut                : out std_logic                         ;              --
        s2mm_ch1_introut                : out std_logic                         ;              --
        s2mm_ch2_introut                : out std_logic                         ;              --
        s2mm_ch3_introut                : out std_logic                         ;              --
        s2mm_ch4_introut                : out std_logic                         ;              --
        s2mm_ch5_introut                : out std_logic                         ;              --
        s2mm_ch6_introut                : out std_logic                         ;              --
        s2mm_ch7_introut                : out std_logic                         ;              --
        s2mm_ch8_introut                : out std_logic                         ;              --
        s2mm_ch9_introut                : out std_logic                         ;              --
        s2mm_ch10_introut                : out std_logic                         ;              --
        s2mm_ch11_introut                : out std_logic                         ;              --
        s2mm_ch12_introut                : out std_logic                         ;              --
        s2mm_ch13_introut                : out std_logic                         ;              --
        s2mm_ch14_introut                : out std_logic                         ;              --
        s2mm_ch15_introut                : out std_logic                         ;              --
        s2mm_ch16_introut                : out std_logic                         ;              --
        axi_mcdma_tstvec              : out std_logic_vector(31 downto 0)  ;                  
        axi_mcdma_tstvec_s2mm_eof     : out std_logic_vector (15 downto 0) ;
        axi_mcdma_tstvec_s2mm_sof     : out std_logic_vector (15 downto 0) ;
        axi_mcdma_tstvec_mm2s_eof     : out std_logic_vector(15 downto 0) ;
        axi_mcdma_tstvec_mm2s_sof     : out std_logic_vector(15 downto 0) ;
        axi_mcdma_tstvec_s2mm_ioc     : out std_logic_vector(15 downto 0) ;
        axi_mcdma_tstvec_mm2s_ioc     : out std_logic_vector(15 downto 0) 

    -----------------------------------------------------------------------
    -- Test Support for Xilinx internal use
    -----------------------------------------------------------------------
    );

end axi_mcdma;

-------------------------------------------------------------------------------
-- Architecture
-------------------------------------------------------------------------------
architecture implementation of axi_mcdma is
  attribute DowngradeIPIdentifiedWarnings: string;
  attribute DowngradeIPIdentifiedWarnings of implementation : architecture is "yes";


-- The FREQ are needed only for ASYNC mode, for SYNC mode these are irrelevant
-- For Async, mm2s or s2mm >= sg >= lite

constant   C_S_AXI_LITE_ACLK_FREQ_HZ        : integer                  := 100000000;
            -- AXI Lite clock frequency in hertz
constant   C_M_AXI_MM2S_ACLK_FREQ_HZ        : integer                  := 100000000;
            -- AXI MM2S clock frequency in hertz
constant   C_M_AXI_S2MM_ACLK_FREQ_HZ        : integer                  := 100000000;
            -- AXI S2MM clock frequency in hertz
constant   C_M_AXI_SG_ACLK_FREQ_HZ          : integer                  := 100000000;
            -- Scatter Gather clock frequency in hertz

   function to_std_logic(c: character) return std_logic is
      variable sl : std_logic;
   begin
      case c is
           when 'U' =>
                sl:='U';
          -- when 'X' =>
          --      sl:='X';
           when '0' =>
                sl:='0';
           when '1' =>
                sl:='1';
           when 'Z' =>
                sl:='Z';
           when 'W' =>
                sl:='W';
           when 'L' =>
                sl:='L';
           when 'H' =>
                sl:='H';
           when '-' => 
                sl:='-';
           when others =>
                sl:='X';
      end case;
      return sl;
   end function to_std_logic;

function to_std_logic_vector(s: string) return std_logic_vector is
      variable slv : std_logic_vector(s'high-s'low downto 0);
      variable k   : integer;
   begin
      k:=s'high-s'low;
      for i in s'range loop
          slv(k):=to_std_logic(s(i));
          k     :=k-1;
      end loop;
      return slv;
   end function to_std_logic_vector;

-------------------------------------------------------------------------------
-- Functions
-------------------------------------------------------------------------------
-- Functions

  -------------------------------------------------------------------
  -- Function
  --
  -- Function Name: funct_get_max
  --
  -- Function Description:
  --   Returns the greater of two integers.
  --
  -------------------------------------------------------------------
  function funct_get_string (value_in_1 : integer)
                          return string is

    Variable max_value : string (1 to 5) := "00000";

  begin

    If (value_in_1 = 1) Then
-- coverage off
      max_value := "11100";
-- coverage on

    else

      max_value := "11111";

    End if;

    Return (max_value);

  end function funct_get_string;


  function width_calc (value_in : integer)
                     return integer is
  variable addr_value : integer := 32;

  begin
      if (value_in > 32) then
          addr_value := 64;
      else
          addr_value := 32;
      end if;

      return(addr_value);

end function width_calc;


--  function max_channel (value_in1 : integer; 
--                        value_in2 : integer)
--                     return integer is
--  variable max_out : integer := 8;

--  begin
--      if (value_in1 > value_in2) then
--         max_out := value_in1;
--      else
--         max_out := value_in2;
--      end if;

--      return(max_out);

--end function max_channel;

--  -------------------------------------------------------------------
--
--
--
--  -------------------------------------------------------------------
--  -- Function
--  --
--  -- Function Name: funct_rnd2pwr_of_2
--  --
--  -- Function Description:
--  --  Rounds the input value up to the nearest power of 2 between
--  --  128 and 8192.
--  --
--  -------------------------------------------------------------------
--  function funct_rnd2pwr_of_2 (input_value : integer) return integer is
--
--    Variable temp_pwr2 : Integer := 128;
--
--  begin
--
--    if (input_value <= 128) then
--
--       temp_pwr2 := 128;
--
--    elsif (input_value <= 256) then
--
--       temp_pwr2 := 256;
--
--    elsif (input_value <= 512) then
--
--       temp_pwr2 := 512;
--
--    elsif (input_value <= 1024) then
--
--       temp_pwr2 := 1024;
--
--    elsif (input_value <= 2048) then
--
--       temp_pwr2 := 2048;
--
--    elsif (input_value <= 4096) then
--
--       temp_pwr2 := 4096;
--
--    else
--
--       temp_pwr2 := 8192;
--
--    end if;
--
--
--    Return (temp_pwr2);
--
--  end function funct_rnd2pwr_of_2;
--  -------------------------------------------------------------------
--
--
--
--
--

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
constant ENABLE_BUF_FIFO : integer := 1;

 Constant SOFT_RST_TIME_CLKS : integer := 8;
   -- Specifies the time of the soft reset assertion in
   -- m_axi_aclk clock periods.
 constant skid_enable : string := (funct_get_string(0));

 -- Calculates the minimum needed depth of the CDMA Store and Forward FIFO
-- Constant PIPEDEPTH_BURST_LEN_PROD : integer :=
--          (funct_get_max(4, 4)+2)
--           * C_M_AXI_MAX_BURST_LEN;
--
-- -- Assigns the depth of the CDMA Store and Forward FIFO to the nearest
-- -- power of 2
-- Constant SF_FIFO_DEPTH       : integer range 128 to 8192 :=
--                                funct_rnd2pwr_of_2(PIPEDEPTH_BURST_LEN_PROD);



-- No Functions Declared

-------------------------------------------------------------------------------
-- Constants Declarations
-------------------------------------------------------------------------------
-- Scatter Gather Engine Configuration
-- Number of Fetch Descriptors to Queue
constant C_MAX_CHANNELS : integer := 16;

constant ADDR_WIDTH : integer := width_calc (C_M_AXI_SG_ADDR_WIDTH);

constant MCDMA                      : integer := 1; --(1 - C_ENABLE_MULTI_CHANNEL);
constant DESC_QUEUE                 : integer := (1*MCDMA);
constant STSCNTRL_ENABLE            : integer := (C_SG_INCLUDE_STSCNTRL_STRM*MCDMA);
constant APPLENGTH_ENABLE           : integer := (C_SG_USE_STSAPP_LENGTH*MCDMA);
constant C_SG_LENGTH_WIDTH_INT      : integer := C_SG_LENGTH_WIDTH; --(C_SG_LENGTH_WIDTH*MCDMA + 23*C_ENABLE_MULTI_CHANNEL);
-- Comment the foll 2 line to disable queuing for McDMA and uncomment the 3rd and 4th lines
--constant SG_FTCH_DESC2QUEUE         : integer := ((DESC_QUEUE * 4)*MCDMA + (2*C_ENABLE_MULTI_CHANNEL)) * C_SG_INCLUDE_DESC_QUEUE;
-- Number of Update Descriptors to Queue
--constant SG_UPDT_DESC2QUEUE         : integer := ((DESC_QUEUE * 4)*MCDMA + (2*C_ENABLE_MULTI_CHANNEL)) * C_SG_INCLUDE_DESC_QUEUE;

constant SG_FTCH_DESC2QUEUE         : integer := (DESC_QUEUE * 2);
-- Number of Update Descriptors to Queue
constant SG_UPDT_DESC2QUEUE         : integer := (DESC_QUEUE * 2);


-- Number of fetch words per descriptor for channel 1 (MM2S)
constant SG_CH1_WORDS_TO_FETCH      : integer := 8 + (5 * STSCNTRL_ENABLE);
-- Number of fetch words per descriptor for channel 2 (S2MM)
constant SG_CH2_WORDS_TO_FETCH      : integer := 8;  -- Only need to fetch 1st 8wrds for s2mm
-- Number of update words per descriptor for channel 1 (MM2S)
constant SG_CH1_WORDS_TO_UPDATE     : integer := 1;  -- Only status needs update for mm2s
-- Number of update words per descriptor for channel 2 (S2MM)
constant SG_CH2_WORDS_TO_UPDATE     : integer := 2 + (5 * STSCNTRL_ENABLE);
-- First word offset (referenced to descriptor beginning) to update for channel 1 (MM2S)
constant SG_CH1_FIRST_UPDATE_WORD   : integer := 7;  -- status word in descriptor
-- First word offset (referenced to descriptor beginning) to update for channel 2 (MM2S)
constant SG_CH2_FIRST_UPDATE_WORD   : integer := 7;  -- status word in descriptor
-- Enable stale descriptor check for channel 1
constant SG_CH1_ENBL_STALE_ERROR    : integer := 1;
-- Enable stale descriptor check for channel 2
constant SG_CH2_ENBL_STALE_ERROR    : integer := 1;
-- Width of descriptor fetch bus
constant M_AXIS_SG_TDATA_WIDTH      : integer := 32;
-- Width of descriptor update pointer bus
constant S_AXIS_UPDPTR_TDATA_WIDTH  : integer := 32;
-- Width of descriptor update status bus
constant S_AXIS_UPDSTS_TDATA_WIDTH  : integer := 33; -- IOC (1 bit) & DescStatus (32 bits)
-- Include SG Descriptor Updates
constant INCLUDE_DESC_UPDATE        : integer := 1;
-- Include SG Interrupt Logic
constant INCLUDE_INTRPT             : integer := 1;
-- Include SG Delay Interrupt
constant INCLUDE_DLYTMR             : integer := 1;


-- Primary DataMover Configuration
-- DataMover Command / Status FIFO Depth
-- Note :Set maximum to the number of update descriptors to queue, to prevent lock up do to
-- update data fifo full before
--constant DM_CMDSTS_FIFO_DEPTH       : integer := 1*C_ENABLE_MULTI_CHANNEL + (max2(1,SG_UPDT_DESC2QUEUE))*MCDMA;
constant DM_CMDSTS_FIFO_DEPTH       : integer := 1; --max2(1,SG_UPDT_DESC2QUEUE);
constant DM_CMDSTS_FIFO_DEPTH_1       : integer := 1; --((1-C_PRMRY_IS_ACLK_ASYNC)+C_PRMRY_IS_ACLK_ASYNC*DM_CMDSTS_FIFO_DEPTH);
-- DataMover Include Status FIFO
constant DM_INCLUDE_STS_FIFO        : integer := 1;

-- Enable indeterminate BTT on datamover when stscntrl stream not included or
-- when use status app rx length is not enable or when in Simple DMA mode.
constant DM_SUPPORT_INDET_BTT       : integer := 1 - (STSCNTRL_ENABLE
                                                        * APPLENGTH_ENABLE
                                                        * C_INCLUDE_SG);
-- Indterminate BTT Mode additional status vector width
constant INDETBTT_ADDED_STS_WIDTH   : integer := 24+3;
-- Base status vector width
constant BASE_STATUS_WIDTH          : integer := 8;
-- DataMover status width - is based on mode of operation
constant DM_STATUS_WIDTH            : integer := BASE_STATUS_WIDTH
                                               + (DM_SUPPORT_INDET_BTT * INDETBTT_ADDED_STS_WIDTH);
-- DataMover outstanding address request fifo depth
constant DM_ADDR_PIPE_DEPTH         : integer := 4;

-- AXI DataMover Full mode value
constant AXI_FULL_MODE              : integer := 1;
-- AXI DataMover mode for MM2S Channel (0 if channel not included)
constant MM2S_AXI_FULL_MODE         : integer := (C_INCLUDE_MM2S) * AXI_FULL_MODE;
-- AXI DataMover mode for S2MM Channel (0 if channel not included)
constant S2MM_AXI_FULL_MODE         : integer := (C_INCLUDE_S2MM) * AXI_FULL_MODE;



-- Minimum value required for length width based on burst size and stream dwidth
-- If user sets c_sg_length_width too small based on setting of burst size and
-- dwidth then this will reset the width to a larger mimimum requirement.
constant DM_BTT_LENGTH_WIDTH : integer := max2((required_btt_width(C_M_AXIS_MM2S_TDATA_WIDTH,
                                                            C_MM2S_BURST_SIZE,
                                                            C_SG_LENGTH_WIDTH_INT)*C_INCLUDE_MM2S),
                                         (required_btt_width(C_S_AXIS_S2MM_TDATA_WIDTH,
                                                            C_S2MM_BURST_SIZE,
                                                            C_SG_LENGTH_WIDTH_INT)*C_INCLUDE_S2MM));


-- Enable store and forward on datamover if data widths are mismatched (allows upsizers
-- to be instantiated) or when enabled by user.
constant DM_MM2S_INCLUDE_SF             : integer := enable_snf(C_INCLUDE_MM2S_SF,
                                                                C_M_AXI_MM2S_DATA_WIDTH,
                                                                C_M_AXIS_MM2S_TDATA_WIDTH);

-- Enable store and forward on datamover if data widths are mismatched (allows upsizers
-- to be instantiated) or when enabled by user.
constant DM_S2MM_INCLUDE_SF             : integer := enable_snf(C_INCLUDE_S2MM_SF,
                                                                C_M_AXI_S2MM_DATA_WIDTH,
                                                                C_S_AXIS_S2MM_TDATA_WIDTH);





-- Always allow datamover address requests
constant ALWAYS_ALLOW       : std_logic := '1';


-- Return correct freq_hz parameter depending on if sg engine is included
constant M_AXI_SG_ACLK_FREQ_HZ  :integer := hertz_prmtr_select(C_INCLUDE_SG,
                                                               C_S_AXI_LITE_ACLK_FREQ_HZ,
                                                               C_M_AXI_SG_ACLK_FREQ_HZ);

-- Scatter / Gather is always configure for synchronous operation for AXI DMA
constant SG_IS_SYNCHRONOUS     : integer := 0;

constant CMD_WIDTH : integer := (ADDR_WIDTH+ CMD_BASE_WIDTH-3) ;

constant MM2S_GP1 : std_logic_vector (15 downto 0) := to_std_logic_vector(C_GROUP1_MM2S);
constant MM2S_GP2 : std_logic_vector (15 downto 0) := to_std_logic_vector(C_GROUP2_MM2S);
constant MM2S_GP3 : std_logic_vector (15 downto 0) := to_std_logic_vector(C_GROUP3_MM2S);
constant MM2S_GP4 : std_logic_vector (15 downto 0) := to_std_logic_vector(C_GROUP4_MM2S);
constant MM2S_GP5 : std_logic_vector (15 downto 0) := to_std_logic_vector(C_GROUP5_MM2S);
constant MM2S_GP6 : std_logic_vector (15 downto 0) := to_std_logic_vector(C_GROUP6_MM2S);

constant S2MM_GP1 : std_logic_vector (15 downto 0) := to_std_logic_vector(C_GROUP1_S2MM);
constant S2MM_GP2 : std_logic_vector (15 downto 0) := to_std_logic_vector(C_GROUP2_S2MM);
constant S2MM_GP3 : std_logic_vector (15 downto 0) := to_std_logic_vector(C_GROUP3_S2MM);
constant S2MM_GP4 : std_logic_vector (15 downto 0) := to_std_logic_vector(C_GROUP4_S2MM);
constant S2MM_GP5 : std_logic_vector (15 downto 0) := to_std_logic_vector(C_GROUP5_S2MM);
constant S2MM_GP6 : std_logic_vector (15 downto 0) := to_std_logic_vector(C_GROUP6_S2MM);

constant C_MM2S_SCHEDULER_NEW : integer := get_scheduler (C_NUM_MM2S_CHANNELS, C_MM2S_SCHEDULER);

signal LOGIC_LOW : std_logic;
signal LOGIC_HIGH : std_logic;

-------------------------------------------------------------------------------
-- Signal / Type Declarations
-------------------------------------------------------------------------------
signal axi_lite_aclk            : std_logic := '1';
signal axi_sg_aclk              : std_logic := '1';

signal m_axi_sg_aresetn         : std_logic := '1';     -- SG Reset on sg aclk domain (Soft/Hard)
signal dm_m_axi_sg_aresetn      : std_logic := '1';     -- SG Reset on sg aclk domain (Soft/Hard) (Raw)
signal m_axi_mm2s_aresetn       : std_logic := '1';     -- MM2S Channel Reset on s2mm aclk domain (Soft/Hard)(Raw)
signal m_axi_s2mm_aresetn       : std_logic := '1';     -- S2MM Channel Reset on s2mm aclk domain (Soft/Hard)(Raw)
signal mm2s_scndry_resetn       : std_logic := '1';     -- MM2S Channel Reset on sg aclk domain (Soft/Hard)
signal s2mm_scndry_resetn       : std_logic := '1';     -- S2MM Channel Reset on sg aclk domain (Soft/Hard)
signal mm2s_prmry_resetn        : std_logic := '1';     -- MM2S Channel Reset on s2mm aclk domain (Soft/Hard)
signal s2mm_prmry_resetn        : std_logic := '1';     -- S2MM Channel Reset on s2mm aclk domain (Soft/Hard)
signal axi_lite_reset_n         : std_logic := '1';     -- AXI Lite Interface Reset (Hard Only)
signal m_axi_sg_hrdresetn       : std_logic := '1';     -- AXI Lite Interface Reset on SG clock domain (Hard Only)
signal dm_mm2s_scndry_resetn    : std_logic := '1';     -- MM2S Channel Reset on sg domain (Soft/Hard)(Raw)
signal dm_s2mm_scndry_resetn    : std_logic := '1';     -- S2MM Channel Reset on sg domain (Soft/Hard)(Raw)


-- Register Module Signals
signal mm2s_halted_clr          : std_logic := '0';
signal mm2s_halted_set          : std_logic := '0';
signal mm2s_idle_set            : std_logic := '0';
signal mm2s_idle_clr            : std_logic := '0';
signal mm2s_dma_interr_set      : std_logic := '0';
signal mm2s_dma_slverr_set      : std_logic := '0';
signal mm2s_dma_decerr_set      : std_logic := '0';
signal mm2s_ioc_irq_set         : std_logic := '0';
signal mm2s_dly_irq_set         : std_logic := '0';
signal mm2s_irqdelay_status     : std_logic_vector(7 downto 0) := (others => '0');
signal mm2s_irqthresh_status    : std_logic_vector(7 downto 0) := (others => '0');
signal mm2s_new_curdesc_wren    : std_logic := '0';
signal mm2s_new_curdesc         : std_logic_vector(ADDR_WIDTH-1 downto 0) := (others => '0');
signal mm2s_tailpntr_updated    : std_logic := '0';
signal mm2s_dmacr               : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');
signal mm2s_dmasr               : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)  := (others => '0');
signal mm2s_curdesc             : std_logic_vector(ADDR_WIDTH-1 downto 0)    := (others => '0');
signal mm2s_taildesc            : std_logic_vector(ADDR_WIDTH-1 downto 0)    := (others => '0');
signal mm2s_sa                  : std_logic_vector(ADDR_WIDTH-1 downto 0)    := (others => '0'); --(C_M_AXI_MM2S_ADDR_WIDTH-1 downto 0)  := (others => '0');
signal mm2s_length              : std_logic_vector(C_SG_LENGTH_WIDTH_INT-1 downto 0)        := (others => '0');
signal mm2s_length_wren         : std_logic := '0';
signal mm2s_smpl_interr_set     : std_logic := '0';
signal mm2s_smpl_slverr_set     : std_logic := '0';
signal mm2s_smpl_decerr_set     : std_logic := '0';
signal mm2s_smpl_done           : std_logic := '0';
signal mm2s_packet_sof          : std_logic := '0';
signal mm2s_packet_eof          : std_logic := '0';
signal mm2s_all_idle            : std_logic := '0';
signal mm2s_error               : std_logic := '0';
signal mm2s_dlyirq_dsble        : std_logic := '0'; -- CR605888



signal s2mm_halted_clr          : std_logic := '0';
signal s2mm_halted_set          : std_logic := '0';
signal s2mm_idle_set            : std_logic := '0';
signal s2mm_idle_clr            : std_logic := '0';
signal s2mm_dma_interr_set      : std_logic := '0';
signal s2mm_dma_slverr_set      : std_logic := '0';
signal s2mm_dma_decerr_set      : std_logic := '0';
signal s2mm_ioc_irq_set         : std_logic := '0';
signal s2mm_dly_irq_set         : std_logic := '0';
signal s2mm_irqdelay_status     : std_logic_vector(7 downto 0) := (others => '0');
signal s2mm_irqthresh_status    : std_logic_vector(7 downto 0) := (others => '0');
signal s2mm_new_curdesc_wren    : std_logic := '0';
signal s2mm_new_curdesc         : std_logic_vector(ADDR_WIDTH-1 downto 0) := (others => '0');
signal s2mm_tailpntr_updated    : std_logic := '0';
signal s2mm_dmacr               : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)    := (others => '0');
signal s2mm_dmasr               : std_logic_vector(C_S_AXI_LITE_DATA_WIDTH-1 downto 0)    := (others => '0');
signal s2mm_curdesc             : std_logic_vector(ADDR_WIDTH-1 downto 0) := (others => '0');
signal s2mm_taildesc            : std_logic_vector(ADDR_WIDTH-1 downto 0) := (others => '0');
signal s2mm_da                  : std_logic_vector(ADDR_WIDTH-1 downto 0)    := (others => '0'); --(C_M_AXI_S2MM_ADDR_WIDTH-1 downto 0)  := (others => '0');
signal s2mm_length              : std_logic_vector(C_SG_LENGTH_WIDTH_INT-1 downto 0)        := (others => '0');
signal s2mm_length_wren         : std_logic := '0';
signal s2mm_bytes_rcvd          : std_logic_vector(C_SG_LENGTH_WIDTH_INT-1 downto 0) := (others => '0');
signal s2mm_bytes_rcvd_wren     : std_logic := '0';
signal s2mm_smpl_interr_set     : std_logic := '0';
signal s2mm_smpl_slverr_set     : std_logic := '0';
signal s2mm_smpl_decerr_set     : std_logic := '0';
signal s2mm_smpl_done           : std_logic := '0';
signal s2mm_packet_sof          : std_logic := '0';
signal s2mm_packet_eof          : std_logic := '0';
signal s2mm_all_idle            : std_logic := '0';
signal s2mm_error               : std_logic := '0';
signal s2mm_dlyirq_dsble        : std_logic := '0'; -- CR605888


signal mm2s_stop                : std_logic := '0';
signal mm2s_ch2_stop                : std_logic := '0';
signal mm2s_ch3_stop                : std_logic := '0';
signal mm2s_ch4_stop                : std_logic := '0';
signal mm2s_ch5_stop                : std_logic := '0';
signal mm2s_ch6_stop                : std_logic := '0';
signal mm2s_ch7_stop                : std_logic := '0';
signal mm2s_ch8_stop                : std_logic := '0';
signal s2mm_stop                : std_logic := '0';
signal s2mm_ch1_stop                : std_logic := '0';
signal s2mm_ch2_stop                : std_logic := '0';
signal s2mm_ch3_stop                : std_logic := '0';
signal s2mm_ch4_stop                : std_logic := '0';
signal s2mm_ch5_stop                : std_logic := '0';
signal s2mm_ch6_stop                : std_logic := '0';
signal s2mm_ch7_stop                : std_logic := '0';
signal s2mm_ch8_stop                : std_logic := '0';
signal ftch_error               : std_logic := '0';
signal ftch_error_addr          : std_logic_vector(ADDR_WIDTH-1 downto 0) := (others => '0');
signal updt_error               : std_logic := '0';
signal updt_error_addr          : std_logic_vector(ADDR_WIDTH-1 downto 0) := (others => '0');

--*********************************
-- MM2S Signals
--*********************************
-- MM2S DMA Controller Signals
signal mm2s_desc_flush          : std_logic := '0';
signal mm2s_ftch_idle           : std_logic := '0';
signal mm2s_updt_idle           : std_logic := '0';
signal mm2s_updt_ioc_irq_set    : std_logic := '0';
signal mm2s_irqthresh_wren      : std_logic := '0';
signal mm2s_irqdelay_wren       : std_logic := '0';
signal mm2s_irqthresh_rstdsbl   : std_logic := '0'; -- CR572013


-- SG MM2S Descriptor Fetch AXI Stream IN
signal m_axis_mm2s_ftch_tdata_new   : std_logic_vector(96+31*0+(0+2)*(ADDR_WIDTH-32) downto 0) := (others => '0');
signal m_axis_mm2s_ftch_tdata_mcdma_new   : std_logic_vector(63 downto 0) := (others => '0');
signal m_axis_mm2s_ftch_tvalid_new  : std_logic := '0';
signal m_axis_mm2s_ftch_tdata   : std_logic_vector(M_AXIS_SG_TDATA_WIDTH-1 downto 0) := (others => '0');
signal m_axis_mm2s_ftch_tvalid  : std_logic := '0';
signal m_axis_mm2s_ftch_tready  : std_logic := '0';
signal m_axis_mm2s_ftch_tlast   : std_logic := '0';
signal m_axis_mm2s_ftch_data_valid  : std_logic := '0';

-- SG MM2S Descriptor Update AXI Stream Out
signal s_axis_mm2s_updtptr_tdata   : std_logic_vector(ADDR_WIDTH-1 downto 0) := (others => '0');
signal s_axis_mm2s_updtptr_tvalid  : std_logic := '0';
signal s_axis_mm2s_updtptr_tready  : std_logic := '0';
signal s_axis_mm2s_updtptr_tlast   : std_logic := '0';

signal s_axis_mm2s_updtsts_tdata   : std_logic_vector(S_AXIS_UPDSTS_TDATA_WIDTH-1 downto 0) := (others => '0');
signal s_axis_mm2s_updtsts_tvalid  : std_logic := '0';
signal s_axis_mm2s_updtsts_tready  : std_logic := '0';
signal s_axis_mm2s_updtsts_tlast   : std_logic := '0';

-- DataMover MM2S Command Stream Signals
signal s_axis_mm2s_cmd_tvalid_split   : std_logic := '0';
signal s_axis_mm2s_cmd_tready_split   : std_logic := '0';
signal s_axis_mm2s_cmd_tdata_split    : std_logic_vector
                                    ((ADDR_WIDTH-32+2*32+CMD_BASE_WIDTH+46)-1 downto 0) := (others => '0');
signal s_axis_s2mm_cmd_tvalid_split   : std_logic := '0';
signal s_axis_s2mm_cmd_tready_split   : std_logic := '0';
signal s_axis_s2mm_cmd_tdata_split    : std_logic_vector
                                    ((ADDR_WIDTH-32+2*32+CMD_BASE_WIDTH+46)-1 downto 0) := (others => '0');
signal s_axis_mm2s_cmd_tvalid   : std_logic := '0';
signal s_axis_mm2s_cmd_tready   : std_logic := '0';
signal s_axis_mm2s_cmd_tdata    : std_logic_vector
              ((ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0) := (others => '0');
-- DataMover MM2S Status Stream Signals
signal m_axis_mm2s_sts_tvalid   : std_logic := '0';
signal m_axis_mm2s_sts_tvalid_int   : std_logic := '0';
signal m_axis_mm2s_sts_tready   : std_logic := '0';
signal m_axis_mm2s_sts_tdata    : std_logic_vector(7 downto 0) := (others => '0');
signal m_axis_mm2s_sts_tdata_int    : std_logic_vector(7 downto 0) := (others => '0');
signal m_axis_mm2s_sts_tkeep    : std_logic_vector(0 downto 0) := (others => '0');
signal mm2s_err                 : std_logic := '0';
signal mm2s_halt                : std_logic := '0';
signal mm2s_halt_cmplt          : std_logic := '0';

-- S2MM DMA Controller Signals
signal s2mm_desc_flush          : std_logic := '0';
signal s2mm_ftch_idle           : std_logic := '0';
signal s2mm_updt_idle           : std_logic := '0';
signal s2mm_updt_ioc_irq_set    : std_logic := '0';
signal s2mm_irqthresh_wren      : std_logic := '0';
signal s2mm_irqdelay_wren       : std_logic := '0';
signal s2mm_irqthresh_rstdsbl   : std_logic := '0'; -- CR572013


-- SG S2MM Descriptor Fetch AXI Stream IN
signal m_axis_s2mm_ftch_tdata_new   : std_logic_vector(96+31*0+(0+2)*(ADDR_WIDTH-32) downto 0) := (others => '0');
signal m_axis_s2mm_ftch_tdata_mcdma_new   : std_logic_vector(63 downto 0) := (others => '0');
signal m_axis_s2mm_ftch_tdata_mcdma_nxt   : std_logic_vector(ADDR_WIDTH-1 downto 0) := (others => '0');
signal m_axis_s2mm_ftch_tvalid_new  : std_logic := '0';
signal m_axis_ftch2_desc_available, m_axis_ftch1_desc_available : std_logic;
signal m_axis_s2mm_ftch_tdata   : std_logic_vector(M_AXIS_SG_TDATA_WIDTH-1 downto 0) := (others => '0');
signal m_axis_s2mm_ftch_tvalid  : std_logic := '0';
signal m_axis_s2mm_ftch_data_valid  : std_logic := '0';
signal m_axis_s2mm_ftch_tready  : std_logic := '0';
signal m_axis_s2mm_ftch_tlast   : std_logic := '0';
signal mm2s_axis_info           : std_logic_vector(13 downto 0) := (others => '0');

-- SG S2MM Descriptor Update AXI Stream Out
signal s_axis_s2mm_updtptr_tdata   : std_logic_vector(ADDR_WIDTH-1 downto 0) := (others => '0');
signal s_axis_s2mm_updtptr_tvalid  : std_logic := '0';
signal s_axis_s2mm_updtptr_tready  : std_logic := '0';
signal s_axis_s2mm_updtptr_tlast   : std_logic := '0';

signal s_axis_s2mm_updtsts_tdata   : std_logic_vector(S_AXIS_UPDSTS_TDATA_WIDTH-1 downto 0) := (others => '0');
signal s_axis_s2mm_updtsts_tvalid  : std_logic := '0';
signal s_axis_s2mm_updtsts_tready  : std_logic := '0';
signal s_axis_s2mm_updtsts_tlast   : std_logic := '0';
signal s_axis_s2mm_updtsts_id      : std_logic_vector (C_MAX_CHANNELS-1 downto 0) := (others => '0');
signal s_axis_mm2s_updtsts_id      : std_logic_vector (C_MAX_CHANNELS-1 downto 0) := (others => '0');

-- DataMover S2MM Command Stream Signals
signal s_axis_s2mm_cmd_tvalid   : std_logic := '0';
signal s_axis_s2mm_cmd_tready   : std_logic := '0';
--signal s_axis_s2mm_cmd_tdata    : std_logic_vector
--           ((ADDR_WIDTH+CMD_BASE_WIDTH+(8*C_ENABLE_MULTI_CHANNEL))-1 downto 0) := (others => '0');
signal s_axis_s2mm_cmd_tdata    : std_logic_vector
                                    ((ADDR_WIDTH+CMD_BASE_WIDTH)-1 downto 0) := (others => '0');
-- DataMover S2MM Status Stream Signals
signal m_axis_s2mm_sts_tvalid   : std_logic := '0';
signal m_axis_s2mm_sts_tvalid_int   : std_logic := '0';
signal m_axis_s2mm_sts_tready   : std_logic := '0';
signal m_axis_s2mm_sts_tdata    : std_logic_vector(DM_STATUS_WIDTH - 1 downto 0) := (others => '0');
signal m_axis_s2mm_sts_tdata_int    : std_logic_vector(DM_STATUS_WIDTH - 1 downto 0) := (others => '0');
signal m_axis_s2mm_sts_tkeep    : std_logic_vector((DM_STATUS_WIDTH/8)-1 downto 0) := (others => '0');
signal s2mm_err                 : std_logic := '0';
signal s2mm_halt                : std_logic := '0';
signal s2mm_halt_cmplt          : std_logic := '0';

-- Error Status Control
signal mm2s_ftch_interr_set     : std_logic := '0';
signal mm2s_ftch_slverr_set     : std_logic := '0';
signal mm2s_ftch_decerr_set     : std_logic := '0';
signal mm2s_updt_interr_set     : std_logic := '0';
signal mm2s_updt_slverr_set     : std_logic := '0';
signal mm2s_updt_decerr_set     : std_logic := '0';
signal mm2s_ftch_err_early      : std_logic := '0';
signal mm2s_ftch_stale_desc     : std_logic := '0';


signal s2mm_updt_interr_set     : std_logic := '0';
signal s2mm_updt_slverr_set     : std_logic := '0';
signal s2mm_updt_decerr_set     : std_logic := '0';
signal s2mm_ftch_interr_set     : std_logic := '0';
signal s2mm_ftch_slverr_set     : std_logic := '0';
signal s2mm_ftch_decerr_set     : std_logic := '0';
signal s2mm_ftch_err_early      : std_logic := '0';
signal s2mm_ftch_stale_desc     : std_logic := '0';


signal soft_reset_clr           : std_logic := '0';
signal soft_reset               : std_logic := '0';

signal s_axis_s2mm_tready_i     : std_logic := '0';
signal s_axis_s2mm_tready_int     : std_logic := '0';
signal m_axis_mm2s_tlast_i      : std_logic := '0';
signal mm2s_tlast : std_logic := '0';
signal mm2s_tuser_tid : std_logic_vector (23 downto 0);
signal m_axis_mm2s_tdest_int : std_logic_vector (3 downto 0);
signal m_axis_mm2s_tlast_i_user      : std_logic := '0';
signal m_axis_mm2s_tvalid_i     : std_logic := '0';
signal sg_ctl                   : std_logic_vector (7 downto 0);

signal s_axis_s2mm_tvalid_int   : std_logic;
signal s_axis_s2mm_tlast_int   : std_logic;

signal tdest_out_int           : std_logic_vector (6 downto 0);
signal same_tdest              : std_logic;

signal s2mm_eof_s2mm           : std_logic;
signal ch2_update_active       : std_logic; 

signal s2mm_desc_info_in          : std_logic_vector (13 downto 0);

signal m_axis_mm2s_tlast_i_mcdma : std_logic;

signal s2mm_tvalid_latch : std_logic;
signal s2mm_tvalid_latch_del : std_logic;

signal clock_splt : std_logic;
signal clock_splt_s2mm : std_logic;
signal updt_cmpt : std_logic;

signal cmpt_updt : std_logic_vector (1 downto 0);

signal reset1, reset2 : std_logic;

signal mm2s_cntrl_strm_stop : std_logic;

signal bd_eq : std_logic;

signal m_axi_sg_awaddr_internal : std_logic_vector (ADDR_WIDTH-1 downto 0)  ;
signal m_axi_sg_araddr_internal : std_logic_vector (ADDR_WIDTH-1 downto 0)  ;
signal m_axi_mm2s_araddr_internal : std_logic_vector (ADDR_WIDTH-1 downto 0)  ;
signal m_axi_s2mm_awaddr_internal : std_logic_vector (ADDR_WIDTH-1 downto 0)  ;

signal s2mm_axis_channel : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_axis_channel : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_axis_channel_reg : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_axis_channel_reg : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal sg_side_band : std_logic_vector (11 downto 0);
signal sg_side_band_valid : std_logic;

signal sg_side_band_s2mm_tuser : std_logic_vector (15 downto 0);
signal sg_side_band_tuser_valid : std_logic;
signal m_axis_s2mm_ftch_id : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal m_axis_mm2s_ftch_id : std_logic_vector (C_MAX_CHANNELS-1 downto 0);

signal s2mm_channel_id_reg_update : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_channel_id_reg_update : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal channel_enable_reg : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal channel_enable_mm2s : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_new_curdesc_wren_mngr : std_logic;
signal mm2s_new_curdesc_wren_mngr : std_logic;

signal s2mm_pkt_irq_set        : std_logic;
signal s2mm_pktirqthresh_status : std_logic_vector (7 downto 0);
signal s2mm_pktirqthresh_wren  : std_logic;


signal s2mm_pktdrp_count : std_logic_vector (31 downto 0);

signal tvalid_to_datamover : std_logic;
signal tready_from_datamover : std_logic;

signal s2mm_dbg_dm : std_logic_vector (31 downto 0);
signal sg_ftch_idle : std_logic_vector (C_MAX_CHANNELS-1 downto 0);

signal mm2s_ch_dmacr_rs: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_desc_flush: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_tailpntr_updated: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_cntrl_strm_stop: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_irqthresh_rstdsbl: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_dlyirq_dsble: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_irqdelay_wren: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_irqthresh_wren: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_packet_sof: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_packet_eof: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_ftch_idle: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_ftch_interr_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_ftch_slverr_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_ftch_decerr_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_ftch_err_early: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_ftch_stale_desc: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_updt_idle: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_updt_ioc_irq_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_updt_interr_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_updt_slverr_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_updt_decerr_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_dma_interr_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_dma_slverr_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_dma_decerr_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_ioc_irq_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_dly_irq_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);

signal mm2s_ch_irqdelay: std_logic_vector (8*C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_irqthresh: std_logic_vector (8*C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_irqdelay_status: std_logic_vector (8*C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_irqthresh_status: std_logic_vector (8*C_MAX_CHANNELS-1 downto 0);

signal mm2s_ch_taildesc: std_logic_vector (ADDR_WIDTH*C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_curdesc: std_logic_vector (ADDR_WIDTH*C_MAX_CHANNELS-1 downto 0);

signal s2mm_ch_dmacr_rs: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_desc_flush: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_tailpntr_updated: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_cntrl_strm_stop: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_irqthresh_rstdsbl: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_dlyirq_dsble: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_irqdelay_wren: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_irqthresh_wren: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_packet_sof: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_packet_eof: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_ftch_idle: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_ftch_interr_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_ftch_slverr_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_ftch_decerr_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_ftch_err_early: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_ftch_stale_desc: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_updt_idle: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_updt_ioc_irq_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_updt_interr_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_updt_slverr_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_updt_decerr_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_dma_interr_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_dma_slverr_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_dma_decerr_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_ioc_irq_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_dly_irq_set: std_logic_vector (C_MAX_CHANNELS-1 downto 0);

signal s2mm_ch_irqdelay: std_logic_vector (8*C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_irqthresh: std_logic_vector (8*C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_irqdelay_status: std_logic_vector (8*C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_irqthresh_status: std_logic_vector (8*C_MAX_CHANNELS-1 downto 0);

signal s2mm_ch_taildesc: std_logic_vector (ADDR_WIDTH*C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_curdesc: std_logic_vector (ADDR_WIDTH*C_MAX_CHANNELS-1 downto 0);

signal mm2s_ch_stop  : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_halted_clr: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_halted_set : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_idle_set   : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_idle_clr   : std_logic_vector (C_MAX_CHANNELS-1 downto 0);             

signal s2mm_ch_stop  : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_halted_clr: std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_halted_set : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_idle_set   : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_idle_clr   : std_logic_vector (C_MAX_CHANNELS-1 downto 0);             

signal mm2s_ch_new_curdesc_wren :std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_new_curdesc_wren :std_logic_vector (C_MAX_CHANNELS-1 downto 0);

signal mm2s_ch_dmacr : std_logic_vector (C_MAX_CHANNELS*32-1 downto 0);
signal mm2s_ch_dmasr : std_logic_vector (C_MAX_CHANNELS*32-1 downto 0);

signal s2mm_ch_dmacr : std_logic_vector (C_MAX_CHANNELS*32-1 downto 0);
signal s2mm_ch_dmasr : std_logic_vector (C_MAX_CHANNELS*32-1 downto 0);

signal s2mm_ch_pkt_irq_set         :std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_pktirqthresh_status    :std_logic_vector (C_MAX_CHANNELS*8-1 downto 0);
signal s2mm_ch_pktirqthresh_wren      :std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_pktdrp_count           :std_logic_vector (C_MAX_CHANNELS*16-1 downto 0);
signal s2mm_ch_pkdrp_rst           :std_logic_vector (C_MAX_CHANNELS-1 downto 0);      
signal s2mm_ch_introut : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_dmacr_pkt_thresh :std_logic_vector (C_MAX_CHANNELS*8-1 downto 0);

signal ch_s2mm_ftch_channel_id      : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal ch_s2mm_updt_channel_id      : std_logic_vector (C_MAX_CHANNELS-1 downto 0);

signal ch_mm2s_ftch_channel_id      : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal ch_mm2s_updt_channel_id      : std_logic_vector (C_MAX_CHANNELS-1 downto 0);


signal accept_sts : std_logic;
signal reject_sts : std_logic;

signal m_axi_s2mm_aclk_i : std_logic;
signal m_axi_mm2s_aclk_i : std_logic;

signal channel_mm2s_wt : std_logic_vector (31 downto 0);
signal channel_mm2s_wt2 : std_logic_vector (31 downto 0);
signal mm2s_schedule : std_logic_vector (31 downto 0);
signal mm2s_ftch_id : std_logic_vector (C_MAX_CHANNELS-1 downto 0);        

signal mm2s_ch_introut : std_logic_vector (C_MAX_CHANNELS-1 downto 0);

signal s2mm_ch_serviced : std_logic_vector (C_MAX_CHANNELS-1 downto 0);
signal mm2s_ch_serviced : std_logic_vector (C_MAX_CHANNELS-1 downto 0);

signal s_axis_buffer : std_logic_vector (C_S_AXIS_S2MM_TDATA_WIDTH + C_S_AXIS_S2MM_TDATA_WIDTH/8 + 4 + 8 + 16 +1-1 downto 0);
signal axis_buffer_out : std_logic_vector (C_S_AXIS_S2MM_TDATA_WIDTH + C_S_AXIS_S2MM_TDATA_WIDTH/8 + 4 + 8 + 16 +1-1 downto 0);
signal axis_buffer_full : std_logic;
signal axis_buffer_valid : std_logic;
signal axis_buffer_empty : std_logic;
signal axis_buffer_read : std_logic;
signal s_axis_s2mm_tdata_dm : std_logic_vector (C_S_AXIS_S2MM_TDATA_WIDTH-1 downto 0);
signal s_axis_s2mm_tkeep_dm : std_logic_vector (C_S_AXIS_S2MM_TDATA_WIDTH/8-1 downto 0);
signal s_axis_s2mm_tdest_dm : std_logic_vector (3 downto 0);
signal s_axis_s2mm_tid_dm   : std_logic_vector (7 downto 0);
signal s_axis_s2mm_tuser_dm : std_logic_vector (15 downto 0);
signal s_axis_s2mm_tlast_dm : std_logic;

signal fifo_rst, tlast_del : std_logic;
signal strb_bytes_set : std_logic_vector (7 downto 0);
signal byte_counter, cmd_btt : std_logic_vector (25 downto 0);
signal eof_detected : std_logic;
signal fetch_more : std_logic;
signal bd_fetch_trig : std_logic;

signal cmd_btt_int : std_logic_vector (25 downto 0);
signal cmd_btt_cdc_to : std_logic_vector (25 downto 0);
signal cmd_btt_s2mm : std_logic_vector (25 downto 0);
signal cmd_btt_s2mm_cumul : std_logic_vector (25 downto 0);
signal cmd_btt_cmp : std_logic_vector (25 downto 0);
signal btt_fifo_empty : std_logic;
signal cmd_received : std_logic;
signal cmd_received_s2mm : std_logic;
signal cmd_received_s2mm1 : std_logic;
signal cmd_received_s2mm2 : std_logic;
signal btt_rst : std_logic;
signal cmd_received_cdc3 : std_logic;
signal cmd_received_cdc2 : std_logic;
signal eof_detected_int : std_logic;
signal fetch_more_int : std_logic;
signal eof_detected_s2mm : std_logic;
signal eof_detected_s2mm_cdc3 : std_logic;
signal eof_detected_s2mm_cdc2 : std_logic;
signal fetch_more_s2mm : std_logic;
signal fetch_more_s2mm_cdc3 : std_logic;
signal fetch_more_s2mm_cdc2 : std_logic;
signal cmd_btt_valid : std_logic;
signal cmd_btt_valid_int : std_logic;

signal cmd_fifo_pop : std_logic;
signal calc_fifo_pop : std_logic;
signal cmd_btt_sg_valid : std_logic;
signal cmd_btt_calc_cmp : std_logic_vector (25 downto 0);
signal btt_calc_fifo_empty : std_logic;
signal mm2s_cache_sg : std_logic_vector (15 downto 0);
signal sg_cache_sg : std_logic_vector (31 downto 0);
signal s2mm_cache_sg : std_logic_vector (15 downto 0);
signal mm2s_cache_mm2s : std_logic_vector (15 downto 0);
signal s2mm_cache_s2mm : std_logic_vector (15 downto 0);

signal s_axis_s2mm_sts_buf  : std_logic_vector (36 downto 0);
signal s_axis_s2mm_sts_tdata_buf  : std_logic_vector (31 downto 0);
signal s_axis_s2mm_sts_tkeep_buf  : std_logic_vector (3 downto 0);
signal s_axis_s2mm_sts_tvalid_buf : std_logic;
signal s_axis_s2mm_sts_tready_buf : std_logic;
signal s_axis_s2mm_sts_tlast_buf  : std_logic;
signal sts_busy : std_logic;

signal mm2s_ch_pktcount : std_logic_vector (16*C_MAX_CHANNELS-1 downto 0);
signal s2mm_ch_pktcount : std_logic_vector (16*C_MAX_CHANNELS-1 downto 0);

-------------------------------------------------------------------------------
-- Begin architecture logic
-------------------------------------------------------------------------------
begin

LOGIC_LOW  <= '0';
LOGIC_HIGH <= '1';

m_axi_sg_arcache <= sg_cache_sg (3 downto 0);
m_axi_sg_aruser  <= sg_cache_sg (11 downto 8);
m_axi_sg_awcache <= sg_cache_sg (19 downto 16);
m_axi_sg_awuser  <= sg_cache_sg (27 downto 24);
btt_fifo_empty   <= '0';
--s2mm_axis_channel <= "00000001" when s_axis_s2mm_tvalid = '1' else "00000000"; -- should be based on tdest
--mm2s_axis_channel (0) <= '1';
--mm2s_axis_channel (C_MAX_CHANNELS-1 downto 1) <= (others => '0');

m_axi_mm2s_araddr <= m_axi_mm2s_araddr_internal (C_M_AXI_SG_ADDR_WIDTH-1 downto 0); 
m_axi_s2mm_awaddr <= m_axi_s2mm_awaddr_internal (C_M_AXI_SG_ADDR_WIDTH-1 downto 0); 

-- AXI DMA Test Vector (For Xilinx Internal Use Only)
axi_mcdma_tstvec(31 downto 6) <= (others => '0');
axi_mcdma_tstvec(5) <= s2mm_updt_ioc_irq_set;
axi_mcdma_tstvec(4) <= mm2s_updt_ioc_irq_set;
axi_mcdma_tstvec(3) <= tvalid_to_datamover and tready_from_datamover and s_axis_s2mm_tlast_dm;
axi_mcdma_tstvec(2) <= tvalid_to_datamover and tready_from_datamover; --s2mm_packet_sof;
axi_mcdma_tstvec(1) <= mm2s_packet_eof;
axi_mcdma_tstvec(0) <= mm2s_packet_sof;


axi_mcdma_tstvec_s2mm_eof (15 downto 0) <=  s2mm_ch_packet_eof;
axi_mcdma_tstvec_s2mm_sof (15 downto 0) <=  s2mm_ch_packet_sof;
axi_mcdma_tstvec_mm2s_eof (15 downto 0) <=  mm2s_ch_packet_eof;
axi_mcdma_tstvec_mm2s_sof (15 downto 0) <=  mm2s_ch_packet_sof;
axi_mcdma_tstvec_s2mm_ioc (15 downto 0) <=  s2mm_ch_serviced;
axi_mcdma_tstvec_mm2s_ioc (15 downto 0) <=  mm2s_ch_serviced;

-- Primary MM2S Stream outputs (used internally to gen eof and sof for
-- interrupt coalescing
m_axis_mm2s_tlast  <= m_axis_mm2s_tlast_i;
m_axis_mm2s_tvalid <= m_axis_mm2s_tvalid_i;
-- Primary S2MM Stream output (used internally to gen eof and sof for
-- interrupt coalescing
--s_axis_s2mm_tready <=     s_axis_s2mm_tready_i;

sg_ftch_idle <=  s2mm_ch_ftch_idle;

    axi_lite_aclk <= s_axi_lite_aclk;

GEN_ASYNC_IP : if C_PRMRY_IS_ACLK_ASYNC = 1 generate

    m_axi_s2mm_aclk_i <= m_axi_s2mm_aclk;
    m_axi_mm2s_aclk_i <= m_axi_mm2s_aclk;

    axi_sg_aclk   <= m_axi_sg_aclk;

MM2S_ENABLED: if C_INCLUDE_MM2S = 1 generate
begin

MM2S_CACHE_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 0,
        C_VECTOR_WIDTH             => 16,
        C_MTBF_STAGES              => 2 --MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => '0',
        prmry_vect_in              => mm2s_cache_sg,

        scndry_aclk                => m_axi_mm2s_aclk_i,
        scndry_resetn              => '0',
        scndry_out                 => open,
        scndry_vect_out            => mm2s_cache_mm2s
    );

m_axi_mm2s_arcache <= mm2s_cache_mm2s (3 downto 0);
m_axi_mm2s_aruser  <= mm2s_cache_mm2s (11 downto 8);

end generate MM2S_ENABLED;

S2MM_ENABLED: if C_INCLUDE_S2MM = 1 generate
begin

S2MM_CACHE_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 0,
        C_VECTOR_WIDTH             => 16,
        C_MTBF_STAGES              => 2 --MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => '0',
        prmry_vect_in              => s2mm_cache_sg,

        scndry_aclk                => m_axi_s2mm_aclk_i,
        scndry_resetn              => '0',
        scndry_out                 => open,
        scndry_vect_out            => s2mm_cache_s2mm
    );

m_axi_s2mm_awcache <= s2mm_cache_s2mm (3 downto 0);
m_axi_s2mm_awuser  <= s2mm_cache_s2mm (11 downto 8);

end generate S2MM_ENABLED;

end generate GEN_ASYNC_IP;


GEN_SYNC_IP : if C_PRMRY_IS_ACLK_ASYNC = 0 generate

    m_axi_s2mm_aclk_i <= s_axi_aclk;
    m_axi_mm2s_aclk_i <= s_axi_aclk;

--    axi_lite_aclk <= s_axi_aclk;
    axi_sg_aclk   <= s_axi_aclk;


m_axi_s2mm_awcache <= s2mm_cache_sg (3 downto 0);
m_axi_s2mm_awuser  <= s2mm_cache_sg (11 downto 8);

m_axi_mm2s_arcache <= mm2s_cache_sg (3 downto 0);
m_axi_mm2s_aruser  <= mm2s_cache_sg (11 downto 8);


end generate GEN_SYNC_IP;

--GEN_EXCLUDE_SG : if C_INCLUDE_SG = 0 generate
--    axi_lite_aclk <= s_axi_lite_aclk;
--    axi_sg_aclk   <= s_axi_lite_aclk;
--end generate GEN_EXCLUDE_SG;


-------------------------------------------------------------------------------
-- AXI DMA Reset Module
-------------------------------------------------------------------------------
I_RST_MODULE : entity  axi_mcdma_v1_1_8.axi_mcdma_rst_module
    generic map(
        C_INCLUDE_MM2S              => C_INCLUDE_MM2S                       ,
        C_INCLUDE_S2MM              => C_INCLUDE_S2MM                       ,
        C_PRMRY_IS_ACLK_ASYNC       => 1, --C_PRMRY_IS_ACLK_ASYNC                ,
        C_M_AXI_MM2S_ACLK_FREQ_HZ   => C_M_AXI_MM2S_ACLK_FREQ_HZ            ,
        C_M_AXI_S2MM_ACLK_FREQ_HZ   => C_M_AXI_S2MM_ACLK_FREQ_HZ            ,
        C_M_AXI_SG_ACLK_FREQ_HZ     => M_AXI_SG_ACLK_FREQ_HZ                ,
        C_SG_INCLUDE_STSCNTRL_STRM  => STSCNTRL_ENABLE           ,
        C_INCLUDE_SG                => C_INCLUDE_SG
    )
    port map(
        -- Clock Sources
        s_axi_lite_aclk             => axi_lite_aclk                        ,
        m_axi_sg_aclk               => axi_sg_aclk                          ,
        m_axi_mm2s_aclk             => m_axi_mm2s_aclk_i                      ,
        m_axi_s2mm_aclk             => m_axi_s2mm_aclk_i                      ,

        -----------------------------------------------------------------------
        -- Hard Reset
        -----------------------------------------------------------------------
        axi_resetn                  => axi_resetn                           ,

        -----------------------------------------------------------------------
        -- Soft Reset
        -----------------------------------------------------------------------
        soft_reset                  => soft_reset                           ,
        soft_reset_clr              => soft_reset_clr                       ,

        mm2s_stop                   => mm2s_stop                            ,
        mm2s_all_idle               => mm2s_all_idle                        ,
        mm2s_halt                   => mm2s_halt                            ,
        mm2s_halt_cmplt             => mm2s_halt_cmplt                      ,

        s2mm_stop                   => s2mm_stop                            ,
        s2mm_all_idle               => s2mm_all_idle                        ,
        s2mm_halt                   => s2mm_halt                            ,
        s2mm_halt_cmplt             => s2mm_halt_cmplt                      ,

        -----------------------------------------------------------------------
        -- MM2S Distributed Reset Out (m_axi_mm2s_aclk)
        -----------------------------------------------------------------------
        dm_mm2s_prmry_resetn        => m_axi_mm2s_aresetn                   ,   -- AXI DataMover Primary Reset (Raw)
        dm_mm2s_scndry_resetn       => dm_mm2s_scndry_resetn                ,   -- AXI DataMover Secondary Reset (Raw)
        mm2s_prmry_reset_out_n      => mm2s_prmry_reset_out_n               ,   -- AXI Stream Primary Reset Outputs
        mm2s_cntrl_reset_out_n      => mm2s_cntrl_reset_out_n               ,   -- AXI Stream Control Reset Outputs
        mm2s_scndry_resetn          => mm2s_scndry_resetn                   ,   -- AXI Secondary Reset
        mm2s_prmry_resetn           => mm2s_prmry_resetn                    ,   -- AXI Primary Reset

        -----------------------------------------------------------------------
        -- S2MM Distributed Reset Out (m_axi_s2mm_aclk_i)
        -----------------------------------------------------------------------
        dm_s2mm_prmry_resetn        => m_axi_s2mm_aresetn                   ,   -- AXI DataMover Primary Reset (Raw)
        dm_s2mm_scndry_resetn       => dm_s2mm_scndry_resetn                ,   -- AXI DataMover Secondary Reset (Raw)
        s2mm_prmry_reset_out_n      => s2mm_prmry_reset_out_n               ,   -- AXI Stream Primary Reset Outputs
        s2mm_sts_reset_out_n        => s2mm_sts_reset_out_n                 ,   -- AXI Stream Control Reset Outputs
        s2mm_scndry_resetn          => s2mm_scndry_resetn                   ,   -- AXI Secondary Reset
        s2mm_prmry_resetn           => s2mm_prmry_resetn                    ,   -- AXI Primary Reset


        -----------------------------------------------------------------------
        -- Scatter Gather Distributed Reset Out (m_axi_sg_aclk)
        -----------------------------------------------------------------------
        m_axi_sg_aresetn            => m_axi_sg_aresetn                     ,   -- AXI Scatter Gather Reset Out
        dm_m_axi_sg_aresetn         => dm_m_axi_sg_aresetn                  ,   -- AXI Scatter Gather Datamover Reset Out

        -----------------------------------------------------------------------
        -- Hard Reset Out (s_axi_lite_aclk)
        -----------------------------------------------------------------------
        m_axi_sg_hrdresetn          => m_axi_sg_hrdresetn                   ,   -- AXI Lite Ingerface (sg aclk) (Hard Only)
        s_axi_lite_resetn           => axi_lite_reset_n                         -- AXI Lite Interface reset (Hard Only)
    );

-------------------------------------------------------------------------------
-- AXI DMA Register Module
-------------------------------------------------------------------------------

I_AXI_DMA_REG_MODULE : entity axi_mcdma_v1_1_8.axi_mcdma_reg_module
    generic map(
        C_INCLUDE_MM2S              => C_INCLUDE_MM2S                       ,
        C_INCLUDE_S2MM              => C_INCLUDE_S2MM                       ,
        C_INCLUDE_SG                => C_INCLUDE_SG                         ,
        C_ENABLE_SINGLE_INTR        => C_ENABLE_SINGLE_INTR     ,
        C_MAX_CHANNELS             =>  C_MAX_CHANNELS           ,
      --  C_SG_LENGTH_WIDTH           => C_SG_LENGTH_WIDTH_INT                ,
        C_AXI_LITE_IS_ASYNC         => 1, --C_PRMRY_IS_ACLK_ASYNC                ,
        C_S_AXI_LITE_ADDR_WIDTH     => C_S_AXI_LITE_ADDR_WIDTH              ,
        C_S_AXI_LITE_DATA_WIDTH     => C_S_AXI_LITE_DATA_WIDTH              ,
        C_M_AXI_SG_ADDR_WIDTH       => ADDR_WIDTH                ,
        C_M_AXI_MM2S_ADDR_WIDTH     => ADDR_WIDTH              ,
        C_ACTUAL_ADDR_WIDTH         => C_M_AXI_SG_ADDR_WIDTH   ,
        C_NUM_S2MM_CHANNELS         => C_NUM_S2MM_CHANNELS                  ,
        C_NUM_MM2S_CHANNELS         => C_NUM_MM2S_CHANNELS                  ,
        C_M_AXI_S2MM_ADDR_WIDTH     => ADDR_WIDTH              ,
        C_MM2S_SCHEDULE             => C_MM2S_SCHEDULER         ,  
        C_GROUP1_MM2S               => MM2S_GP1, --C_GROUP1_MM2S,
        C_GROUP2_MM2S               => MM2S_GP2,--C_GROUP2_MM2S,
        C_GROUP3_MM2S               => MM2S_GP3,--C_GROUP3_MM2S,
        C_GROUP4_MM2S               => MM2S_GP4,--C_GROUP4_MM2S,
        C_GROUP5_MM2S               => MM2S_GP5,--C_GROUP5_MM2S,
        C_GROUP6_MM2S               => MM2S_GP6,--C_GROUP6_MM2S,
        C_GROUP1_S2MM               => S2MM_GP1,--C_GROUP1_S2MM,
        C_GROUP2_S2MM               => S2MM_GP2,--C_GROUP2_S2MM,
        C_GROUP3_S2MM               => S2MM_GP3,--C_GROUP3_S2MM,
        C_GROUP4_S2MM               => S2MM_GP4,--C_GROUP4_S2MM,
        C_GROUP5_S2MM               => S2MM_GP5,--C_GROUP5_S2MM,
        C_GROUP6_S2MM               => S2MM_GP6 --C_GROUP6_S2MM
    )
    port map(
        -----------------------------------------------------------------------
        -- AXI Lite Control Interface
        -----------------------------------------------------------------------
        s_axi_lite_aclk             => axi_lite_aclk                        ,
        axi_lite_reset_n            => axi_lite_reset_n                     ,

        m_axi_sg_aclk               => axi_sg_aclk                          ,
        m_axi_sg_aresetn            => m_axi_sg_aresetn                     ,
        m_axi_sg_hrdresetn          => m_axi_sg_hrdresetn                   ,

        -- AXI Lite Write Address Channel
        s_axi_lite_awvalid          => s_axi_lite_awvalid                   ,
        s_axi_lite_awready          => s_axi_lite_awready                   ,
        s_axi_lite_awaddr           => s_axi_lite_awaddr                    ,

        -- AXI Lite Write Data Channel
        s_axi_lite_wvalid           => s_axi_lite_wvalid                    ,
        s_axi_lite_wready           => s_axi_lite_wready                    ,
        s_axi_lite_wdata            => s_axi_lite_wdata                     ,

        -- AXI Lite Write Response Channel
        s_axi_lite_bresp            => s_axi_lite_bresp                     ,
        s_axi_lite_bvalid           => s_axi_lite_bvalid                    ,
        s_axi_lite_bready           => s_axi_lite_bready                    ,

        -- AXI Lite Read Address Channel
        s_axi_lite_arvalid          => s_axi_lite_arvalid                   ,
        s_axi_lite_arready          => s_axi_lite_arready                   ,
        s_axi_lite_araddr           => s_axi_lite_araddr                    ,
        s_axi_lite_rvalid           => s_axi_lite_rvalid                    ,
        s_axi_lite_rready           => s_axi_lite_rready                    ,
        s_axi_lite_rdata            => s_axi_lite_rdata                     ,
        s_axi_lite_rresp            => s_axi_lite_rresp                     ,
        sg_user_cache               => sg_cache_sg,

        -- MM2S DMASR Status
        mm2s_stop                   => mm2s_stop                            ,
        mm2s_halted_clr             => mm2s_halted_clr                      ,
        mm2s_halted_set             => mm2s_halted_set                      ,
        mm2s_idle_set               => mm2s_idle_set                        ,
        mm2s_idle_clr               => mm2s_idle_clr                        ,
        mm2s_dma_interr_set         => mm2s_dma_interr_set                  ,
        mm2s_dma_slverr_set         => mm2s_dma_slverr_set                  ,
        mm2s_dma_decerr_set         => mm2s_dma_decerr_set                  ,
        mm2s_ioc_irq_set            => mm2s_ioc_irq_set                     ,
        mm2s_dly_irq_set            => mm2s_dly_irq_set                     ,
        mm2s_ch_sg_idle                => mm2s_ch_ftch_idle                       ,
        mm2s_irqthresh_wren         => mm2s_irqthresh_wren                  ,
        mm2s_irqdelay_wren          => mm2s_irqdelay_wren                   ,
        mm2s_irqthresh_rstdsbl      => mm2s_irqthresh_rstdsbl               , -- CR572013
        mm2s_irqdelay_status        => mm2s_irqdelay_status                 ,
        mm2s_irqthresh_status       => mm2s_irqthresh_status                ,
        mm2s_dlyirq_dsble           => mm2s_dlyirq_dsble                    , -- CR605888
        mm2s_ftch_interr_set        => mm2s_ftch_interr_set                 ,
        mm2s_ftch_slverr_set        => mm2s_ftch_slverr_set                 ,
        mm2s_ftch_decerr_set        => mm2s_ftch_decerr_set                 ,
        mm2s_updt_interr_set        => mm2s_updt_interr_set                 ,
        mm2s_updt_slverr_set        => mm2s_updt_slverr_set                 ,
        mm2s_updt_decerr_set        => mm2s_updt_decerr_set                 ,

        -- MM2S TAILDESC Update
        mm2s_tailpntr_updated       => mm2s_tailpntr_updated                ,

        -- MM2S Registers
        mm2s_dmacr                  => mm2s_dmacr                           ,
        mm2s_dmasr                  => mm2s_dmasr                           ,

        -- MM2S 2_ DMASR Status
        mm2s_ch_stop                   => mm2s_ch_stop                            ,
        mm2s_ch_halted_clr             => mm2s_ch_halted_clr                      ,
        mm2s_ch_halted_set             => mm2s_ch_halted_set                      ,
        mm2s_ch_idle_set               => mm2s_ch_idle_set                        ,
        mm2s_ch_idle_clr               => mm2s_ch_idle_clr                        ,
        mm2s_ch_dma_interr_set         => mm2s_ch_dma_interr_set                  ,
        mm2s_ch_dma_slverr_set         => mm2s_ch_dma_slverr_set                  ,
        mm2s_ch_dma_decerr_set         => mm2s_ch_dma_decerr_set                  ,
        mm2s_ch_ioc_irq_set            => mm2s_ch_ioc_irq_set                     ,
        mm2s_ch_dly_irq_set            => mm2s_ch_dly_irq_set                     ,
        mm2s_ch_irqthresh_wren         => mm2s_ch_irqthresh_wren                  ,
        mm2s_ch_irqdelay_wren          => mm2s_ch_irqdelay_wren                   ,
        mm2s_ch_irqthresh_rstdsbl      => mm2s_ch_irqthresh_rstdsbl               , -- CR572013
        mm2s_ch_irqdelay_status        => mm2s_ch_irqdelay_status                 ,
        mm2s_ch_irqthresh_status       => mm2s_ch_irqthresh_status                ,
        mm2s_ch_pktcount               => mm2s_ch_pktcount,
        mm2s_ch_dlyirq_dsble           => mm2s_ch_dlyirq_dsble                    , -- CR605888
        mm2s_ch_ftch_interr_set        => mm2s_ch_ftch_interr_set                 ,
        mm2s_ch_ftch_slverr_set        => mm2s_ch_ftch_slverr_set                 ,
        mm2s_ch_ftch_decerr_set        => mm2s_ch_ftch_decerr_set                 ,
        mm2s_ch_updt_interr_set        => mm2s_ch_updt_interr_set                 ,
        mm2s_ch_updt_slverr_set        => mm2s_ch_updt_slverr_set                 ,
        mm2s_ch_updt_decerr_set        => mm2s_ch_updt_decerr_set                 ,

        -- MM2S2_ CURDESC Update
        mm2s_ch_new_curdesc_wren       => mm2s_ch_new_curdesc_wren                ,
        mm2s_ch_new_curdesc            => mm2s_new_curdesc                     ,

        -- MM2S2_ TAILDESC Update
        mm2s_ch_tailpntr_updated       => mm2s_ch_tailpntr_updated                ,

        -- MM2S2_ Registers
        mm2s_ch_dmacr                  => mm2s_ch_dmacr                           ,
        mm2s_ch_dmasr                  => mm2s_ch_dmasr                           ,
        mm2s_ch_curdesc                => mm2s_ch_curdesc                         ,
        mm2s_ch_taildesc               => mm2s_ch_taildesc                        ,
        mm2s_channel_enable            => channel_enable_mm2s,
        mm2s_ch_serviced               => mm2s_ch_serviced                 ,
        mm2s_channel_id                => mm2s_axis_channel, --_reg, 
        mm2s_schedule                  => mm2s_schedule, 
        mm2s_ch_weight                 => channel_mm2s_wt,
        mm2s_ch_weight_2               => channel_mm2s_wt2,
        mm2s_user_cache                => mm2s_cache_sg,



        -- S2MM DMASR Status
        s2mm_channel_id             => s2mm_axis_channel_reg, 
        s2mm_channel_id_run         => s2mm_axis_channel, 
        pktdrp_count_in             => s2mm_pktdrp_count                    , 
        s2mm_channel_enable         => channel_enable_reg                   ,
        s2mm_ch_serviced            => s2mm_ch_serviced                 ,

        s2mm_stop                   => s2mm_stop                            ,
        s2mm_halted_clr             => s2mm_halted_clr                      ,
        s2mm_halted_set             => s2mm_halted_set                      ,
        s2mm_idle_set               => s2mm_idle_set                        ,
        s2mm_idle_clr               => s2mm_idle_clr                        ,
        s2mm_dma_interr_set         => s2mm_dma_interr_set                  ,
        s2mm_dma_slverr_set         => s2mm_dma_slverr_set                  ,
        s2mm_dma_decerr_set         => s2mm_dma_decerr_set                  ,
        s2mm_ioc_irq_set            => s2mm_ioc_irq_set                     ,
        s2mm_dly_irq_set            => s2mm_dly_irq_set                     ,
        s2mm_sg_idle                => s2mm_ftch_idle                       ,
        s2mm_irqthresh_wren         => s2mm_irqthresh_wren                  ,
        s2mm_irqdelay_wren          => s2mm_irqdelay_wren                   ,
        s2mm_irqthresh_rstdsbl      => s2mm_irqthresh_rstdsbl               , -- CR572013
        s2mm_irqdelay_status        => s2mm_irqdelay_status                 ,
        s2mm_irqthresh_status       => s2mm_irqthresh_status                ,
        s2mm_pktdrp_irq_set         => s2mm_pkt_irq_set                     ,
        s2mm_pktirqthresh_status    => s2mm_pktirqthresh_status             ,
        s2mm_pktirqthresh_wren      => s2mm_pktirqthresh_wren               ,
        s2mm_dlyirq_dsble           => s2mm_dlyirq_dsble                    , -- CR605888
        s2mm_ftch_interr_set        => s2mm_ftch_interr_set                 ,
        s2mm_ftch_slverr_set        => s2mm_ftch_slverr_set                 ,
        s2mm_ftch_decerr_set        => s2mm_ftch_decerr_set                 ,
        s2mm_updt_interr_set        => s2mm_updt_interr_set                 ,
        s2mm_updt_slverr_set        => s2mm_updt_slverr_set                 ,
        s2mm_updt_decerr_set        => s2mm_updt_decerr_set                 ,

        -- S2egisters
        s2mm_dmacr                  => s2mm_dmacr                           ,
        s2mm_dmasr                  => s2mm_dmasr                           ,

        -- S2MM Channels
        s2mm_ch_stop                   => s2mm_ch_stop                            ,
        s2mm_ch_halted_clr             => s2mm_ch_halted_clr                      ,
        s2mm_ch_halted_set             => s2mm_ch_halted_set                      ,
        s2mm_ch_idle_set               => s2mm_ch_idle_set                        ,
        s2mm_ch_idle_clr               => s2mm_ch_idle_clr                        ,
        s2mm_ch_dma_interr_set         => s2mm_ch_dma_interr_set                  ,
        s2mm_ch_dma_slverr_set         => s2mm_ch_dma_slverr_set                  ,
        s2mm_ch_dma_decerr_set         => s2mm_ch_dma_decerr_set                  ,
        s2mm_ch_ioc_irq_set            => s2mm_ch_ioc_irq_set                     ,
        s2mm_ch_dly_irq_set            => s2mm_ch_dly_irq_set                     ,
        s2mm_ch_sg_idle                => s2mm_ch_ftch_idle                       ,
        s2mm_ch_irqthresh_wren         => s2mm_ch_irqthresh_wren                  ,
        s2mm_ch_irqdelay_wren          => s2mm_ch_irqdelay_wren                   ,
        s2mm_ch_irqthresh_rstdsbl      => s2mm_ch_irqthresh_rstdsbl               , -- CR572013
        s2mm_ch_irqdelay_status        => s2mm_ch_irqdelay_status                 ,
        s2mm_ch_irqthresh_status       => s2mm_ch_irqthresh_status                ,
        s2mm_ch_pktdrp_irq_set         => s2mm_ch_pkt_irq_set                     ,
        s2mm_ch_pktirqthresh_status    => s2mm_ch_pktirqthresh_status             ,
        s2mm_ch_pktcount               => s2mm_ch_pktcount,
        s2mm_ch_pktirqthresh_wren      => s2mm_ch_pktirqthresh_wren               ,
        s2mm_ch_pktdrp_count           => s2mm_ch_pktdrp_count                    ,
        s2mm_ch_pktdrp_reset           => s2mm_ch_pkdrp_rst                       , 
        s2mm_ch_dlyirq_dsble           => s2mm_ch_dlyirq_dsble                    , -- CR605888
        s2mm_ch_ftch_interr_set        => s2mm_ch_ftch_interr_set                 ,
        s2mm_ch_ftch_slverr_set        => s2mm_ch_ftch_slverr_set                 ,
        s2mm_ch_ftch_decerr_set        => s2mm_ch_ftch_decerr_set                 ,
        s2mm_ch_updt_interr_set        => s2mm_ch_updt_interr_set                 ,
        s2mm_ch_updt_slverr_set        => s2mm_ch_updt_slverr_set                 ,
        s2mm_ch_updt_decerr_set        => s2mm_ch_updt_decerr_set                 ,

        -- S2MMCURDESC Update
        s2mm_ch_new_curdesc_wren       => s2mm_ch_new_curdesc_wren                ,
        s2mm_ch_new_curdesc            => s2mm_new_curdesc                     ,

        -- S2MMTAILDESC Update
        s2mm_ch_tailpntr_updated       => s2mm_ch_tailpntr_updated                ,

        -- S2MMRegisters
        s2mm_ch_dmacr                  => s2mm_ch_dmacr                           ,
        s2mm_ch_dmasr                  => s2mm_ch_dmasr                           ,
        s2mm_ch_curdesc                => s2mm_ch_curdesc                         ,
        s2mm_ch_taildesc               => s2mm_ch_taildesc                        ,
        s2mm_user_cache                => s2mm_cache_sg,

        -- Soft reset and clear
        soft_reset                  => soft_reset                           ,
        soft_reset_clr              => soft_reset_clr                       ,

        -- Fetch/Update error addresses
        ftch_error_addr             => ftch_error_addr                      ,
        updt_error_addr             => updt_error_addr                      ,
        ch_s2mm_ftch_channel_id     => ch_s2mm_ftch_channel_id          ,
        ch_s2mm_updt_channel_id     => ch_s2mm_updt_channel_id          ,
        ch_mm2s_ftch_channel_id     => ch_mm2s_ftch_channel_id          ,
        ch_mm2s_updt_channel_id     => ch_mm2s_updt_channel_id          ,

        -- DMA Interrupt Outputs
        mm2s_introut                => mm2s_introut                         ,
        mm2s_ch_introut                => mm2s_ch_introut                         ,
        s2mm_introut                    => s2mm_introut ,
        s2mm_ch_introut                => s2mm_ch_introut 
    );

mm2s_ch1_introut  <= mm2s_ch_introut (0);
mm2s_ch2_introut  <= mm2s_ch_introut (1);
mm2s_ch3_introut  <= mm2s_ch_introut (2);
mm2s_ch4_introut  <= mm2s_ch_introut (3);
mm2s_ch5_introut  <= mm2s_ch_introut (4);
mm2s_ch6_introut  <= mm2s_ch_introut (5);
mm2s_ch7_introut  <= mm2s_ch_introut (6);
mm2s_ch8_introut  <= mm2s_ch_introut (7);
mm2s_ch9_introut  <= mm2s_ch_introut (8);
mm2s_ch10_introut <= mm2s_ch_introut (9);
mm2s_ch11_introut <= mm2s_ch_introut (10);
mm2s_ch12_introut <= mm2s_ch_introut (11);
mm2s_ch13_introut <= mm2s_ch_introut (12);
mm2s_ch14_introut <= mm2s_ch_introut (13);
mm2s_ch15_introut <= mm2s_ch_introut (14);
mm2s_ch16_introut <= mm2s_ch_introut (15);

s2mm_ch1_introut <= s2mm_ch_introut (0);
s2mm_ch2_introut <= s2mm_ch_introut (1);
s2mm_ch3_introut <= s2mm_ch_introut (2);
s2mm_ch4_introut <= s2mm_ch_introut (3);
s2mm_ch5_introut <= s2mm_ch_introut (4);
s2mm_ch6_introut <= s2mm_ch_introut (5);
s2mm_ch7_introut <= s2mm_ch_introut (6);
s2mm_ch8_introut <= s2mm_ch_introut (7);
s2mm_ch9_introut <= s2mm_ch_introut (8);
s2mm_ch10_introut <= s2mm_ch_introut (9);
s2mm_ch11_introut <= s2mm_ch_introut (10);
s2mm_ch12_introut <= s2mm_ch_introut (11);
s2mm_ch13_introut <= s2mm_ch_introut (12);
s2mm_ch14_introut <= s2mm_ch_introut (13);
s2mm_ch15_introut <= s2mm_ch_introut (14);
s2mm_ch16_introut <= s2mm_ch_introut (15);


CHANNEL_INTR_GEN: for I in 0 to C_MAX_CHANNELS-1 generate
begin

s2mm_ch_irqthresh(8+8*I-1 downto 8*I) <=s2mm_ch_dmacr(32*I+23 downto 16+32*I);  
s2mm_ch_irqdelay(8+8*I-1 downto 8*I) <=s2mm_ch_dmacr(32*I+31 downto 24+32*I);  

mm2s_ch_irqthresh(8+8*I-1 downto 8*I) <=mm2s_ch_dmacr(32*I+23 downto 16+32*I);  
mm2s_ch_irqdelay(8+8*I-1 downto 8*I) <=mm2s_ch_dmacr(32*I+31 downto 24+32*I);  

end generate CHANNEL_INTR_GEN;

GEN_NOSG_ENGINE : if C_INCLUDE_SG = 0 generate
begin
mm2s_dma_interr_set  <= '0';
mm2s_dma_slverr_set  <= '0';
mm2s_dma_decerr_set  <= '0';
mm2s_ftch_interr_set <= '0';
mm2s_ftch_slverr_set <= '0';
mm2s_ftch_decerr_set <= '0';
mm2s_updt_interr_set <= '0';
mm2s_updt_slverr_set <= '0';
mm2s_updt_decerr_set <= '0';
mm2s_ch_ftch_idle       <= (others => '0');
mm2s_ch_dma_interr_set  <= (others => '0');
mm2s_ch_dma_slverr_set  <= (others => '0');
mm2s_ch_dma_decerr_set  <= (others => '0');
mm2s_ch_ftch_interr_set <= (others => '0');
mm2s_ch_ftch_slverr_set <= (others => '0');
mm2s_ch_ftch_decerr_set <= (others => '0');
mm2s_ch_updt_interr_set <= (others => '0');
mm2s_ch_updt_slverr_set <= (others => '0');
mm2s_ch_updt_decerr_set <= (others => '0');
mm2s_ch_serviced        <= (others => '0');
--mm2s_axis_channel       <= (others => '0');
s2mm_ch_serviced        <= (others => '0');
s2mm_dma_interr_set  <= '0';
s2mm_dma_slverr_set  <= '0';
s2mm_dma_decerr_set  <= '0';
s2mm_ftch_interr_set <= '0';
s2mm_ftch_slverr_set <= '0';
s2mm_ftch_decerr_set <= '0';
s2mm_updt_interr_set <= '0';
s2mm_updt_slverr_set <= '0';
s2mm_updt_decerr_set <= '0';
s2mm_ch_dma_interr_set  <= (others => '0');
s2mm_ch_dma_slverr_set  <= (others => '0');
s2mm_ch_dma_decerr_set  <= (others => '0');
s2mm_ch_ftch_interr_set <= (others => '0');
s2mm_ch_ftch_slverr_set <= (others => '0');
s2mm_ch_ftch_decerr_set <= (others => '0');
s2mm_ch_updt_interr_set <= (others => '0');
s2mm_ch_updt_slverr_set <= (others => '0');
s2mm_ch_updt_decerr_set <= (others => '0');
s2mm_ch_ioc_irq_set	<= (others => '0');
s2mm_ch_dly_irq_set	<= (others => '0');
mm2s_ch_ioc_irq_set	<= (others => '0');
mm2s_ch_dly_irq_set	<= (others => '0');
s2mm_ch_ftch_idle	<= (others => '0');
ch_s2mm_ftch_channel_id <= (others => '0');
ch_s2mm_updt_channel_id <= (others => '0');
ch_mm2s_ftch_channel_id <= (others => '0');
ch_mm2s_updt_channel_id <= (others => '0');
mm2s_ftch_idle 		<= '0';
mm2s_updt_idle 		<= '0';
mm2s_ftch_err_early     <= '0';
mm2s_ftch_stale_desc    <= '0';
s2mm_ftch_idle 		<= '0';
s2mm_updt_idle 		<= '0';
s2mm_ftch_err_early     <= '0';
s2mm_ftch_stale_desc    <= '0';
updt_error		<= '0';
ftch_error		<= '0';

end generate GEN_NOSG_ENGINE;
-------------------------------------------------------------------------------
-- Scatter Gather Mode (C_INCLUDE_SG = 1)
-------------------------------------------------------------------------------
GEN_SG_ENGINE : if C_INCLUDE_SG = 1 generate
begin
--    reset1 <= dm_m_axi_sg_aresetn and s2mm_tvalid_latch;
--    reset2 <= m_axi_sg_aresetn and s2mm_tvalid_latch;

S2MM_ENABLED: if C_INCLUDE_S2MM = 1 generate
begin

CHANNEL_GEN : for I in 0 to C_NUM_S2MM_CHANNELS-1 generate
begin

s2mm_ch_dmacr_rs(I) <= s2mm_ch_dmacr (CHDMACR_START_STOP_BIT+32*I);

end generate CHANNEL_GEN;

UNUSED_CHANNELS : if C_MAX_CHANNELS > C_NUM_S2MM_CHANNELS generate
begin

CHANNEL_GEN : for I in C_NUM_S2MM_CHANNELS to C_MAX_CHANNELS-1 generate
begin

s2mm_ch_dmacr_rs(I) <= s2mm_ch_dmacr (CHDMACR_START_STOP_BIT+32*I);
end generate CHANNEL_GEN;

end generate UNUSED_CHANNELS;

end generate S2MM_ENABLED;


MM2S_ENABLED: if C_INCLUDE_MM2S = 1 generate
begin

CHANNEL_GEN : for I in 0 to C_NUM_MM2S_CHANNELS-1 generate
begin

mm2s_ch_dmacr_rs(I) <= mm2s_ch_dmacr (CHDMACR_START_STOP_BIT+32*I);

end generate CHANNEL_GEN;

UNUSED_CHANNELS : if C_MAX_CHANNELS > C_NUM_MM2S_CHANNELS generate
begin

CHANNEL_GEN : for I in C_NUM_MM2S_CHANNELS to C_MAX_CHANNELS-1 generate
begin

mm2s_ch_dmacr_rs(I) <= mm2s_ch_dmacr (CHDMACR_START_STOP_BIT+32*I);
end generate CHANNEL_GEN;

end generate UNUSED_CHANNELS;

end generate MM2S_ENABLED;

s2mm_ch_desc_flush <= (others => s2mm_desc_flush);
mm2s_ch_desc_flush <= (others => mm2s_desc_flush);
sg_ctl		   <= (others => '0');

    -- Scatter Gather Engine
    I_SG_ENGINE : entity  axi_msg_v1_0_8.axi_msg
        generic map(
            C_M_AXI_SG_ADDR_WIDTH       => ADDR_WIDTH            ,
            C_M_AXI_SG_DATA_WIDTH       => C_M_AXI_SG_DATA_WIDTH            ,
            C_M_AXIS_SG_TDATA_WIDTH     => M_AXIS_SG_TDATA_WIDTH            ,
            C_S_AXIS_UPDPTR_TDATA_WIDTH => 32                               ,
            C_S_AXIS_UPDSTS_TDATA_WIDTH => S_AXIS_UPDSTS_TDATA_WIDTH        ,
            C_SG_FTCH_DESC2QUEUE        => SG_FTCH_DESC2QUEUE               ,
            C_SG_UPDT_DESC2QUEUE        => SG_UPDT_DESC2QUEUE               ,
            C_SG_CH1_WORDS_TO_FETCH     => SG_CH1_WORDS_TO_FETCH            ,
            C_SG_CH1_WORDS_TO_UPDATE    => SG_CH1_WORDS_TO_UPDATE           ,
            C_SG_CH1_FIRST_UPDATE_WORD  => SG_CH1_FIRST_UPDATE_WORD         ,
            C_SG_CH1_ENBL_STALE_ERROR   => SG_CH1_ENBL_STALE_ERROR          ,
            C_SG_CH2_WORDS_TO_FETCH     => SG_CH2_WORDS_TO_FETCH            ,
            C_SG_CH2_WORDS_TO_UPDATE    => SG_CH2_WORDS_TO_UPDATE           ,
            C_SG_CH2_FIRST_UPDATE_WORD  => SG_CH2_FIRST_UPDATE_WORD         ,
            C_SG_CH2_ENBL_STALE_ERROR   => SG_CH2_ENBL_STALE_ERROR          ,
            C_AXIS_IS_ASYNC             => SG_IS_SYNCHRONOUS                ,
            C_ASYNC                     => C_PRMRY_IS_ACLK_ASYNC                ,
            C_INCLUDE_CH1               => C_INCLUDE_MM2S                   ,
            C_INCLUDE_CH2               => C_INCLUDE_S2MM                   ,
            C_INCLUDE_DESC_UPDATE       => INCLUDE_DESC_UPDATE              ,
            C_INCLUDE_INTRPT            => INCLUDE_INTRPT                   ,
            C_ENABLE_SINGLE_INTR        => C_ENABLE_SINGLE_INTR     ,
            C_INCLUDE_DLYTMR            => INCLUDE_DLYTMR                   ,
            C_DLYTMR_RESOLUTION         => C_DLYTMR_RESOLUTION              ,
            C_ENABLE_MULTI_CHANNEL      => 0 ,--C_ENABLE_MULTI_CHANNEL                  ,
            C_ENABLE_EXTRA_FIELD        => STSCNTRL_ENABLE ,
            C_NUM_S2MM_CHANNELS         => C_NUM_S2MM_CHANNELS              ,
            C_NUM_MM2S_CHANNELS         => C_NUM_MM2S_CHANNELS              ,
            C_ACTUAL_ADDR               => C_M_AXI_SG_ADDR_WIDTH            ,            
            C_MAX_CHANNELS              => C_MAX_CHANNELS                   ,
            C_FAMILY                    => C_FAMILY
        )
        port map(
            -----------------------------------------------------------------------
            -- AXI Scatter Gather Interface
            -----------------------------------------------------------------------
            m_axi_msg_aclk               => axi_sg_aclk                      ,
            m_axi_mm2s_aclk             => m_axi_mm2s_aclk_i                  ,
            m_axi_msg_aresetn            => m_axi_sg_aresetn                 ,
            dm_resetn                   => dm_m_axi_sg_aresetn              ,
            p_reset_n                   => mm2s_prmry_resetn                    ,

            -- Scatter Gather Write Address Channel
            m_axi_msg_awaddr             => m_axi_sg_awaddr_internal                  ,
            m_axi_msg_awlen              => m_axi_sg_awlen                   ,
            m_axi_msg_awsize             => m_axi_sg_awsize                  ,
            m_axi_msg_awburst            => m_axi_sg_awburst                 ,
            m_axi_msg_awprot             => m_axi_sg_awprot                  ,
            m_axi_msg_awcache            => open, --m_axi_sg_awcache                 ,
            m_axi_msg_awuser             => open, --m_axi_sg_awuser                  ,
            m_axi_msg_awvalid            => m_axi_sg_awvalid                 ,
            m_axi_msg_awready            => m_axi_sg_awready                 ,

            -- Scatter Gather Write Data Channel
            m_axi_msg_wdata              => m_axi_sg_wdata                   ,
            m_axi_msg_wstrb              => m_axi_sg_wstrb                   ,
            m_axi_msg_wlast              => m_axi_sg_wlast                   ,
            m_axi_msg_wvalid             => m_axi_sg_wvalid                  ,
            m_axi_msg_wready             => m_axi_sg_wready                  ,

            -- Scatter Gather Write Response Channel
            m_axi_msg_bresp              => m_axi_sg_bresp                   ,
            m_axi_msg_bvalid             => m_axi_sg_bvalid                  ,
            m_axi_msg_bready             => m_axi_sg_bready                  ,

            -- Scatter Gather Read Address Channel
            m_axi_msg_araddr             => m_axi_sg_araddr_internal                  ,
            m_axi_msg_arlen              => m_axi_sg_arlen                   ,
            m_axi_msg_arsize             => m_axi_sg_arsize                  ,
            m_axi_msg_arburst            => m_axi_sg_arburst                 ,
            m_axi_msg_arprot             => m_axi_sg_arprot                  ,
            m_axi_msg_arcache            => open, --m_axi_sg_arcache                 ,
            m_axi_msg_aruser             => open, --m_axi_sg_aruser                  ,
            m_axi_msg_arvalid            => m_axi_sg_arvalid                 ,
            m_axi_msg_arready            => m_axi_sg_arready                 ,

            -- Memory Map to Stream Scatter Gather Read Data Channel
            m_axi_msg_rdata              => m_axi_sg_rdata                   ,
            m_axi_msg_rresp              => m_axi_sg_rresp                   ,
            m_axi_msg_rlast              => m_axi_sg_rlast                   ,
            m_axi_msg_rvalid             => m_axi_sg_rvalid                  ,
            m_axi_msg_rready             => m_axi_sg_rready                  ,
    
            sg_ctl                      => sg_ctl                           ,

        mm2s_ftch_idle               => mm2s_ftch_idle       ,
        mm2s_ftch_interr_set         => mm2s_ftch_interr_set ,
        mm2s_ftch_slverr_set         => mm2s_ftch_slverr_set ,
        mm2s_ftch_decerr_set         => mm2s_ftch_decerr_set ,
        mm2s_ftch_err_early          => mm2s_ftch_err_early  ,
        mm2s_ftch_stale_desc         => mm2s_ftch_stale_desc ,
        mm2s_updt_idle               => mm2s_updt_idle       ,

        mm2s_updt_ioc_irq_set        => mm2s_updt_ioc_irq_set,
        mm2s_updt_interr_set         => mm2s_updt_interr_set ,
        mm2s_updt_slverr_set         => mm2s_updt_slverr_set ,
        mm2s_updt_decerr_set         => mm2s_updt_decerr_set ,
        mm2s_dma_interr_set          => mm2s_dma_interr_set  ,
        mm2s_dma_slverr_set          => mm2s_dma_slverr_set  ,
        mm2s_dma_decerr_set          => mm2s_dma_decerr_set  ,
            ch_mm2s_ftch_channel_id     => ch_mm2s_ftch_channel_id          ,
            ch_mm2s_updt_channel_id     => ch_mm2s_updt_channel_id          ,
                                                                                            --
        mm2s_irqthresh_rstdsbl       => mm2s_irqthresh_rstdsbl,
        mm2s_dlyirq_dsble            => mm2s_dlyirq_dsble,
        mm2s_irqdelay_wren           => mm2s_irqdelay_wren,
        mm2s_irqdelay                => mm2s_dmacr(MCDMACR_IRQDELAY_MSB_BIT downto MCDMACR_IRQDELAY_LSB_BIT),
        mm2s_irqthresh_wren          => mm2s_irqthresh_wren,
        mm2s_irqthresh               => mm2s_dmacr(MCDMACR_IRQTHRESH_MSB_BIT downto MCDMACR_IRQTHRESH_LSB_BIT),
        mm2s_packet_sof              => mm2s_packet_sof,
        mm2s_packet_eof              => mm2s_packet_eof,
        mm2s_ioc_irq_set             => mm2s_ioc_irq_set,
        mm2s_dly_irq_set             => mm2s_dly_irq_set,
        mm2s_ch_serviced             => mm2s_ch_serviced                 ,
        mm2s_irqdelay_status         => mm2s_irqdelay_status,
        mm2s_irqthresh_status        => mm2s_irqthresh_status,

        ch_mm2s_run_stop                 => mm2s_ch_dmacr_rs,
        ch_mm2s_desc_flush               => mm2s_ch_desc_flush,
        ch_mm2s_tailpntr_enabled         => (others => '1'),
        ch_mm2s_taildesc_wren            => mm2s_ch_tailpntr_updated,
        ch_mm2s_cntrl_strm_stop          => mm2s_ch_cntrl_strm_stop,
        ch_mm2s_irqthresh_rstdsbl        => mm2s_ch_irqthresh_rstdsbl,
        ch_mm2s_dlyirq_dsble             => mm2s_ch_dlyirq_dsble,
        ch_mm2s_irqdelay_wren            => mm2s_ch_irqdelay_wren,
        ch_mm2s_irqthresh_wren           => mm2s_ch_irqthresh_wren,
        ch_mm2s_packet_sof               => mm2s_ch_packet_sof,
        ch_mm2s_packet_eof               => mm2s_ch_packet_eof,
        ch_mm2s_ftch_idle                => mm2s_ch_ftch_idle,
        ch_mm2s_ftch_interr_set          => mm2s_ch_ftch_interr_set,
        ch_mm2s_ftch_slverr_set          => mm2s_ch_ftch_slverr_set,
        ch_mm2s_ftch_decerr_set          => mm2s_ch_ftch_decerr_set,
        ch_mm2s_ftch_err_early           => mm2s_ch_ftch_err_early,
        ch_mm2s_ftch_stale_desc          => mm2s_ch_ftch_stale_desc,
        ch_mm2s_updt_idle                => mm2s_ch_updt_idle,
        ch_mm2s_updt_ioc_irq_set         => mm2s_ch_updt_ioc_irq_set,
        ch_mm2s_updt_interr_set          => mm2s_ch_updt_interr_set,
        ch_mm2s_updt_slverr_set          => mm2s_ch_updt_slverr_set,
        ch_mm2s_updt_decerr_set          => mm2s_ch_updt_decerr_set,
        ch_mm2s_dma_interr_set           => mm2s_ch_dma_interr_set,
        ch_mm2s_dma_slverr_set           => mm2s_ch_dma_slverr_set,
        ch_mm2s_dma_decerr_set           => mm2s_ch_dma_decerr_set,
        ch_mm2s_ioc_irq_set              => mm2s_ch_ioc_irq_set,
        ch_mm2s_dly_irq_set              => mm2s_ch_dly_irq_set,
        ch_mm2s_irqdelay                 => mm2s_ch_irqdelay,
        ch_mm2s_irqthresh                => mm2s_ch_irqthresh,
        ch_mm2s_irqdelay_status          => mm2s_ch_irqdelay_status,
        ch_mm2s_irqthresh_status         => mm2s_ch_irqthresh_status,
        ch_mm2s_pktcount                 => mm2s_ch_pktcount,
        ch_mm2s_taildesc                 => mm2s_ch_taildesc,
        ch_mm2s_curdesc                  => mm2s_ch_curdesc,


            -- Channel 1 AXI Fetch Stream Out
            m_axis_ch1_ftch_aclk        => axi_sg_aclk                      ,
            m_axis_ch1_ftch_tdata       => m_axis_mm2s_ftch_tdata           ,
            m_axis_ch1_ftch_tvalid      => m_axis_mm2s_ftch_tvalid          ,
            m_axis_ch1_ftch_tready      => m_axis_mm2s_ftch_tready          ,
            m_axis_ch1_ftch_tlast       => m_axis_mm2s_ftch_tlast           ,
            m_axis_ch1_ftch_data_valid      => m_axis_mm2s_ftch_data_valid          ,
            m_axis_ch1_ftch_id          => m_axis_mm2s_ftch_id                   ,
            mm2s_channel_id_ftch        => mm2s_axis_channel, --"00000001", --(others => '0'),



            -- Channel 1 AXI Update Stream In
            s_axis_ch1_updt_aclk        => axi_sg_aclk                      ,
            s_axis_ch1_updtptr_tdata    => s_axis_mm2s_updtptr_tdata        ,
            s_axis_ch1_updtptr_tvalid   => s_axis_mm2s_updtptr_tvalid       ,
            s_axis_ch1_updtptr_tready   => s_axis_mm2s_updtptr_tready       ,
            s_axis_ch1_updtptr_tlast    => s_axis_mm2s_updtptr_tlast        ,

            mm2s_channel_updt_id_in     => s_axis_mm2s_updtsts_id           , --(others => '0'),
            s_axis_ch1_updtsts_tdata    => s_axis_mm2s_updtsts_tdata        ,
            s_axis_ch1_updtsts_tvalid   => s_axis_mm2s_updtsts_tvalid       ,
            s_axis_ch1_updtsts_tready   => s_axis_mm2s_updtsts_tready       ,
            s_axis_ch1_updtsts_tlast    => s_axis_mm2s_updtsts_tlast        ,


        -- S2MM Common signal


        -- S2MM Channel 1 Control and Status                                                     --

        ch_s2mm_run_stop                 => s2mm_ch_dmacr_rs,
        ch_s2mm_desc_flush               => s2mm_ch_desc_flush,
        ch_s2mm_tailpntr_enabled         => (others => '1'),
        ch_s2mm_taildesc_wren            => s2mm_ch_tailpntr_updated,
        ch_s2mm_cntrl_strm_stop          => (others => '0'),
        ch_s2mm_irqthresh_rstdsbl        => s2mm_ch_irqthresh_rstdsbl,
        ch_s2mm_dlyirq_dsble             => s2mm_ch_dlyirq_dsble,
        ch_s2mm_irqdelay_wren            => s2mm_ch_irqdelay_wren,
        ch_s2mm_irqthresh_wren           => s2mm_ch_irqthresh_wren,
        ch_s2mm_packet_sof               => s2mm_ch_packet_sof,
        ch_s2mm_packet_eof               => s2mm_ch_packet_eof,
        ch_s2mm_ftch_idle                => s2mm_ch_ftch_idle,
        ch_s2mm_ftch_interr_set          => s2mm_ch_ftch_interr_set,
        ch_s2mm_ftch_slverr_set          => s2mm_ch_ftch_slverr_set,
        ch_s2mm_ftch_decerr_set          => s2mm_ch_ftch_decerr_set,
        ch_s2mm_ftch_err_early           => s2mm_ch_ftch_err_early,
        ch_s2mm_ftch_stale_desc          => s2mm_ch_ftch_stale_desc,
        ch_s2mm_updt_idle                => s2mm_ch_updt_idle,
        ch_s2mm_updt_ioc_irq_set         => s2mm_ch_updt_ioc_irq_set,
        ch_s2mm_updt_interr_set          => s2mm_ch_updt_interr_set,
        ch_s2mm_updt_slverr_set          => s2mm_ch_updt_slverr_set,
        ch_s2mm_updt_decerr_set          => s2mm_ch_updt_decerr_set,
        ch_s2mm_dma_interr_set           => s2mm_ch_dma_interr_set,
        ch_s2mm_dma_slverr_set           => s2mm_ch_dma_slverr_set,
        ch_s2mm_dma_decerr_set           => s2mm_ch_dma_decerr_set,
        ch_s2mm_ioc_irq_set              => s2mm_ch_ioc_irq_set,
        ch_s2mm_dly_irq_set              => s2mm_ch_dly_irq_set,
        ch_s2mm_irqdelay                 => s2mm_ch_irqdelay,
        ch_s2mm_irqthresh                => s2mm_ch_irqthresh,
        ch_s2mm_irqdelay_status          => s2mm_ch_irqdelay_status,
        ch_s2mm_irqthresh_status         => s2mm_ch_irqthresh_status,
        ch_s2mm_pktcount                 => s2mm_ch_pktcount,
        ch_s2mm_taildesc                 => s2mm_ch_taildesc,
        ch_s2mm_curdesc                  => s2mm_ch_curdesc,


            s2mm_ftch_idle              => s2mm_ftch_idle                   ,
            s2mm_ftch_interr_set        => s2mm_ftch_interr_set             ,
            s2mm_ftch_slverr_set        => s2mm_ftch_slverr_set             ,
            s2mm_ftch_decerr_set        => s2mm_ftch_decerr_set             ,
            s2mm_ftch_err_early         => s2mm_ftch_err_early              ,
            s2mm_ftch_stale_desc        => s2mm_ftch_stale_desc             ,
            s2mm_updt_idle              => s2mm_updt_idle                   ,

            s2mm_updt_ioc_irq_set       => s2mm_updt_ioc_irq_set            ,
            s2mm_updt_interr_set        => s2mm_updt_interr_set             ,
            s2mm_updt_slverr_set        => s2mm_updt_slverr_set             ,
            s2mm_updt_decerr_set        => s2mm_updt_decerr_set             ,
            s2mm_dma_interr_set         => s2mm_dma_interr_set              ,
            s2mm_dma_slverr_set         => s2mm_dma_slverr_set              ,
            s2mm_dma_decerr_set         => s2mm_dma_decerr_set              ,
            ch_s2mm_ftch_channel_id     => ch_s2mm_ftch_channel_id          ,
            ch_s2mm_updt_channel_id     => ch_s2mm_updt_channel_id          ,
                                        
            s2mm_irqthresh_rstdsbl      => s2mm_irqthresh_rstdsbl                , -- CR605888
            s2mm_dlyirq_dsble           => s2mm_dlyirq_dsble           , -- CR572013
            s2mm_irqdelay_wren          => s2mm_irqdelay_wren               ,
            s2mm_irqdelay               => s2mm_dmacr(MCDMACR_IRQDELAY_MSB_BIT
                                           downto MCDMACR_IRQDELAY_LSB_BIT),
            s2mm_irqthresh_wren         => s2mm_irqthresh_wren              ,
            s2mm_irqthresh              => s2mm_dmacr(MCDMACR_IRQTHRESH_MSB_BIT
                                          downto MCDMACR_IRQTHRESH_LSB_BIT),
            s2mm_packet_sof             => s2mm_packet_sof                  ,
            s2mm_packet_eof             => s2mm_packet_eof                  ,
            s2mm_ioc_irq_set            => s2mm_ioc_irq_set                 ,
            s2mm_dly_irq_set            => s2mm_dly_irq_set                 ,
            s2mm_ch_serviced            => s2mm_ch_serviced                 ,
            s2mm_irqdelay_status        => s2mm_irqdelay_status             ,
            s2mm_irqthresh_status       => s2mm_irqthresh_status            ,


            -- Channel 2 AXI Fetch Stream Out
            s2mm_channel_id_ftch        => s2mm_axis_channel, --"00000001", --(others => '0'),
            m_axis_ch2_ftch_aclk        => axi_sg_aclk                      ,
            m_axis_ch2_ftch_tdata       => m_axis_s2mm_ftch_tdata           ,
            m_axis_ch2_ftch_tvalid      => m_axis_s2mm_ftch_tvalid          ,
            m_axis_ch2_ftch_data_valid      => m_axis_s2mm_ftch_data_valid          ,
            m_axis_ch2_ftch_tready      => m_axis_s2mm_ftch_tready          ,
            m_axis_ch2_ftch_tlast       => m_axis_s2mm_ftch_tlast           ,
            m_axis_ch2_ftch_id          => m_axis_s2mm_ftch_id                   ,


            -- Channel 2 AXI Update Stream In
            s_axis_ch2_updt_aclk        => axi_sg_aclk                      ,
            s_axis_ch2_updtptr_tdata    => s_axis_s2mm_updtptr_tdata        ,
            s_axis_ch2_updtptr_tvalid   => s_axis_s2mm_updtptr_tvalid       ,
            s_axis_ch2_updtptr_tready   => s_axis_s2mm_updtptr_tready       ,
            s_axis_ch2_updtptr_tlast    => s_axis_s2mm_updtptr_tlast        ,
    
            s2mm_channel_updt_id_in     => s_axis_s2mm_updtsts_id           , --(others => '0'),
            s_axis_ch2_updtsts_tdata    => s_axis_s2mm_updtsts_tdata        ,
            s_axis_ch2_updtsts_tvalid   => s_axis_s2mm_updtsts_tvalid       ,
            s_axis_ch2_updtsts_tready   => s_axis_s2mm_updtsts_tready       ,
            s_axis_ch2_updtsts_tlast    => s_axis_s2mm_updtsts_tlast        ,


            -- Error addresses        
            ftch_error                  => ftch_error                       ,
            ftch_error_addr             => ftch_error_addr                  ,
            updt_error                  => updt_error                       ,
            updt_error_addr             => updt_error_addr                  

--        m_axis_mm2s_cntrl_tdata  => m_axis_mm2s_cntrl_tdata  ,
--        m_axis_mm2s_cntrl_tkeep  => m_axis_mm2s_cntrl_tkeep  ,
--        m_axis_mm2s_cntrl_tvalid => m_axis_mm2s_cntrl_tvalid ,
--        m_axis_mm2s_cntrl_tready => m_axis_mm2s_cntrl_tready ,
--        m_axis_mm2s_cntrl_tlast  => m_axis_mm2s_cntrl_tlast 

        );

m_axi_sg_awaddr <= m_axi_sg_awaddr_internal (C_M_AXI_SG_ADDR_WIDTH-1 downto 0);
m_axi_sg_araddr <= m_axi_sg_araddr_internal (C_M_AXI_SG_ADDR_WIDTH-1 downto 0);

end generate GEN_SG_ENGINE;


INCLUDE_MM2S_SOF_EOF_GENERATOR : if C_INCLUDE_MM2S = 1 generate
begin

mm2s_tlast <= m_axis_mm2s_tvalid_i and m_axis_mm2s_tlast_i; -- and m_axis_mm2s_tready; 

        m_axis_mm2s_tuser  <= mm2s_tuser_tid (15 downto 0);
        m_axis_mm2s_tid    <= mm2s_tuser_tid (23 downto 16);
        m_axis_mm2s_tdest  <= m_axis_mm2s_tdest_int;
-------------------------------------------------------------------------------
-- MM2S DMA Controller
-------------------------------------------------------------------------------
I_MM2S_DMA_MNGR : entity  axi_mcdma_v1_1_8.axi_mcdma_mm2s_mngr
    generic map(

        C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC                ,
        C_PRMY_CMDFIFO_DEPTH        => DM_CMDSTS_FIFO_DEPTH                 ,
        C_INCLUDE_SG                => C_INCLUDE_SG                         ,
        C_SG_INCLUDE_STSCNTRL_STRM  => STSCNTRL_ENABLE           ,
        C_SG_INCLUDE_DESC_QUEUE     => DESC_QUEUE              ,
        C_SG_LENGTH_WIDTH           => C_SG_LENGTH_WIDTH_INT                    ,
        C_M_AXI_SG_ADDR_WIDTH       => ADDR_WIDTH                ,
        C_M_AXIS_SG_TDATA_WIDTH     => M_AXIS_SG_TDATA_WIDTH                ,
        C_S_AXIS_UPDPTR_TDATA_WIDTH => ADDR_WIDTH, --S_AXIS_UPDPTR_TDATA_WIDTH            ,
        C_S_AXIS_UPDSTS_TDATA_WIDTH => S_AXIS_UPDSTS_TDATA_WIDTH            ,
        C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH => C_M_AXIS_MM2S_CNTRL_TDATA_WIDTH  ,
        C_INCLUDE_MM2S              => C_INCLUDE_MM2S                       ,
        C_M_AXI_MM2S_ADDR_WIDTH     => ADDR_WIDTH, --C_M_AXI_MM2S_ADDR_WIDTH              ,
--        C_ENABLE_MULTI_CHANNEL             => 0,
--        C_MICRO_DMA                 => 0,
        C_MAX_CHANNELS              => C_MAX_CHANNELS                       ,
        C_NUM_CHANNELS              => C_NUM_MM2S_CHANNELS,
        C_MM2S_SCHEDULE             => C_MM2S_SCHEDULER_NEW,
        C_FAMILY                    => C_FAMILY
    )
    port map(

        -- Secondary Clock and Reset
        m_axi_sg_aclk               => axi_sg_aclk                          ,
        m_axi_sg_aresetn            => mm2s_scndry_resetn                   ,

        -- Primary Clock and Reset
        axi_prmry_aclk              => m_axi_mm2s_aclk_i                      ,
        p_reset_n                   => mm2s_prmry_resetn                    ,

        soft_reset                  => soft_reset                           ,

        channel_enable              => channel_enable_mm2s,
        channel_weight              => channel_mm2s_wt,    
        channel_weight_2            => channel_mm2s_wt2,    
        mm2s_schedule               => mm2s_schedule(3 downto 0),      
        channel_idle                => mm2s_ch_ftch_idle,       
        channel_id                  => mm2s_axis_channel, --mm2s_ftch_id,        
        mm2s_tlast                  => mm2s_tlast,
        mm2s_tready                 => m_axis_mm2s_tready,
        tuser_out                   => mm2s_tuser_tid(15 downto 0),
        tid_out                     => mm2s_tuser_tid(23 downto 16),
        tdest_out                   => m_axis_mm2s_tdest_int, 


        -- MM2S Control and Status
        mm2s_run_stop               => mm2s_dmacr(MCDMACR_RS_BIT)             ,
--        mm2s_keyhole                => LOGIC_LOW, --mm2s_dmacr(DMACR_KH_BIT)             ,
        mm2s_halted                 => mm2s_dmasr(MCDMASR_HALTED_BIT)         ,
        mm2s_ftch_idle              => mm2s_ftch_idle                       ,
        mm2s_updt_idle              => mm2s_updt_idle                       ,
        mm2s_halt                   => mm2s_halt                            ,
        mm2s_halt_cmplt             => mm2s_halt_cmplt                      ,
        mm2s_halted_clr             => mm2s_halted_clr                      ,
        mm2s_halted_set             => mm2s_halted_set                      ,
        mm2s_idle_set               => mm2s_idle_set                        ,
        mm2s_idle_clr               => mm2s_idle_clr                        ,
        mm2s_stop                   => mm2s_stop                            ,
        mm2s_ftch_err_early         => mm2s_ftch_err_early                  ,
        mm2s_ftch_stale_desc        => mm2s_ftch_stale_desc                 ,
        mm2s_desc_flush             => mm2s_desc_flush                      ,
--        cntrl_strm_stop             => mm2s_cntrl_strm_stop                 ,  
        mm2s_tailpntr_enble         => LOGIC_HIGH, --mm2s_dmacr(DMACR_TAILPEN_BIT)        ,
        mm2s_all_idle               => mm2s_all_idle                        ,
        mm2s_error                  => mm2s_error                           ,
        s2mm_error                  => s2mm_error                           ,

        -- Simple DMA Mode Signals
        mm2s_sa                     => mm2s_sa                              ,
        mm2s_length                 => mm2s_length                          ,
        mm2s_length_wren            => mm2s_length_wren                     ,
        mm2s_smple_done             => mm2s_smpl_done                       ,
        mm2s_interr_set             => mm2s_smpl_interr_set                 ,
        mm2s_slverr_set             => mm2s_smpl_slverr_set                 ,
        mm2s_decerr_set             => mm2s_smpl_decerr_set                 ,

  --      m_axis_mm2s_aclk            => m_axi_mm2s_aclk_i,
 --       mm2s_strm_tlast             => m_axis_mm2s_tlast_i_user,
 --       mm2s_strm_tready            => m_axis_mm2s_tready,
 --       mm2s_axis_info              => mm2s_axis_info,

        -- SG MM2S Descriptor Fetch AXI Stream In
        m_axis_mm2s_ftch_data_valid     => m_axis_mm2s_ftch_data_valid              ,
        m_axis_mm2s_ftch_tdata      => m_axis_mm2s_ftch_tdata               ,
        m_axis_mm2s_ftch_tvalid     => m_axis_mm2s_ftch_tvalid              ,
        m_axis_mm2s_ftch_tready     => m_axis_mm2s_ftch_tready              ,
        m_axis_mm2s_ftch_tlast      => m_axis_mm2s_ftch_tlast               ,
        m_axis_mm2s_ftch_id         => m_axis_mm2s_ftch_id                  ,

 --       m_axis_mm2s_ftch_tdata_new      => m_axis_mm2s_ftch_tdata_new               ,
 --       m_axis_mm2s_ftch_tdata_mcdma_new      => m_axis_mm2s_ftch_tdata_mcdma_new               ,
 --       m_axis_mm2s_ftch_tvalid_new     => m_axis_mm2s_ftch_tvalid_new              ,
 --           m_axis_ftch1_desc_available  => m_axis_ftch1_desc_available,

        -- SG MM2S Descriptor Update AXI Stream Out
        s_axis_mm2s_updtptr_tdata   => s_axis_mm2s_updtptr_tdata            ,
        s_axis_mm2s_updtptr_tvalid  => s_axis_mm2s_updtptr_tvalid           ,
        s_axis_mm2s_updtptr_tready  => s_axis_mm2s_updtptr_tready           ,
        s_axis_mm2s_updtptr_tlast   => s_axis_mm2s_updtptr_tlast            ,

        s_axis_mm2s_updtsts_tdata   => s_axis_mm2s_updtsts_tdata            ,
        s_axis_mm2s_updtsts_tvalid  => s_axis_mm2s_updtsts_tvalid           ,
        s_axis_mm2s_updtsts_tready  => s_axis_mm2s_updtsts_tready           ,
        s_axis_mm2s_updtsts_tlast   => s_axis_mm2s_updtsts_tlast            ,
        s_axis_mm2s_updtsts_id      => s_axis_mm2s_updtsts_id               ,


        -- Currently Being Processed Descriptor
        mm2s_new_curdesc            => mm2s_new_curdesc                     ,
        mm2s_new_curdesc_wren       => mm2s_new_curdesc_wren_mngr, --mm2s_new_curdesc_wren                ,
        mm2s_channel_id_reg_update  => mm2s_channel_id_reg_update           ,

        -- User Command Interface Ports (AXI Stream)
        s_axis_mm2s_cmd_tvalid      => s_axis_mm2s_cmd_tvalid               ,
        s_axis_mm2s_cmd_tready      => s_axis_mm2s_cmd_tready               ,
        s_axis_mm2s_cmd_tdata       => s_axis_mm2s_cmd_tdata               ,

        -- User Status Interface Ports (AXI Stream)
        m_axis_mm2s_sts_tvalid      => m_axis_mm2s_sts_tvalid               ,
        m_axis_mm2s_sts_tready      => m_axis_mm2s_sts_tready               ,
        m_axis_mm2s_sts_tdata       => m_axis_mm2s_sts_tdata                ,
        m_axis_mm2s_sts_tkeep       => m_axis_mm2s_sts_tkeep                ,
        mm2s_err                    => mm2s_err                             ,
        updt_error                  => updt_error                           ,
        ftch_error                  => ftch_error                           ,

        -- Memory Map to Stream Control Stream Interface
        m_axis_mm2s_cntrl_tdata     => m_axis_mm2s_cntrl_tdata              ,
        m_axis_mm2s_cntrl_tkeep     => m_axis_mm2s_cntrl_tkeep              ,
        m_axis_mm2s_cntrl_tvalid    => m_axis_mm2s_cntrl_tvalid             ,
        m_axis_mm2s_cntrl_tready    => m_axis_mm2s_cntrl_tready             ,
        m_axis_mm2s_cntrl_tlast     => m_axis_mm2s_cntrl_tlast
    );

CURDESC_WREN_GEN : for I in 0 to C_NUM_MM2S_CHANNELS-1 generate
begin

mm2s_ch_new_curdesc_wren(I) <= mm2s_channel_id_reg_update(I) and mm2s_new_curdesc_wren_mngr;

end generate CURDESC_WREN_GEN;

UNUSED_WREN_GEN : if C_MAX_CHANNELS > C_NUM_MM2S_CHANNELS generate
begin

CURDESC_WREN_GEN : for I in C_NUM_MM2S_CHANNELS to C_MAX_CHANNELS-1 generate
begin

mm2s_ch_new_curdesc_wren(I) <= mm2s_channel_id_reg_update(I) and mm2s_new_curdesc_wren_mngr;

end generate CURDESC_WREN_GEN;

end generate UNUSED_WREN_GEN;

-- If MM2S channel included then include sof/eof generator
    -------------------------------------------------------------------------------
    -- MM2S SOF / EOF generation for interrupt coalescing -------------------------------------------------------------------------------
    I_MM2S_SOFEOF_GEN : entity  axi_mcdma_v1_1_8.axi_mcdma_sofeof_gen
        generic map(
            C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC,
            C_ENABLE_SINGLE_INTR        => C_ENABLE_SINGLE_INTR,
            C_MAX_CHANNELS              => C_MAX_CHANNELS,
            C_FAMILY                    => C_FAMILY
        )
        port map(
            axi_prmry_aclk              => m_axi_mm2s_aclk_i                  ,
            p_reset_n                   => mm2s_prmry_resetn                ,

            m_axi_sg_aclk               => axi_sg_aclk                      ,
            m_axi_sg_aresetn            => mm2s_scndry_resetn               ,

            axis_tready                 => m_axis_mm2s_tready               ,
            axis_tvalid                 => m_axis_mm2s_tvalid_i             ,
            axis_tlast                  => m_axis_mm2s_tlast_i              ,
            axis_tdest                  => m_axis_mm2s_tdest_int                ,

            packet_sof                  => mm2s_packet_sof                  ,
            packet_eof                  => mm2s_packet_eof                  ,

            packet_sof_ch               => mm2s_ch_packet_sof                  ,
            packet_eof_ch               => mm2s_ch_packet_eof                  
        );

end generate INCLUDE_MM2S_SOF_EOF_GENERATOR;

-- If MM2S channel not included then exclude sof/eof generator
EXCLUDE_MM2S_SOF_EOF_GENERATOR : if C_INCLUDE_MM2S = 0 generate
begin
    mm2s_packet_sof <= '0';
    mm2s_packet_eof <= '0';
end generate EXCLUDE_MM2S_SOF_EOF_GENERATOR;


INCLUDE_S2MM_SOF_EOF_GENERATOR : if C_INCLUDE_S2MM = 1 generate
begin

-------------------------------------------------------------------------------
-- S2MM DMA Controller
-------------------------------------------------------------------------------

I_S2MM_DMA_MNGR : entity  axi_mcdma_v1_1_8.axi_mcdma_s2mm_mngr
    generic map(

        C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC                ,
        C_PRMY_CMDFIFO_DEPTH        => DM_CMDSTS_FIFO_DEPTH                 ,
        C_DM_STATUS_WIDTH           => DM_STATUS_WIDTH                      ,
        C_INCLUDE_SG                => C_INCLUDE_SG                         ,
        C_SG_INCLUDE_STSCNTRL_STRM  => C_SG_INCLUDE_STSCNTRL_STRM           ,
        C_SG_INCLUDE_DESC_QUEUE     => 1, --C_SG_INCLUDE_DESC_QUEUE              ,
        C_SG_USE_STSAPP_LENGTH      => C_SG_USE_STSAPP_LENGTH               ,
        C_SG_LENGTH_WIDTH           => C_SG_LENGTH_WIDTH_INT                    ,
        C_M_AXI_SG_ADDR_WIDTH       => ADDR_WIDTH,                          --C_M_AXI_SG_ADDR_WIDTH                ,
        C_M_AXIS_SG_TDATA_WIDTH     => M_AXIS_SG_TDATA_WIDTH                ,
        C_S_AXIS_UPDPTR_TDATA_WIDTH => ADDR_WIDTH,                          --S_AXIS_UPDPTR_TDATA_WIDTH            ,
        C_S_AXIS_UPDSTS_TDATA_WIDTH => S_AXIS_UPDSTS_TDATA_WIDTH            ,
        C_S_AXIS_S2MM_STS_TDATA_WIDTH => C_S_AXIS_S2MM_STS_TDATA_WIDTH      ,
        C_INCLUDE_S2MM              => C_INCLUDE_S2MM                       ,
        C_M_AXI_S2MM_ADDR_WIDTH     => ADDR_WIDTH, --C_M_AXI_S2MM_ADDR_WIDTH              ,
        C_MAX_CHANNELS              => C_MAX_CHANNELS                       ,
        C_FAMILY                    => C_FAMILY
    )
    port map(

        -- Secondary Clock and Reset
        m_axi_sg_aclk               => axi_sg_aclk                          ,
        m_axi_sg_aresetn            => s2mm_scndry_resetn                   ,

        -- Primary Clock and Reset
        axi_prmry_aclk              => m_axi_s2mm_aclk_i                      ,
        p_reset_n                   => s2mm_prmry_resetn                    ,

        accept_sts                  => accept_sts, 
        reject_sts                  => reject_sts, 
        sts_busy                    => sts_busy,

        soft_reset                  => soft_reset                           ,

        -- S2MM Control and Status
        s2mm_run_stop               => s2mm_dmacr(MCDMACR_RS_BIT)             ,
        s2mm_halted                 => s2mm_dmasr(MCDMASR_HALTED_BIT)         ,
        s2mm_ftch_idle              => s2mm_ftch_idle                       ,
        s2mm_updt_idle              => s2mm_updt_idle                       ,
        s2mm_halted_clr             => s2mm_halted_clr                      ,
        s2mm_halted_set             => s2mm_halted_set                      ,
        s2mm_idle_set               => s2mm_idle_set                        ,
        s2mm_idle_clr               => s2mm_idle_clr                        ,
        s2mm_stop                   => s2mm_stop                            ,
        s2mm_ftch_err_early         => s2mm_ftch_err_early                  ,
        s2mm_ftch_stale_desc        => s2mm_ftch_stale_desc                 ,
        s2mm_desc_flush             => s2mm_desc_flush                      ,
        s2mm_tailpntr_enble         => LOGIC_HIGH, --s2mm_dmacr(DMACR_TAILPEN_BIT)        ,
        s2mm_all_idle               => s2mm_all_idle                        ,
        s2mm_halt                   => s2mm_halt                            ,
        s2mm_halt_cmplt             => s2mm_halt_cmplt                      ,
        s2mm_error                  => s2mm_error                           ,
        mm2s_error                  => mm2s_error                           ,
        fetch_more                  => bd_fetch_trig, --fetch_more                           ,

        -- SG S2MM Descriptor Fetch AXI Stream In
        m_axis_s2mm_ftch_tdata      => m_axis_s2mm_ftch_tdata               ,
        m_axis_s2mm_ftch_tvalid     => m_axis_s2mm_ftch_tvalid              ,
        m_axis_s2mm_ftch_data_valid     => m_axis_s2mm_ftch_data_valid              ,
        m_axis_s2mm_ftch_tready     => m_axis_s2mm_ftch_tready              ,
        m_axis_s2mm_ftch_tlast      => m_axis_s2mm_ftch_tlast               ,
        m_axis_s2mm_ftch_id         => m_axis_s2mm_ftch_id                   ,

        -- SG S2MM Descriptor Update AXI Stream Out
        s_axis_s2mm_updtptr_tdata   => s_axis_s2mm_updtptr_tdata            ,
        s_axis_s2mm_updtptr_tvalid  => s_axis_s2mm_updtptr_tvalid           ,
        s_axis_s2mm_updtptr_tready  => s_axis_s2mm_updtptr_tready           ,
        s_axis_s2mm_updtptr_tlast   => s_axis_s2mm_updtptr_tlast            ,

        s_axis_s2mm_updtsts_tdata   => s_axis_s2mm_updtsts_tdata            ,
        s_axis_s2mm_updtsts_tvalid  => s_axis_s2mm_updtsts_tvalid           ,
        s_axis_s2mm_updtsts_tready  => s_axis_s2mm_updtsts_tready           ,
        s_axis_s2mm_updtsts_tlast   => s_axis_s2mm_updtsts_tlast            ,
        s_axis_s2mm_updtsts_id      => s_axis_s2mm_updtsts_id               ,

        -- Currently Being Processed Descriptor
        s2mm_new_curdesc            => s2mm_new_curdesc                     ,
        s2mm_new_curdesc_wren       => s2mm_new_curdesc_wren_mngr           ,
        s2mm_channel_id_reg_update  => s2mm_channel_id_reg_update           ,

        -- User Command Interface Ports (AXI Stream)
        s_axis_s2mm_cmd_tvalid      => s_axis_s2mm_cmd_tvalid               ,
        s_axis_s2mm_cmd_tready      => s_axis_s2mm_cmd_tready               ,
        s_axis_s2mm_cmd_tdata       => s_axis_s2mm_cmd_tdata                ,

        -- User Status Interface Ports (AXI Stream)
        m_axis_s2mm_sts_tvalid      => m_axis_s2mm_sts_tvalid               ,
        m_axis_s2mm_sts_tready      => m_axis_s2mm_sts_tready               ,
        m_axis_s2mm_sts_tdata       => m_axis_s2mm_sts_tdata                ,
        m_axis_s2mm_sts_tkeep       => m_axis_s2mm_sts_tkeep                ,
        m_axis_s2mm_sg_side_band    => sg_side_band                         ,
        m_axis_s2mm_sg_side_band_valid    => sg_side_band_valid                         ,
        m_axis_s2mm_sg_side_band_s2mm_tuser         => sg_side_band_s2mm_tuser,
        m_axis_s2mm_sg_side_band_tuser_valid        => sg_side_band_tuser_valid,
        s2mm_err                    => s2mm_err                             ,
        updt_error                  => updt_error                           ,
        ftch_error                  => ftch_error                           ,

        -- Stream to Memory Map Status Stream Interface
        s_axis_s2mm_sts_tdata       => s_axis_s2mm_sts_tdata_buf                ,
        s_axis_s2mm_sts_tkeep       => s_axis_s2mm_sts_tkeep_buf                ,
        s_axis_s2mm_sts_tvalid      => s_axis_s2mm_sts_tvalid_buf               ,
        s_axis_s2mm_sts_tready      => s_axis_s2mm_sts_tready_buf               ,
        s_axis_s2mm_sts_tlast       => s_axis_s2mm_sts_tlast_buf 
    );

CURDESC_WREN_GEN : for I in 0 to C_NUM_S2MM_CHANNELS-1 generate
begin

s2mm_ch_new_curdesc_wren(I) <= s2mm_channel_id_reg_update(I) and s2mm_new_curdesc_wren_mngr;

end generate CURDESC_WREN_GEN;

UNUSED_WREN_GEN : if C_MAX_CHANNELS > C_NUM_S2MM_CHANNELS generate
begin

CURDESC_WREN_GEN : for I in C_NUM_S2MM_CHANNELS to C_MAX_CHANNELS-1 generate
begin

s2mm_ch_new_curdesc_wren(I) <= s2mm_channel_id_reg_update(I) and s2mm_new_curdesc_wren_mngr;

end generate CURDESC_WREN_GEN;

end generate UNUSED_WREN_GEN;



-- If S2MM channel included then include sof/eof generator
    -------------------------------------------------------------------------------
    -- S2MM SOF / EOF generation for interrupt coalescing
    -------------------------------------------------------------------------------
    I_S2MM_SOFEOF_GEN : entity  axi_mcdma_v1_1_8.axi_mcdma_sofeof_gen
        generic map(
            C_PRMRY_IS_ACLK_ASYNC       => C_PRMRY_IS_ACLK_ASYNC,
            C_ENABLE_SINGLE_INTR        => C_ENABLE_SINGLE_INTR,
            C_MAX_CHANNELS              => C_MAX_CHANNELS
        )
        port map(
            axi_prmry_aclk              => m_axi_s2mm_aclk_i                  ,
            p_reset_n                   => s2mm_prmry_resetn                ,

            m_axi_sg_aclk               => axi_sg_aclk                      ,
            m_axi_sg_aresetn            => s2mm_scndry_resetn               ,

            axis_tready                 => tready_from_datamover             ,
            axis_tvalid                 => tvalid_to_datamover, --s_axis_s2mm_tvalid               ,
            axis_tlast                  => s_axis_s2mm_tlast_dm                ,
            axis_tdest                  => s_axis_s2mm_tdest_dm                ,

            packet_sof                  => s2mm_packet_sof                  ,
            packet_eof                  => s2mm_packet_eof                  ,

            packet_sof_ch              => s2mm_ch_packet_sof                  ,
            packet_eof_ch              => s2mm_ch_packet_eof                  


        );


CHANNEL_GEN: for I in 0 to C_MAX_CHANNELS-1 generate
begin

s2mm_ch_dmacr_pkt_thresh(8+8*I-1 downto 8*I) <=s2mm_ch_dmacr(32*I+CHDMACR_PKTTHRESH_MSB_BIT downto CHDMACR_PKTTHRESH_LSB_BIT+32*I);  


end generate CHANNEL_GEN;


   I_S2MM_GATE_GEN : entity  axi_mcdma_v1_1_8.axi_mcdma_s2mm_tdest
       generic map (
           C_FAMILY       => C_FAMILY,
           C_MAX_CHANNELS => C_MAX_CHANNELS,
           C_NUM_S2MM_CHANNELS => C_NUM_S2MM_CHANNELS, 
           C_ASYNC        => C_PRMRY_IS_ACLK_ASYNC,
           C_ENABLE_SINGLE_INTR => C_ENABLE_SINGLE_INTR,
           C_ENABLE_DROP_CNT    => 1
       ) 
       port map (
           m_axi_s2mm_aclk      => m_axi_s2mm_aclk_i,
           m_axi_sg_aclk        => axi_sg_aclk,
           m_axi_sg_aresetn     => m_axi_sg_aresetn,
           m_axi_s2mm_aresetn   => s2mm_prmry_resetn,
           eof_detected         => eof_detected, 
           channel_idle         => sg_ftch_idle,
           channel_enable       => channel_enable_reg,
           sts_busy             => sts_busy,
           s2mm_run_stop        => s2mm_dmacr(MCDMACR_RS_BIT)             ,
           fetch_more           => fetch_more,
           s_axis_tvalid        => axis_buffer_valid, --s_axis_s2mm_tvalid,
           s_axis_tlast         => s_axis_s2mm_tlast_dm,
           s_axis_tdest         => s_axis_s2mm_tdest_dm,
           s_axis_tuser         => s_axis_s2mm_tuser_dm,
           s_axis_tid           => s_axis_s2mm_tid_dm,
           s_axis_tready        => s_axis_s2mm_tready_i,

           m_axis_tvalid        => tvalid_to_datamover,
           m_axis_tready        => tready_from_datamover,

           sg_channel_id               => s2mm_axis_channel,
           sg_channel_id_reg               => s2mm_axis_channel_reg,
           bd_fetch_trig            => bd_fetch_trig,
           accept_sts                  => accept_sts, 
           reject_sts                  => reject_sts, 
           s2mm_pktdrp_irq_set              => s2mm_pkt_irq_set                     ,
           s2mm_pktirqthresh_status         => s2mm_pktirqthresh_status             ,
           s2mm_pktirqthresh_wren           => s2mm_pktirqthresh_wren               ,
           s2mm_pktirqthresh                => s2mm_dmacr(MCDMACR_PKTTHRESH_MSB_BIT downto MCDMACR_PKTTHRESH_LSB_BIT),
           s2mm_pktdrp_count                => s2mm_pktdrp_count,
           ch_s2mm_pktdrp_irq_set          => s2mm_ch_pkt_irq_set                     ,
           ch_s2mm_pktirqthresh_status     => s2mm_ch_pktirqthresh_status             ,
           ch_s2mm_pktirqthresh_wren       => s2mm_ch_pktirqthresh_wren               ,
           ch_s2mm_pktirqthresh            => s2mm_ch_dmacr_pkt_thresh,
           ch_s2mm_pktdrp_count            => s2mm_ch_pktdrp_count,
           ch_s2mm_pktdrp_reset            => s2mm_ch_pkdrp_rst,
           sg_side_band                    => open,
           sg_side_band_s2mm               => sg_side_band,
           sg_side_band_valid              => sg_side_band_valid, 
           sg_side_band_s2mm_tuser         => sg_side_band_s2mm_tuser,
           sg_side_band_tuser_valid        => sg_side_band_tuser_valid

          );



EXCLUDE_BUF_FIFO : if ENABLE_BUF_FIFO = 0 generate
begin

        s_axis_s2mm_tdata_dm <= s_axis_s2mm_tdata;
        s_axis_s2mm_tkeep_dm <= s_axis_s2mm_tkeep;
        s_axis_s2mm_tdest_dm <= s_axis_s2mm_tdest;
        s_axis_s2mm_tid_dm   <= s_axis_s2mm_tid;
        s_axis_s2mm_tuser_dm <= s_axis_s2mm_tuser;
        s_axis_s2mm_tlast_dm <= s_axis_s2mm_tlast;


        axis_buffer_valid    <= s_axis_s2mm_tvalid;
        axis_buffer_read <= s_axis_s2mm_tready_i and s_axis_s2mm_tvalid;
        s_axis_s2mm_tready <= s_axis_s2mm_tready_i;

end generate EXCLUDE_BUF_FIFO;

INCLUDE_BUF_FIFO : if ENABLE_BUF_FIFO = 1 generate
begin
        -- data_width = 1 + 16 + 8 + 4 + tdata/8 + tdata;
        s_axis_buffer <= s_axis_s2mm_tlast & s_axis_s2mm_tuser & s_axis_s2mm_tid & s_axis_s2mm_tdest & s_axis_s2mm_tkeep & s_axis_s2mm_tdata;
        s_axis_s2mm_tvalid_int <= s_axis_s2mm_tvalid and (not axis_buffer_full);
        s_axis_s2mm_tready <= not axis_buffer_full;

        axis_buffer_valid <= not (axis_buffer_empty);
        axis_buffer_read <= s_axis_s2mm_tready_i and (not axis_buffer_empty);
        s_axis_s2mm_tdata_dm <= axis_buffer_out (C_S_AXIS_S2MM_TDATA_WIDTH-1 downto 0);
        s_axis_s2mm_tkeep_dm <= axis_buffer_out (C_S_AXIS_S2MM_TDATA_WIDTH+C_S_AXIS_S2MM_TDATA_WIDTH/8-1 downto C_S_AXIS_S2MM_TDATA_WIDTH);
        s_axis_s2mm_tdest_dm <= axis_buffer_out (C_S_AXIS_S2MM_TDATA_WIDTH+C_S_AXIS_S2MM_TDATA_WIDTH/8+4-1 downto C_S_AXIS_S2MM_TDATA_WIDTH+C_S_AXIS_S2MM_TDATA_WIDTH/8);
        s_axis_s2mm_tid_dm   <= axis_buffer_out (C_S_AXIS_S2MM_TDATA_WIDTH+C_S_AXIS_S2MM_TDATA_WIDTH/8+4+8-1 downto C_S_AXIS_S2MM_TDATA_WIDTH+C_S_AXIS_S2MM_TDATA_WIDTH/8+4);
        s_axis_s2mm_tuser_dm <= axis_buffer_out (C_S_AXIS_S2MM_TDATA_WIDTH+C_S_AXIS_S2MM_TDATA_WIDTH/8+4+8+16-1 downto C_S_AXIS_S2MM_TDATA_WIDTH+C_S_AXIS_S2MM_TDATA_WIDTH/8+4+8);
        s_axis_s2mm_tlast_dm <= axis_buffer_out (C_S_AXIS_S2MM_TDATA_WIDTH+C_S_AXIS_S2MM_TDATA_WIDTH/8+4+8+16);


        fifo_rst <= not m_axi_s2mm_aresetn;


    -- Generate Synchronous FIFO
    I_BUF_FIFO : entity lib_fifo_v1_0_16.sync_fifo_fg
    generic map (
        C_FAMILY                =>  C_FAMILY                ,
        C_MEMORY_TYPE           =>  1, --USE_LOGIC_FIFOS,
        C_WRITE_DATA_WIDTH      =>  C_S_AXIS_S2MM_TDATA_WIDTH + C_S_AXIS_S2MM_TDATA_WIDTH/8 + 4 + 8 + 16 +1,
        C_WRITE_DEPTH           =>  256       ,
        C_READ_DATA_WIDTH       =>  C_S_AXIS_S2MM_TDATA_WIDTH + C_S_AXIS_S2MM_TDATA_WIDTH/8 + 4 + 8 + 16 +1,
        C_READ_DEPTH            =>  256       ,
        C_PORTS_DIFFER          =>  0,
        C_HAS_DCOUNT            =>  1, --req for proper fifo operation
        C_DCOUNT_WIDTH          =>  9,
        C_HAS_ALMOST_FULL       =>  0,
        C_HAS_RD_ACK            =>  0,
        C_HAS_RD_ERR            =>  0,
        C_HAS_WR_ACK            =>  0,
        C_HAS_WR_ERR            =>  0,
        C_RD_ACK_LOW            =>  0,
        C_RD_ERR_LOW            =>  0,
        C_WR_ACK_LOW            =>  0,
        C_WR_ERR_LOW            =>  0,
        C_PRELOAD_REGS          =>  1,-- 1 = first word fall through
        C_PRELOAD_LATENCY       =>  0, -- 0 = first word fall through
        C_XPM_FIFO              =>  1

    )
    port map (

        Clk             =>  m_axi_s2mm_aclk_i       ,
        Sinit           =>  fifo_rst                ,
        Din             =>  s_axis_buffer  ,
        Wr_en           =>  s_axis_s2mm_tvalid_int ,
        Rd_en           =>  axis_buffer_read     , -- read of fifo internally
        Dout            =>  axis_buffer_out     ,  -- to be used internally
        Full            =>  axis_buffer_full ,
        Empty           =>  axis_buffer_empty    ,
        Almost_full     =>  open                ,
        Data_count      =>  open                ,
        Rd_ack          =>  open                ,
        Rd_err          =>  open                ,
        Wr_ack          =>  open                ,
        Wr_err          =>  open

    );

-- For STS Stream
INCLUDE_STS_FIFO : if C_SG_INCLUDE_STSCNTRL_STRM = 1 generate 
signal s_axis_s2mm_sts_wr : std_logic;
signal sts_fifo_full : std_logic;
signal sts_fifo_empty : std_logic;
signal sts_fifo_rd : std_logic;
signal s_axis_s2mm_sts_rd_buf : std_logic_vector (36 downto 0);
begin


    s_axis_s2mm_sts_buf <= s_axis_s2mm_sts_tdata & s_axis_s2mm_sts_tkeep & s_axis_s2mm_sts_tlast;
    s_axis_s2mm_sts_wr <= s_axis_s2mm_sts_tvalid and (not sts_fifo_full);
    s_axis_s2mm_sts_tready <= not sts_fifo_full;
    sts_fifo_rd <= s_axis_s2mm_sts_tready_buf and (not sts_fifo_empty);
    s_axis_s2mm_sts_tdata_buf <= s_axis_s2mm_sts_rd_buf (36 downto 5) ;
    s_axis_s2mm_sts_tkeep_buf <= s_axis_s2mm_sts_rd_buf (4 downto 1);
    s_axis_s2mm_sts_tlast_buf <= s_axis_s2mm_sts_rd_buf (0);
    s_axis_s2mm_sts_tvalid_buf <= not sts_fifo_empty;

    -- Generate Synchronous FIFO
    I_BUF_STS_FIFO : entity lib_fifo_v1_0_16.sync_fifo_fg
    generic map (
        C_FAMILY                =>  C_FAMILY                ,
        C_MEMORY_TYPE           =>  1, --USE_LOGIC_FIFOS,
        C_WRITE_DATA_WIDTH      =>  37,
        C_WRITE_DEPTH           =>  256       ,
        C_READ_DATA_WIDTH       =>  37,
        C_READ_DEPTH            =>  256       ,
        C_PORTS_DIFFER          =>  0,
        C_HAS_DCOUNT            =>  1, --req for proper fifo operation
        C_DCOUNT_WIDTH          =>  9,
        C_HAS_ALMOST_FULL       =>  0,
        C_HAS_RD_ACK            =>  0,
        C_HAS_RD_ERR            =>  0,
        C_HAS_WR_ACK            =>  0,
        C_HAS_WR_ERR            =>  0,
        C_RD_ACK_LOW            =>  0,
        C_RD_ERR_LOW            =>  0,
        C_WR_ACK_LOW            =>  0,
        C_WR_ERR_LOW            =>  0,
        C_PRELOAD_REGS          =>  1,-- 1 = first word fall through
        C_PRELOAD_LATENCY       =>  0, -- 0 = first word fall through
        C_XPM_FIFO              =>  1

    )
    port map (

        Clk             =>  m_axi_s2mm_aclk_i       ,
        Sinit           =>  fifo_rst                ,
        Din             =>  s_axis_s2mm_sts_buf  ,
        Wr_en           =>  s_axis_s2mm_sts_wr ,
        Rd_en           =>  sts_fifo_rd     , -- read of fifo internally
        Dout            =>  s_axis_s2mm_sts_rd_buf     ,  -- to be used internally
        Full            =>  sts_fifo_full ,
        Empty           =>  sts_fifo_empty    ,
        Almost_full     =>  open                ,
        Data_count      =>  open                ,
        Rd_ack          =>  open                ,
        Rd_err          =>  open                ,
        Wr_ack          =>  open                ,
        Wr_err          =>  open

    );
end generate INCLUDE_STS_FIFO;

end generate INCLUDE_BUF_FIFO;

COUNT_STBS_SET : entity axi_mcdma_v1_1_8.axi_mcdma_stbs_set
    generic map (

      C_STROBE_WIDTH      =>  C_S_AXIS_S2MM_TDATA_WIDTH/8

      )
    port map (

      tstrb_in            =>  s_axis_s2mm_tkeep_dm,
      num_stbs_asserted   =>  strb_bytes_set  -- 8 bit wide slv

      );


process (axi_sg_aclk)
begin
if (axi_sg_aclk'event and axi_sg_aclk = '1') then
     if (dm_s2mm_scndry_resetn = '0') then
         cmd_btt_int <= (others => '0');
     elsif (s_axis_s2mm_cmd_tvalid = '1' and s_axis_s2mm_cmd_tready = '1') then
         cmd_btt_int <= s_axis_s2mm_cmd_tdata (25 downto 0);
     end if;
end if;
end process;


-- async
ASYNC_EOF_FETCH : if C_PRMRY_IS_ACLK_ASYNC = 1 generate
begin


process (axi_sg_aclk)
begin
if (axi_sg_aclk'event and axi_sg_aclk = '1') then
     if (dm_s2mm_scndry_resetn = '0') then
         cmd_received <= '0';
     elsif (s_axis_s2mm_cmd_tvalid = '1' and s_axis_s2mm_cmd_tready = '1') then
         cmd_received <= not cmd_received;   -- to be passed to cdc to s2mm_clk
     end if;
end if;
end process;

CMD_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => 2 --MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => cmd_received,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => m_axi_s2mm_aclk_i,
        scndry_resetn              => '0',
        scndry_out                 => cmd_received_cdc3,
        scndry_vect_out            => open
    );

process (m_axi_s2mm_aclk_i)
begin
if (m_axi_s2mm_aclk_i'event and m_axi_s2mm_aclk_i = '1') then
       cmd_received_cdc2 <= cmd_received_cdc3;
end if;
end process;

    cmd_received_s2mm <= cmd_received_cdc2 xor cmd_received_cdc3;

    btt_rst <= not m_axi_s2mm_aresetn;

--            BTT_FIFO : entity lib_srl_fifo_v1_0_2.srl_fifo_f
--              generic map(
--                C_DWIDTH        => 23                              ,
--                C_DEPTH         => 4                                               ,
--                C_FAMILY        => C_FAMILY
--                )
--              port map(
--                Clk             => m_axi_s2mm_aclk_i                                  ,
--                Reset           => btt_rst, --xb_fifo_reset                                    ,
--                FIFO_Write      => cmd_received_s2mm2                                     ,
--                Data_In         => cmd_btt_s2mm                                       ,
--                FIFO_Read       => cmd_fifo_pop                                  ,
--                Data_Out        => cmd_btt_cmp, --s2mm_xferd_bytes                                 ,
--                FIFO_Empty      => btt_fifo_empty                                             ,
--                FIFO_Full       => open, --xb_fifo_full                                     ,
--                Addr            => open
--                );




process (m_axi_s2mm_aclk_i)
begin
if (m_axi_s2mm_aclk_i'event and m_axi_s2mm_aclk_i = '1') then
     if (m_axi_s2mm_aresetn = '0') then
         cmd_btt_cdc_to <= (others => '0');
     elsif (cmd_received_s2mm = '1') then
         cmd_btt_cdc_to <= cmd_btt_int;
     end if;
end if;
end process;


process (m_axi_s2mm_aclk_i)
begin
if (m_axi_s2mm_aclk_i'event and m_axi_s2mm_aclk_i = '1') then
     if (m_axi_s2mm_aresetn = '0') then
         cmd_btt_s2mm <= (others => '0');
         cmd_received_s2mm1 <= '0';
         cmd_received_s2mm2 <= '0';
     else
         cmd_btt_s2mm <= cmd_btt_cdc_to;
         cmd_received_s2mm1 <= cmd_received_s2mm; 
         cmd_received_s2mm2 <= cmd_received_s2mm1; 
     end if;
end if;
end process;


process (m_axi_s2mm_aclk_i)
begin
if (m_axi_s2mm_aclk_i'event and m_axi_s2mm_aclk_i = '1') then
     if (m_axi_s2mm_aresetn = '0' or eof_detected_int = '1' ) then
         cmd_btt_s2mm_cumul <= (others => '0');
     elsif (cmd_received_s2mm2 = '1') then
         cmd_btt_s2mm_cumul <= std_logic_vector (unsigned(cmd_btt_s2mm_cumul(25 downto 0)) + unsigned(cmd_btt_s2mm(25 downto 0)));
     end if;
end if;
end process;


process (m_axi_s2mm_aclk_i)
begin
if (m_axi_s2mm_aclk_i'event and m_axi_s2mm_aclk_i = '1') then
     if (m_axi_s2mm_aresetn = '0' or eof_detected_int = '1' or fetch_more_int = '1') then
         cmd_btt_valid_int <= '0';
     elsif (cmd_received_s2mm2 = '1') then
         cmd_btt_valid_int <= '1';
     end if;
end if;
end process;

        cmd_btt_valid <= cmd_btt_valid_int;
        cmd_btt <= cmd_btt_cdc_to;


process (m_axi_s2mm_aclk_i)
begin
if (m_axi_s2mm_aclk_i'event and m_axi_s2mm_aclk_i = '1') then
     if (m_axi_s2mm_aresetn = '0') then
       eof_detected_s2mm <= '0';
     elsif (eof_detected_int = '1') then
        eof_detected_s2mm <= not eof_detected_s2mm;
     end if;
end if;
end process;


EOF_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => 2 --MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => eof_detected_s2mm,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => eof_detected_s2mm_cdc3,
        scndry_vect_out            => open
    );

process (axi_sg_aclk)
begin
if (axi_sg_aclk'event and axi_sg_aclk = '1') then
    eof_detected_s2mm_cdc2 <= eof_detected_s2mm_cdc3;
end if;
end process;

eof_detected <= eof_detected_s2mm_cdc2 xor eof_detected_s2mm_cdc3;


process (m_axi_s2mm_aclk_i)
begin
if (m_axi_s2mm_aclk_i'event and m_axi_s2mm_aclk_i = '1') then
     if (m_axi_s2mm_aresetn = '0') then
       fetch_more_s2mm <= '0';
     elsif (fetch_more_int = '1') then
        fetch_more_s2mm <= not fetch_more_s2mm;
     end if;
end if;
end process;

FETCH_MORE_CDC : entity  lib_cdc_v1_0_2.cdc_sync
    generic map (
        C_CDC_TYPE                 => 1,
        C_RESET_STATE              => 0,
        C_SINGLE_BIT               => 1,
        C_VECTOR_WIDTH             => 32,
        C_MTBF_STAGES              => 2 --MTBF_STAGES
    )
    port map (
        prmry_aclk                 => '0',
        prmry_resetn               => '0',
        prmry_in                   => fetch_more_s2mm,
        prmry_vect_in              => (others => '0'),

        scndry_aclk                => axi_sg_aclk,
        scndry_resetn              => '0',
        scndry_out                 => fetch_more_s2mm_cdc3,
        scndry_vect_out            => open
    );

process (axi_sg_aclk)
begin
if (axi_sg_aclk'event and axi_sg_aclk = '1') then
    fetch_more_s2mm_cdc2 <= fetch_more_s2mm_cdc3;
end if;
end process;

fetch_more <= fetch_more_s2mm_cdc2 xor fetch_more_s2mm_cdc3;

--end of async
end generate ASYNC_EOF_FETCH;


-- sync
SYNC_EOF_FETCH : if C_PRMRY_IS_ACLK_ASYNC = 0 generate
begin


process (axi_sg_aclk)
begin
if (axi_sg_aclk'event and axi_sg_aclk = '1') then
     if (dm_s2mm_scndry_resetn = '0' or eof_detected = '1' or fetch_more = '1') then
         cmd_btt_valid_int <= '0';
     elsif (s_axis_s2mm_cmd_tvalid = '1' and s_axis_s2mm_cmd_tready = '1') then
         cmd_btt_valid_int <= '1';
     end if;
end if;
end process;


process (axi_sg_aclk)
begin
if (axi_sg_aclk'event and axi_sg_aclk = '1') then
     if (dm_s2mm_scndry_resetn = '0' or eof_detected_int = '1' ) then
         cmd_btt_s2mm_cumul <= (others => '0');
     elsif (s_axis_s2mm_cmd_tvalid = '1' and s_axis_s2mm_cmd_tready = '1') then
         cmd_btt_s2mm_cumul <= std_logic_vector (unsigned(cmd_btt_s2mm_cumul(25 downto 0)) + unsigned(s_axis_s2mm_cmd_tdata (25 downto 0)));
     end if;
end if;
end process;

btt_rst <= not dm_s2mm_scndry_resetn;
cmd_btt_sg_valid <= s_axis_s2mm_cmd_tvalid and s_axis_s2mm_cmd_tready;

cmd_btt_valid <= cmd_btt_valid_int;
cmd_btt <= cmd_btt_int;
eof_detected <= eof_detected_int;
fetch_more <= fetch_more_int;

--            BTT_FIFO : entity lib_srl_fifo_v1_0_2.srl_fifo_f
--              generic map(
-- -               C_DWIDTH        => 23                              ,
--                C_DEPTH         => 4                                               ,
--                C_FAMILY        => C_FAMILY
--                )
--              port map(
--                Clk             => axi_sg_aclk                                  ,
--                Reset           => btt_rst, --xb_fifo_reset                                    ,
--                FIFO_Write      => cmd_btt_sg_valid                                     ,
--                Data_In         => s_axis_s2mm_cmd_tdata (22 downto 0)                                       ,
--                FIFO_Read       => cmd_fifo_pop                                  ,
--                Data_Out        => cmd_btt_cmp, --s2mm_xferd_bytes                                 ,
--                FIFO_Empty      => btt_fifo_empty                                             ,
--                FIFO_Full       => open, --xb_fifo_full                                     ,
--                Addr            => open
--                );

-- end of sync

end generate SYNC_EOF_FETCH;

process (m_axi_s2mm_aclk_i)
begin
if (m_axi_s2mm_aclk_i'event and m_axi_s2mm_aclk_i = '1') then
     if (m_axi_s2mm_aresetn = '0') then -- or fetch_more_int = '1') then
         byte_counter <= (others => '0');
     elsif (tlast_del = '1' and tvalid_to_datamover = '1' and tready_from_datamover = '1') then
       --  byte_counter <= std_logic_vector(to_unsigned(23,strb_bytes_set(7 downto 0))); 
         byte_counter <= "000000000000000000" & strb_bytes_set(7 downto 0);
     elsif (tlast_del = '1') then
         byte_counter <= (others => '0');
     elsif (tvalid_to_datamover = '1' and tready_from_datamover = '1') then
         byte_counter <= std_logic_vector(unsigned(byte_counter(25 downto 0)) +unsigned(strb_bytes_set(7 downto 0)));
     end if;
end if;
end process;


process (m_axi_s2mm_aclk_i)
begin
if (m_axi_s2mm_aclk_i'event and m_axi_s2mm_aclk_i = '1') then
     if (m_axi_s2mm_aresetn = '0') then
         tlast_del <= '0';
     else
         tlast_del <= tvalid_to_datamover and s_axis_s2mm_tlast_dm and tready_from_datamover;
     end if;

end if;
end process;

--in s2mm clock

eof_detected_int <= '1' when ((cmd_btt_s2mm_cumul >= cmd_btt_calc_cmp) and btt_calc_fifo_empty = '0' and cmd_btt_valid = '1') else '0'; -- tlast detected within btt range
fetch_more_int <= '1' when ((cmd_btt_s2mm_cumul < byte_counter) and cmd_btt_valid = '1') else 
                  '1' when ((cmd_btt_s2mm_cumul < cmd_btt_calc_cmp) and btt_calc_fifo_empty = '0' and cmd_btt_valid = '1') else '0';    -- tlast not detected withing btt range


--eof_detected_int <= '1' when ((cmd_btt_calc_cmp <= cmd_btt_cmp) and calc_fifo_pop = '1') else '0'; -- tlast detected within btt range
--fetch_more_int <= '1' when (tlast_del = '0' and (byte_counter = cmd_btt_cmp) and btt_fifo_empty = '0') else '0';    -- tlast not detected withing btt range

cmd_fifo_pop <= fetch_more_int or (not btt_calc_fifo_empty and (not btt_fifo_empty));
calc_fifo_pop <= eof_detected_int and (not btt_calc_fifo_empty);

            BTT_CALC_FIFO : entity lib_srl_fifo_v1_0_2.srl_fifo_f
              generic map(
                C_DWIDTH        => 26                              ,
                C_DEPTH         => 4                                               ,
                C_FAMILY        => C_FAMILY
                )
              port map(
                Clk             => m_axi_s2mm_aclk_i                                  ,
                Reset           => btt_rst, --xb_fifo_reset                                    ,
                FIFO_Write      => tlast_del,
                Data_In         => byte_counter,
                FIFO_Read       => calc_fifo_pop                                  ,
                Data_Out        => cmd_btt_calc_cmp, --s2mm_xferd_bytes                                 ,
                FIFO_Empty      => btt_calc_fifo_empty                                             ,
                FIFO_Full       => open, --xb_fifo_full                                     ,
                Addr            => open
                );


end generate INCLUDE_S2MM_SOF_EOF_GENERATOR;

-- If S2MM channel not included then exclude sof/eof generator
EXCLUDE_S2MM_SOF_EOF_GENERATOR : if C_INCLUDE_S2MM = 0 generate
begin
    s2mm_packet_sof <= '0';
    s2mm_packet_eof <= '0';
    s2mm_ch_packet_sof <= (others => '0');
    s2mm_ch_packet_eof <= (others => '0');
    s2mm_new_curdesc_wren     <= '0';
	tvalid_to_datamover <= '0';
	s2mm_desc_flush		<= '0';
	s2mm_error		<= '0';
	s_axis_s2mm_cmd_tvalid	<= '0';	
	s_axis_s2mm_cmd_tdata	<= (others => '0');	
	m_axis_s2mm_sts_tready	<= '0';	
	s_axis_s2mm_tlast_dm	<= '0';	
	s_axis_s2mm_tdata_dm	<= (others => '0');	
	s_axis_s2mm_tkeep_dm	<= (others => '0');	

end generate EXCLUDE_S2MM_SOF_EOF_GENERATOR;


-------------------------------------------------------------------------------
-- Primary MM2S and S2MM DataMover
-------------------------------------------------------------------------------
I_PRMRY_DATAMOVER : entity axi_datamover_v5_1_29.axi_datamover
    generic map(
        C_INCLUDE_MM2S              => MM2S_AXI_FULL_MODE,
        C_M_AXI_MM2S_ADDR_WIDTH     => ADDR_WIDTH,
        C_M_AXI_MM2S_DATA_WIDTH     => C_M_AXI_MM2S_DATA_WIDTH,
        C_M_AXIS_MM2S_TDATA_WIDTH   => C_M_AXIS_MM2S_TDATA_WIDTH,
        C_INCLUDE_MM2S_STSFIFO      => DM_INCLUDE_STS_FIFO,
        C_MM2S_STSCMD_FIFO_DEPTH    => DM_CMDSTS_FIFO_DEPTH_1,
        C_MM2S_STSCMD_IS_ASYNC      => C_PRMRY_IS_ACLK_ASYNC,
        C_INCLUDE_MM2S_DRE          => C_INCLUDE_MM2S_DRE,
        C_MM2S_BURST_SIZE           => C_MM2S_BURST_SIZE,
        C_MM2S_BTT_USED             => DM_BTT_LENGTH_WIDTH,
        C_MM2S_ADDR_PIPE_DEPTH      => DM_ADDR_PIPE_DEPTH,
        C_MM2S_INCLUDE_SF           => DM_MM2S_INCLUDE_SF,

        C_ENABLE_CACHE_USER         => 0, --C_ENABLE_MULTI_CHANNEL,
        C_ENABLE_SKID_BUF           => skid_enable, --"11111",
        C_MICRO_DMA                 => 0,
        C_CMD_WIDTH                 => CMD_WIDTH,

        C_INCLUDE_S2MM              => S2MM_AXI_FULL_MODE,
        C_M_AXI_S2MM_ADDR_WIDTH     => ADDR_WIDTH,
        C_M_AXI_S2MM_DATA_WIDTH     => C_M_AXI_S2MM_DATA_WIDTH,
        C_S_AXIS_S2MM_TDATA_WIDTH   => C_S_AXIS_S2MM_TDATA_WIDTH,
        C_INCLUDE_S2MM_STSFIFO      => DM_INCLUDE_STS_FIFO,
        C_S2MM_STSCMD_FIFO_DEPTH    => DM_CMDSTS_FIFO_DEPTH_1,
        C_S2MM_STSCMD_IS_ASYNC      => C_PRMRY_IS_ACLK_ASYNC,
        C_INCLUDE_S2MM_DRE          => C_INCLUDE_S2MM_DRE,
        C_S2MM_BURST_SIZE           => C_S2MM_BURST_SIZE,
        C_S2MM_BTT_USED             => DM_BTT_LENGTH_WIDTH,
        C_S2MM_SUPPORT_INDET_BTT    => DM_SUPPORT_INDET_BTT,
        C_S2MM_ADDR_PIPE_DEPTH      => DM_ADDR_PIPE_DEPTH,
        C_S2MM_INCLUDE_SF           => DM_S2MM_INCLUDE_SF,
        C_FAMILY                    => C_FAMILY,
        C_MCDMA                     => 1
    )
    port map(
        -- MM2S Primary Clock / Reset input
        m_axi_mm2s_aclk             => m_axi_mm2s_aclk_i                      ,
        m_axi_mm2s_aresetn          => m_axi_mm2s_aresetn                   ,
    
        mm2s_halt                   => mm2s_halt                            ,
        mm2s_halt_cmplt             => mm2s_halt_cmplt                      ,
        mm2s_err                    => mm2s_err                             ,
        mm2s_allow_addr_req         => ALWAYS_ALLOW                         ,
        mm2s_addr_req_posted        => open                                 ,
        mm2s_rd_xfer_cmplt          => open                                 ,
   
        -- Memory Map to Stream Command FIFO and Status FIFO I/O --------------
        m_axis_mm2s_cmdsts_aclk     => axi_sg_aclk                          ,
        m_axis_mm2s_cmdsts_aresetn  => dm_mm2s_scndry_resetn                ,

        -- User Command Interface Ports (AXI Stream)
        s_axis_mm2s_cmd_tvalid      => s_axis_mm2s_cmd_tvalid               ,
        s_axis_mm2s_cmd_tready      => s_axis_mm2s_cmd_tready               ,
        s_axis_mm2s_cmd_tdata       => s_axis_mm2s_cmd_tdata                ,

        -- User Status Interface Ports (AXI Stream)
        m_axis_mm2s_sts_tvalid      => m_axis_mm2s_sts_tvalid               ,
        m_axis_mm2s_sts_tready      => m_axis_mm2s_sts_tready               ,
        m_axis_mm2s_sts_tdata       => m_axis_mm2s_sts_tdata                ,
        m_axis_mm2s_sts_tkeep       => m_axis_mm2s_sts_tkeep                ,
        m_axis_mm2s_sts_tlast       => open                                 ,

        -- MM2S AXI Address Channel I/O  --------------------------------------
        m_axi_mm2s_arid             => open                                 ,
        m_axi_mm2s_araddr           => m_axi_mm2s_araddr_internal                    ,
        m_axi_mm2s_arlen            => m_axi_mm2s_arlen                     ,
        m_axi_mm2s_arsize           => m_axi_mm2s_arsize                    ,
        m_axi_mm2s_arburst          => m_axi_mm2s_arburst                   ,
        m_axi_mm2s_arprot           => m_axi_mm2s_arprot                    ,
        m_axi_mm2s_arcache          => open, --m_axi_mm2s_arcache                   ,
        m_axi_mm2s_aruser           => open, --m_axi_mm2s_aruser                   ,
        m_axi_mm2s_arvalid          => m_axi_mm2s_arvalid                   ,
        m_axi_mm2s_arready          => m_axi_mm2s_arready                   ,

        -- MM2S AXI MMap Read Data Channel I/O  -------------------------------
        m_axi_mm2s_rdata            => m_axi_mm2s_rdata                     ,
        m_axi_mm2s_rresp            => m_axi_mm2s_rresp                     ,
        m_axi_mm2s_rlast            => m_axi_mm2s_rlast                     ,
        m_axi_mm2s_rvalid           => m_axi_mm2s_rvalid                    ,
        m_axi_mm2s_rready           => m_axi_mm2s_rready                    ,

        -- MM2S AXI Master Stream Channel I/O  --------------------------------
        m_axis_mm2s_tdata           => m_axis_mm2s_tdata                    ,
        m_axis_mm2s_tkeep           => m_axis_mm2s_tkeep                    ,
        m_axis_mm2s_tlast           => m_axis_mm2s_tlast_i                  ,
        m_axis_mm2s_tvalid          => m_axis_mm2s_tvalid_i                 ,
        m_axis_mm2s_tready          => m_axis_mm2s_tready                   ,

        -- Testing Support I/O
        mm2s_dbg_sel                => (others => '0')                      ,
        mm2s_dbg_data               => open                                 ,

        -- S2MM Primary Clock/Reset input
        m_axi_s2mm_aclk             => m_axi_s2mm_aclk_i                      ,
        m_axi_s2mm_aresetn          => m_axi_s2mm_aresetn                   ,
        s2mm_halt                   => s2mm_halt                            ,
        s2mm_halt_cmplt             => s2mm_halt_cmplt                      ,
        s2mm_err                    => s2mm_err                             ,
        s2mm_allow_addr_req         => ALWAYS_ALLOW                         ,
        s2mm_addr_req_posted        => open                                 ,
        s2mm_wr_xfer_cmplt          => open                                 ,
        s2mm_ld_nxt_len             => open                                 ,
        s2mm_wr_len                 => open                                 ,

        -- Stream to Memory Map Command FIFO and Status FIFO I/O --------------
        m_axis_s2mm_cmdsts_awclk    => axi_sg_aclk                          ,
        m_axis_s2mm_cmdsts_aresetn  => dm_s2mm_scndry_resetn                ,

        -- User Command Interface Ports (AXI Stream)
        s_axis_s2mm_cmd_tvalid      => s_axis_s2mm_cmd_tvalid               ,
        s_axis_s2mm_cmd_tready      => s_axis_s2mm_cmd_tready               ,
        s_axis_s2mm_cmd_tdata       => s_axis_s2mm_cmd_tdata                ,

        -- User Status Interface Ports (AXI Stream)
        m_axis_s2mm_sts_tvalid      => m_axis_s2mm_sts_tvalid           ,
        m_axis_s2mm_sts_tready      => m_axis_s2mm_sts_tready               ,
        m_axis_s2mm_sts_tdata       => m_axis_s2mm_sts_tdata            ,
        m_axis_s2mm_sts_tkeep       => m_axis_s2mm_sts_tkeep                ,
        m_axis_s2mm_sts_tlast       => open                                 ,

        -- S2MM AXI Address Channel I/O  --------------------------------------
        m_axi_s2mm_awid             => open                                 ,
        m_axi_s2mm_awaddr           => m_axi_s2mm_awaddr_internal                    ,
        m_axi_s2mm_awlen            => m_axi_s2mm_awlen                     ,
        m_axi_s2mm_awsize           => m_axi_s2mm_awsize                    ,
        m_axi_s2mm_awburst          => m_axi_s2mm_awburst                   ,
        m_axi_s2mm_awprot           => m_axi_s2mm_awprot                    ,
        m_axi_s2mm_awcache          => open, --m_axi_s2mm_awcache                   ,
        m_axi_s2mm_awuser           => open, --m_axi_s2mm_awuser                    ,
        m_axi_s2mm_awvalid          => m_axi_s2mm_awvalid                   ,
        m_axi_s2mm_awready          => m_axi_s2mm_awready                   ,

        -- S2MM AXI MMap Write Data Channel I/O  ------------------------------
        m_axi_s2mm_wdata            => m_axi_s2mm_wdata                     ,
        m_axi_s2mm_wstrb            => m_axi_s2mm_wstrb                     ,
        m_axi_s2mm_wlast            => m_axi_s2mm_wlast                     ,
        m_axi_s2mm_wvalid           => m_axi_s2mm_wvalid                    ,
        m_axi_s2mm_wready           => m_axi_s2mm_wready                    ,

        -- S2MM AXI MMap Write response Channel I/O  --------------------------
        m_axi_s2mm_bresp            => m_axi_s2mm_bresp                     ,
        m_axi_s2mm_bvalid           => m_axi_s2mm_bvalid                    ,
        m_axi_s2mm_bready           => m_axi_s2mm_bready                    ,

        -- S2MM AXI Slave Stream Channel I/O  ---------------------------------
        s_axis_s2mm_tdata           => s_axis_s2mm_tdata_dm                    ,
        s_axis_s2mm_tkeep           => s_axis_s2mm_tkeep_dm                    ,
        s_axis_s2mm_tlast           => s_axis_s2mm_tlast_dm                    , 
        s_axis_s2mm_tvalid          => tvalid_to_datamover, --s_axis_s2mm_tvalid                   , 
        s_axis_s2mm_tready          => tready_from_datamover, --s_axis_s2mm_tready_i                 ,

        -- Testing Support I/O
        s2mm_dbg_sel                  => "0001"                    ,
        s2mm_dbg_data                 => s2mm_dbg_dm
    );




end implementation;


