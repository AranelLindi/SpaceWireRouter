diff --git a/trunk/rtl/vhdl/routertest_deprecated.vhd b/trunk/rtl/vhdl/routertest_deprecated.vhd
new file mode 100644
index 0000000..a4f304b
--- /dev/null
+++ b/trunk/rtl/vhdl/routertest_deprecated.vhd
@@ -0,0 +1,386 @@
+----------------------------------------------------------------------------------
+-- Company: University of Wuerzburg, Germany
+-- Engineer: Stefan Lindoerfer
+-- 
+-- Create Date: 03.09.2021 17:54
+-- Design Name: SpaceWire Router Testbench
+-- Module Name: spwroutertest
+-- Project Name: Bachelor Thesis: Implementation of a SpaceWire Router on a FPGA
+-- Target Devices: 
+-- Tool Versions: 
+-- Description: 
+--
+-- Dependencies: spwpkg, spwrouterpkg
+-- 
+-- Revision:
+----------------------------------------------------------------------------------
+
+LIBRARY IEEE;
+USE IEEE.Std_logic_1164.ALL;
+USE IEEE.Numeric_Std.ALL;
+USE work.spwpkg.ALL;
+USE work.spwrouterpkg.ALL;
+
+ENTITY routertest IS
+	GENERIC (
+		-- Number of SpaceWire ports.
+		numports : INTEGER RANGE 0 TO 31;
+
+		-- System clock frequency in Hz.
+		-- This must be set to the frequency of "clk". It is used to setup
+		-- counters for reset timing, disconnect timeout and to transmit
+		-- at 10 Mbit/s during the link handshake.
+		sysfreq : real;
+
+		-- Transmit clock frequency in Hz (only if tximpl = impl_fast).
+		-- This must be set to the frequency of "txclk". It is used to
+		-- transmit at 10 Mbit/s during the link handshake.
+		txclkfreq : real := 0.0;
+
+		-- Selection of a receiver front-end implementation.
+		rximpl : spw_implementation_type_rec;
+
+		-- Maximum number of bits received per system clock
+		-- (must be 1 in case of impl_generic).
+		rxchunk : INTEGER RANGE 1 TO 4 := 1;
+
+		-- Width of shift registers in clock recovery front-end; added: SL
+		WIDTH : INTEGER RANGE 1 TO 3 := 2;
+
+		-- Selection of a transmitter implementation.
+		tximpl : spw_implementation_type_xmit;
+
+		-- Size of the receive FIFO as the 2-logarithm of the number of bytes.
+		-- Must be at least 6 (64 bytes).
+		rxfifosize_bits : INTEGER RANGE 6 TO 14 := 11;
+
+		-- Size of the transmit FIFO as the 2-logarithm of the number of bytes.
+		txfifosize_bits : INTEGER RANGE 2 TO 14 := 11
+	);
+	PORT (
+		-- System clock.
+		clk : IN STD_LOGIC;
+
+		-- Receiver sample clock (only for impl_fast)
+		rxclk : IN STD_LOGIC;
+
+		-- Transmit clock (only for impl_fast)
+		txclk : IN STD_LOGIC;
+
+		-- Synchronous reset (active-high).
+		rst : IN STD_LOGIC;
+
+		-- Enables automatic link start on receipt of a NULL character.
+		autostart : IN STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+		-- Enables link start once the Ready state is reached.
+		-- Without autostart or linkstart, the link remains in state Ready.
+		linkstart : IN STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+		-- Do not start link (overrides linkstart and autostart) and/or
+		-- disconnect a running link.
+		linkdis : IN STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+		-- Scaling factor minus 1, used to scale the transmit base clock into
+		-- the transmission bit rate. The system clock (for impl_generic) or
+		-- the txclk (for impl_fast) is divided by (unsigned(txdivcnt) + 1).
+		-- Changing this signal will immediately change the transmission rate.
+		-- During link setup, the transmission rate is always 10 Mbit/s.
+		txdivcnt : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
+
+		-- High for one clock cycle to request transmission of a TimeCode.
+		-- The request is registered inside the entity until it can be processed.
+		tick_in : IN STD_LOGIC_VECTOR(numports DOWNTO 1);
+
+		-- Control bits of the TimeCode to be sent. Must be valid while tick_in is high.
+		ctrl_in : IN array_t(numports DOWNTO 1)(1 DOWNTO 0);
+
+		-- Counter value of the TimeCode to be sent. Must be valid while tick_in is high.
+		time_in : IN array_t(numports DOWNTO 1)(5 DOWNTO 0);
+
+		-- Pulled high by the application to write an N-Char to the transmit
+		-- queue. If "txwrite" and "txrdy" are both high on the rising edge
+		-- of "clk", a character is added to the transmit queue.
+		-- This signal has no effect if "txrdy" is low.
+		txwrite : IN STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+		-- Control flag to be sent with the next N_Char.
+		-- Must be valid while txwrite is high.
+		txflag : IN STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+		-- Byte to be sent, or "00000000" for EOP or "00000001" for EEP.
+		-- Must be valid while txwrite is high.
+		txdata : IN array_t(numports DOWNTO 0)(7 DOWNTO 0);
+
+		-- High if the entity is ready to accept an N-Char for transmission.
+		txrdy : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+		-- High if the transmission queue is at least half full.
+		txhalff : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+		-- High for one clock cycle if a TimeCode was just received.
+		tick_out : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+		-- Control bits of the last received TimeCode.
+		ctrl_out : OUT array_t(numports DOWNTO 1)(1 DOWNTO 0);
+
+		-- Counter value of the last received TimeCode.
+		time_out : OUT array_t(numports DOWNTO 1)(5 DOWNTO 0);
+
+		-- High if "rxflag" and "rxdata" contain valid data.
+		-- This signal is high unless the receive FIFO is empty.
+		rxvalid : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+		-- High if the receive FIFO is at least half full.
+		rxhalff : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+		-- High if the received character is EOP or EEP; low if the received
+		-- character is a data byte. Valid if "rxvalid" is high.
+		rxflag : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+		-- Received byte, or "00000000" for EOP or "00000001" for EEP.
+		-- Valid if "rxvalid" is high.
+		rxdata : OUT array_t(numports DOWNTO 0)(7 DOWNTO 0);
+
+		-- Pulled high by the application to accept a received character.
+		-- If "rxvalid" and "rxread" are both high on the rising edge of "clk",
+		-- a character is removed from the receive FIFO and "rxvalid", "rxflag"
+		-- and "rxdata" are updated.
+		-- This signal has no effect if "rxvalid" is low.
+		rxread : IN STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+		-- High if the link state machine is currently in the Started state.
+		-- (p) = external Ports; (r) = Router ports
+		pstarted : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+		rstarted : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+		-- High if the link state machine is currently in the Connecting state.
+		-- (p) = external Ports; (r) = Router ports
+		pconnecting : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+		rconnecting : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+		-- High if the link state machine is currently in the Run state, indicating
+		-- that the link is fully operational. If none of started, connecting or running
+		-- is high, the link is in an initial state and the transmitter is not yet enabled.
+		-- (p) = external Ports; (r) = Router ports
+		prunning : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+		rrunning : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+		-- Disconnect detected in state Run. Triggers a reset and reconnect of the link.
+		-- This indication is auto-clearing.
+		-- (p) = external Ports; (r) = Router ports
+		perrdisc : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+		rerrdisc : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+		-- Parity error detected in state Run. Triggers a reset and reconnect of the link.
+		-- This indication is auto-clearing.
+		-- (p) = external Ports; (r) = Router ports
+		perrpar : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+		rerrpar : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+		-- Invalid escape sequence detected in state Run. Triggers a reset and reconnect of
+		-- the link. This indication is auto-clearing.
+		-- (p) = external Ports; (r) = Router ports
+		perresc : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+		rerresc : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+		-- Credit error detected. Triggers a reset and reconnect of the link.
+		-- This indication is auto-clearing.
+		-- (p) = external Ports; (r) = Router ports
+		perrcred : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+		rerrcred : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+		
+		-- Data In signal from SpaceWire bus.
+		spw_d_r2p : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+		-- Strobe In signal from SpaceWire bus.
+		--spw_s_r2p : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+		-- Data Out signal to SpaceWire bus.
+		spw_d_p2r : OUT STD_LOGIC_VECTOR(numports DOWNTO 0)
+
+		-- Strobe Out signal to SpaceWire bus.
+		--spw_s_p2r : OUT STD_LOGIC_VECTOR(numports DOWNTO 0)
+	);
+END routertest;
+
+ARCHITECTURE routertest_arch OF routertest IS
+	-- Signals from router.
+	SIGNAL s_spw_di : STD_LOGIC_VECTOR(numports DOWNTO 0);
+	SIGNAL s_spw_si : STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+	-- Signals to router.
+	SIGNAL s_spw_do : STD_LOGIC_VECTOR(numports DOWNTO 0);
+	SIGNAL s_spw_so : STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+	-- Router status signals.
+	SIGNAL s_rstarted : STD_LOGIC_VECTOR(numports DOWNTO 0);
+	SIGNAL s_rconnecting : STD_LOGIC_VECTOR(numports DOWNTO 0);
+	SIGNAL s_rrunning : STD_LOGIC_VECTOR(numports DOWNTO 0);
+	SIGNAL s_rerrdisc : STD_LOGIC_VECTOR(numports DOWNTO 0);
+	SIGNAL s_rerrpar : STD_LOGIC_VECTOR(numports DOWNTO 0);
+	SIGNAL s_rerresc : STD_LOGIC_VECTOR(numports DOWNTO 0);
+	SIGNAL s_rerrcred : STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+	-- Port status signals.
+	SIGNAL s_pstarted : STD_LOGIC_VECTOR(numports DOWNTO 0);
+	SIGNAL s_pconnecting : STD_LOGIC_VECTOR(numports DOWNTO 0);
+	SIGNAL s_prunning : STD_LOGIC_VECTOR(numports DOWNTO 0);
+	SIGNAL s_perrdisc : STD_LOGIC_VECTOR(numports DOWNTO 0);
+	SIGNAL s_perrpar : STD_LOGIC_VECTOR(numports DOWNTO 0);
+	SIGNAL s_perresc : STD_LOGIC_VECTOR(numports DOWNTO 0);
+	SIGNAL s_perrcred : STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+BEGIN
+	-- Signals from router to ports. (for debugging only)
+	--spw_d_r2p <= s_spw_di;
+	--spw_s_r2p <= s_spw_si;
+	-- Signals from ports to router.
+	--spw_d_p2r <= s_spw_do;
+	--spw_s_p2r <= s_spw_so;
+
+	-- Status/errors for router and ports.
+	rstarted <= s_rstarted;
+	pstarted <= s_pstarted;
+	rconnecting <= s_rconnecting;
+	pconnecting <= s_pconnecting;
+	rrunning <= s_rrunning;
+	prunning <= s_prunning;
+	rerrdisc <= s_rerrdisc;
+	perrdisc <= s_perrdisc;
+	rerrpar <= s_rerrpar;
+	perrpar <= s_perrpar;
+	rerresc <= s_rerresc;
+	perresc <= s_perresc;
+	rerrcred <= s_rerrcred;
+	perrcred <= s_perrcred;
+
+	-- Port 0
+	ExternPort0 : spwstream
+	GENERIC MAP(
+		sysfreq => sysfreq,
+		txclkfreq => txclkfreq,
+		rximpl => rximpl,
+		rxchunk => rxchunk,
+		WIDTH => WIDTH,
+		tximpl => tximpl,
+		rxfifosize_bits => rxfifosize_bits,
+		txfifosize_bits => txfifosize_bits
+	)
+	PORT MAP(
+		clk => clk,
+		rxclk => rxclk,
+		txclk => txclk,
+		rst => rst,
+		autostart => autostart(0),
+		linkstart => linkstart(0),
+		linkdis => linkdis(0),
+		txdivcnt => txdivcnt,
+		tick_in => '0',
+		ctrl_in => (OTHERS => '0'),
+		time_in => (OTHERS => '0'),
+		txwrite => txwrite(0),
+		txflag => txflag(0),
+		txdata => txdata(0),
+		txrdy => txrdy(0),
+		txhalff => txhalff(0),
+		tick_out => OPEN,
+		ctrl_out => OPEN,
+		time_out => OPEN,
+		rxvalid => rxvalid(0),
+		rxhalff => rxhalff(0),
+		rxflag => rxflag(0),
+		rxdata => rxdata(0),
+		rxread => rxread(0),
+		started => s_pstarted(0),
+		connecting => s_pconnecting(0),
+		running => s_prunning(0),
+		errdisc => s_perrdisc(0),
+		errpar => s_perrpar(0),
+		erresc => s_perresc(0),
+		errcred => s_perrcred(0),
+		spw_di => s_spw_di(0), -- from router
+		spw_si => s_spw_si(0), -- from router
+		spw_do => s_spw_do(0), -- to router
+		spw_so => s_spw_so(0) -- to router
+	);
+
+	-- Port 1 to numports
+	ExternPortX : FOR i IN 1 TO numports GENERATE
+		ePortX : spwstream
+		GENERIC MAP(
+			sysfreq => sysfreq,
+			txclkfreq => txclkfreq,
+			rximpl => rximpl,
+			rxchunk => rxchunk,
+			tximpl => tximpl,
+			rxfifosize_bits => rxfifosize_bits,
+			txfifosize_bits => txfifosize_bits,
+			WIDTH => WIDTH
+		)
+		PORT MAP(
+			clk => clk,
+			rxclk => rxclk,
+			txclk => txclk,
+			rst => rst,
+			autostart => autostart(i),
+			linkstart => linkstart(i),
+			linkdis => linkdis(i),
+			txdivcnt => txdivcnt,
+			tick_in => tick_in(i),
+			ctrl_in => ctrl_in(i),
+			time_in => time_in(i),
+			txwrite => txwrite(i),
+			txflag => txflag(i),
+			txdata => txdata(i),
+			txrdy => txrdy(i),
+			txhalff => txhalff(i),
+			tick_out => tick_out(i),
+			ctrl_out => ctrl_out(i),
+			time_out => time_out(i),
+			rxvalid => rxvalid(i),
+			rxhalff => rxhalff(i),
+			rxflag => rxflag(i),
+			rxdata => rxdata(i),
+			rxread => rxread(i),
+			started => s_pstarted(i),
+			connecting => s_pconnecting(i),
+			running => s_prunning(i),
+			errdisc => s_perrdisc(i),
+			errpar => s_perrpar(i),
+			erresc => s_perresc(i),
+			errcred => s_perrcred(i),
+			spw_di => s_spw_di(i), -- from router
+			spw_si => s_spw_si(i),
+			spw_do => s_spw_do(i), -- to router
+			spw_so => s_spw_so(i)
+		);
+	END GENERATE ExternPortX;
+
+	-- SpaceWire router.
+	Router : spwrouter
+	GENERIC MAP(
+		numports => numports,
+		sysfreq => sysfreq,
+		txclkfreq => txclkfreq,
+		rx_impl => (OTHERS => rximpl),
+		tx_impl => (OTHERS => tximpl)
+	)
+	PORT MAP(
+		clk => clk,
+		rxclk => rxclk,
+		txclk => txclk,
+		rst => rst,
+		started => s_rstarted,
+		connecting => s_rconnecting,
+		running => s_rrunning,
+		errdisc => s_rerrdisc,
+		errpar => s_rerrpar,
+		erresc => s_rerresc,
+		errcred => s_rerrcred,
+		spw_di => s_spw_do,
+		spw_si => s_spw_so,
+		spw_do => s_spw_di,
+		spw_so => s_spw_si
+	);
+END routertest_arch;
\ No newline at end of file
diff --git a/trunk/rtl/vhdl/spwrouter.vhd b/trunk/rtl/vhdl/spwrouter.vhd
index 3e0cdbb..9c72584 100644
--- a/trunk/rtl/vhdl/spwrouter.vhd
+++ b/trunk/rtl/vhdl/spwrouter.vhd
@@ -5,12 +5,13 @@
 -- Create Date: 31.07.2021 12:53
 -- Design Name: SpaceWire Router Top Module
 -- Module Name: spwrouter
--- Project Name: Bachelor Thesis: Implementation of a SpaceWire Router on an FPGA
+-- Project Name: Bachelor Thesis: Implementation of a SpaceWire Router on a FPGA
 -- Target Devices: 
 -- Tool Versions: 
--- Description: Top router entity.
+-- Description: Complete router implementation which contains all necessary entities.
+-- (Active autostart but no linkstart! Router is waiting for an attemption of an incoming connection)
 --
--- Dependencies: spwstream (spwpkg), spwrouterpkg
+-- Dependencies: none
 -- 
 -- Revision:
 ----------------------------------------------------------------------------------
@@ -25,19 +26,19 @@ USE WORK.SPWPKG.ALL;
 ENTITY spwrouter IS
     GENERIC (
         -- Number of SpaceWire ports.
-        numports : INTEGER RANGE 0 TO 31;
+        numports : INTEGER RANGE 0 TO 31 := 2;
 
         -- System clock frequency in Hz.
-        sysfreq : real;
+        sysfreq : real := 10.0e6;
 
         -- txclk frequency in Hz (if tximpl = impl_fast)
-        txclkfreq : real;
+        txclkfreq : real := 10.0e6;
 
         -- Selection of receiver front-end implementation.
-        rx_impl : rximpl_array(numports DOWNTO 0);-- := (OTHERS => impl_fast);
+        rx_impl : rximpl_array(numports DOWNTO 0) := (others => impl_fast);
 
         -- Selection of transmitter implementation.
-        tx_impl : tximpl_array(numports DOWNTO 0)-- := (OTHERS => impl_fast)
+        tx_impl : tximpl_array(numports DOWNTO 0) := (others => impl_fast)
     );
     PORT (
         -- System clock.
@@ -88,344 +89,311 @@ ENTITY spwrouter IS
 END spwrouter;
 
 ARCHITECTURE spwrouter_arch OF spwrouter IS
-    PACKAGE spwrouterfunc IS NEW work.spwrouterfunc
+    PACKAGE function_pkg IS NEW work.spwrouterfunc
         GENERIC MAP(numports => numports); -- Import package with various functions.
 
-        -- ====================================
-        -- General constants and signals.
-        -- ====================================
-        CONSTANT blen : INTEGER RANGE 0 TO 5 := INTEGER(ceil(log2(real(numports)))); -- Necessary number of bits to represent numport-ports
-
-
-        -- ====================================
-        -- TIME CODES (Bus I)
-        -- ====================================
-
-        -- Time Code specific signals.
-        -- Time codes are forwareded via a separate bus and always have hightest priority.
-        SIGNAL s_tick_from_tcc_to_ports : STD_LOGIC_VECTOR(numports DOWNTO 0); -- High for one clock cycle if transmission of Time Code is requested
-        SIGNAL s_tick_from_ports_to_tcc : STD_LOGIC_VECTOR(numports DOWNTO 0); -- High for one clock cycle if Time Code was received
-        SIGNAL s_tc_from_tcc_to_ports : array_t(numports DOWNTO 0)(7 DOWNTO 0); -- Time Code (control flag & counter value) of Time Code to sent
-        SIGNAL s_tc_from_ports_to_tcc : array_t(numports DOWNTO 0)(7 DOWNTO 0); -- Time Code (control flag & coutner value) of received Time Code
+        -- Necessary number of bits to represent numport-ports.
+        CONSTANT blen : INTEGER RANGE 0 TO 5 := INTEGER(ceil(log2(real(numports))));
+
+        SIGNAL iSelectDestinationPort : array_t(numports DOWNTO 0)(numports DOWNTO 0);
+        SIGNAL iSwitchPortNumber : array_t(numports DOWNTO 0)(numports DOWNTO 0);
+
+        SIGNAL requestOut : STD_LOGIC_VECTOR(numports DOWNTO 0);
+        SIGNAL destinationPort : array_t(numports DOWNTO 0)(7 DOWNTO 0);
+        SIGNAL sourcePortOut : array_t(numports DOWNTO 0)(blen DOWNTO 0);
+        SIGNAL granted : STD_LOGIC_VECTOR(numports DOWNTO 0);
+        SIGNAL iReadyIn : STD_LOGIC_VECTOR(numports DOWNTO 0);
+        SIGNAL dataOut : array_t(numports DOWNTO 0)(8 DOWNTO 0);
+        SIGNAL strobeOut : STD_LOGIC_VECTOR(numports DOWNTO 0);
+        SIGNAL iRequestIn : STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+        SIGNAL iDataIn : array_t(numports DOWNTO 0)(8 DOWNTO 0);
+        SIGNAL iStrobeIn : STD_LOGIC_VECTOR(numports DOWNTO 0);
+        SIGNAL readyOut : STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+        SIGNAL routingSwitch : array_t(numports DOWNTO 0)(numports DOWNTO 0);
+
+        SIGNAL routerTimeCode : STD_LOGIC_VECTOR(7 DOWNTO 0);
+
+        -- Bus System I.
+        SIGNAL busMasterAddressOut : array_t(numports DOWNTO 0)(31 DOWNTO 0);
+        SIGNAL busMasterDataOut : array_t(numports DOWNTO 0)(31 DOWNTO 0);
+        SIGNAL busMasterByteEnableOut : array_t(numports DOWNTO 0)(3 DOWNTO 0);
+        SIGNAL busMasterWriteEnableOut : STD_LOGIC_VECTOR(numports DOWNTO 0);
+        SIGNAL busMasterRequestOut : STD_LOGIC_VECTOR(numports DOWNTO 0);
+        SIGNAL busMasterGranted : STD_LOGIC_VECTOR(numports DOWNTO 0);
+        SIGNAL busMasterAcknowledgeIn : STD_LOGIC_VECTOR(numports DOWNTO 0);
+        SIGNAL busMasterStrobeOut : STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+        -- Bus System II.
+        SIGNAL iBusSlaveCycleIn : STD_LOGIC;
+        SIGNAL iBusSlaveStrobeIn : STD_LOGIC;
+        SIGNAL iBusSlaveAddressIn : STD_LOGIC_VECTOR(31 DOWNTO 0);
+        SIGNAL busSlaveDataOut : STD_LOGIC_VECTOR(31 DOWNTO 0);
+        SIGNAL iBusSlaveDataIn : STD_LOGIC_VECTOR(31 DOWNTO 0);
+        SIGNAL iBusSlaveAcknowledgeOut : STD_LOGIC;
+        SIGNAL iBusSlaveWriteEnableIn : STD_LOGIC;
+        SIGNAL iBusSlaveByteEnableIn : STD_LOGIC_VECTOR(3 DOWNTO 0);
+        SIGNAL iBusSlaveOriginalPortIn : STD_LOGIC_VECTOR(7 DOWNTO 0);
+
+        SIGNAL ibusMasterDataOut : STD_LOGIC_VECTOR(31 DOWNTO 0);
+
+        -- All ports that are in running state.
+        SIGNAL iLinkUp : STD_LOGIC_VECTOR(numports DOWNTO 0);
+
+        -- Time Codes.
+        SIGNAL s_tick_from_tcc_to_ports : std_logic_vector(numports downto 0); -- High for one clock cycle if transmission of Time Code is requested
+        signal s_tick_from_ports_to_tcc : std_logic_vector(numports downto 0); -- High for one clock cycle if Time Code was received
+        signal s_tc_from_tcc_to_ports : array_t(numports downto 0)(7 downto 0); -- Time Code (control flag & counter value) of Time Code to sent
+        signal s_tc_from_ports_to_tcc : array_t(numports downto 0)(7 downto 0); -- Time Code (control flag & coutner value) of received Time Code
 
         -- TimeCodes & Register.
-        SIGNAL s_auto_tc : STD_LOGIC_VECTOR(7 DOWNTO 0); -- autoTimeCodeValue
-        SIGNAL s_auto_cycle : STD_LOGIC_VECTOR(31 DOWNTO 0); -- autoTimeCodeCycle
-        SIGNAL s_last_tc : STD_LOGIC_VECTOR(7 DOWNTO 0); -- TODO: Noch nicht korrekt eingebunden, soll das zuletzt empfangene TC speichern.
-
-
-        -- ====================================
-        -- ARBITRATION (physical addressing, Bus II)
-        -- ====================================
-
-        -- Arbitration-specific signals (spwrouterarb).
-        SIGNAL s_routing_matrix_transposed : array_t(numports DOWNTO 0)(numports DOWNTO 0); -- Transposed routing_matrix from arbiter.
-        SIGNAL s_routing_matrix : array_t(numports DOWNTO 0)(numports DOWNTO 0); -- Routing switch matrix: Maps source ports (row) to target ports (column).
-        SIGNAL s_source_port_row : array_t(numports DOWNTO 0)(numports DOWNTO 0); -- Copy of routing_matrix.
-        SIGNAL s_request_out : STD_LOGIC_VECTOR(numports DOWNTO 0); -- requestOut -- High if a port transfers a packet.        
-        SIGNAL s_destination_port : array_t(numports DOWNTO 0)(7 DOWNTO 0); -- destinationPort -- First byte of a packet (address byte) with destination port (both physical and logical addressing).
-        --SIGNAL sourcePortOut : array_t(numports DOWNTO 0)(blen DOWNTO 0);
-        SIGNAL s_granted : STD_LOGIC_VECTOR(numports DOWNTO 0); -- granted -- Contains ports that have granted access to the port that is specified in destport.
-        -- SPACEWIRE PORTS
-        -- Port-specific signals (physical addressing only !).
-        -- Pysical addressing is controlled using a crossbar and a round robin arbiter. Acess to routing table is not necessary,
-        -- this type of addressing is processed faster than logical adressing.
-        SIGNAL s_ready_in : STD_LOGIC_VECTOR(numports DOWNTO 0); -- readyIn -- High if destination port is ready to accept next N-Char.
-        SIGNAL s_rxdata : array_t(numports DOWNTO 0)(8 DOWNTO 0); -- dataOut -- Received byte and control flag.
-        SIGNAL s_strobe_out : STD_LOGIC_VECTOR(numports DOWNTO 0); -- strobeOut -- High if data byte or EOP/EEP of one port is ready to transfer to destination port.
-        SIGNAL s_request_in : STD_LOGIC_VECTOR(numports DOWNTO 0); -- requestIn -- High as long as a packet is sent via one port.
-        SIGNAL s_txdata : array_t(numports DOWNTO 0)(8 DOWNTO 0); -- iDataIn -- Data byte and flag to transmit.
-        SIGNAL s_strobe_in : STD_LOGIC_VECTOR(numports DOWNTO 0); -- strobeIn -- High if transmission via one port should be performed (new byte still on txdata).
-        SIGNAL s_txrdy : STD_LOGIC_VECTOR(numports DOWNTO 0); -- readyOut -- High if port is ready to accept an N-Char for transmission FIFO.
-
-        SIGNAL s_running : STD_LOGIC_VECTOR(numports DOWNTO 0); -- Contains running-state of every port
-
-
-        -- ====================================
-        -- INTERNAL BUS (logical addressing & register, Bus III)
-        -- ====================================
-
-        -- Master (m) bus signals.
-        -- Each port acts as a master. An internal arbiter controls access to registers and routing table (logical addressing only !)
-        SIGNAL s_bus_m_address : array_t(numports DOWNTO 0)(31 DOWNTO 0); -- busMasterAddressOut -- Contains register destination address (routing table only) for each port
-        SIGNAL s_bus_m_data : array_t(numports DOWNTO 0)(31 DOWNTO 0); -- busMasterDataOut -- Contains data word to be written into register for each port (currently unused)
-        SIGNAL s_bus_m_dByte : array_t(numports DOWNTO 0)(3 DOWNTO 0); -- busMasterByteEnableOut -- Determines for each port which byte (1-4) is to be written into register or read from it
-        SIGNAL s_bus_m_readwrite : STD_LOGIC_VECTOR(numports DOWNTO 0); -- busMasterWriteEnableOut -- Determines for each port whether a read (0) or write (1) operation into register should be performed
-        SIGNAL s_bus_m_request : STD_LOGIC_VECTOR(numports DOWNTO 0); -- busMasterRequestOut -- Contains for each port whether there is a request to access routing table
-        SIGNAL s_bus_m_granted : STD_LOGIC_VECTOR(numports DOWNTO 0); -- busMasterGranted -- Contains for each port whether desired access to routing table is granted
-        SIGNAL s_bus_m_ack : STD_LOGIC_VECTOR(numports DOWNTO 0); -- busMasterAcknowledgeIn -- Contains for each port whether there is an acknowledgement of register for its operation
-        SIGNAL s_bus_m_strobe : STD_LOGIC_VECTOR(numports DOWNTO 0); -- busMasterStrobeOut -- Contains strobe signal for each port related to register access/routing table
-
-        -- Slave (s) bus signals.
-        -- The access_control process controls which master (port) has received access to internal bus from round robin arbiter and is allowed
-        -- to take control of the slave. The slave takes over communication with register and/or routing table.
-        SIGNAL s_bus_s_address : STD_LOGIC_VECTOR(31 DOWNTO 0); -- iBusSlaveAddressIn -- Copy of allowed port destination address (s_bus_m_address)
-        SIGNAL s_bus_s_request : STD_LOGIC; -- iBusSlaveCycleIn -- High if access to internal bus is required from a port, otherwise low
-        SIGNAL s_bus_s_strobe : STD_LOGIC; -- iBusSlaveStrobeIn -- High if a port performs an operation in register/routing table, otherwise low
-
-        SIGNAL s_bus_s_register_data_out : STD_LOGIC_VECTOR(31 DOWNTO 0); -- busSlaveDataOut -- Contains data word from data_out_buffer
-        SIGNAL s_register_data_out_buffer : STD_LOGIC_VECTOR(31 DOWNTO 0); -- ibusMasterDataOut -- Word taken from routing table (register) with current address of granted port
-        SIGNAL s_bus_s_register_data_in : STD_LOGIC_VECTOR(31 DOWNTO 0); -- iBusSlaveDataIn -- Data word to write into register of current granted port
-        SIGNAL s_bus_s_ack : STD_LOGIC; -- iBusSlaveAcknowledgeOut -- Contains acknowledgment from register (mapping to port is done in access_control)
-        SIGNAL s_bus_s_readwrite : STD_LOGIC; -- iBusSlaveWriteEnableIn -- Contains which kind of operation shall be performed in register
-        SIGNAL s_bus_s_dByte : STD_LOGIC_VECTOR(3 DOWNTO 0); -- iBusSlaveByteEnableIn -- Determines which byte (1-4) of data word in register should be read or overwritten
-
-        SIGNAL iBusSlaveOriginalPortIn : STD_LOGIC_VECTOR(7 DOWNTO 0); -- iBusSlaveOriginalPortIn -- diesen Port mal noch dort lassen, wird in aktueller Version nicht verwendet, ist aber nützlich um Registerzugriff neu zu regeln
+        SIGNAL autoTimeCodeValue : STD_LOGIC_VECTOR(7 DOWNTO 0);
+        SIGNAL autoTimeCodeCycleTime : STD_LOGIC_VECTOR(31 DOWNTO 0);
+
+        -- Eigene Signale
+        SIGNAL s_running : STD_LOGIC_VECTOR(numports DOWNTO 0);
     BEGIN
         -- Drive outputs.
         running <= s_running;
-        --        iLinkUp <= s_running;
+        iLinkUp <= s_running;
+        
+        -- Crossbar Switch - Router Arbiter.
+        arb : spwrouterarb
+        GENERIC MAP(
+            numports => numports
+        )
+        PORT MAP(
+            clk => clk,
+            rst => rst,
+            dest => destinationPort,
+            req => requestOut,
+            grnt => granted,
+            rout => routingSwitch
+        );
+
+        -- The destination PortNo regarding to the source PortNo.
+        destPort : FOR i IN 0 TO numports GENERATE
+            destPortI : FOR j IN 0 TO numports GENERATE
+                iSelectDestinationPort(i)(j) <= routingSwitch(j)(i);
+            END GENERATE destPortI;
+        END GENERATE destPort;
+
+        -- The source to the destination PortNo PortNo.
+        srcPort : FOR i IN 0 TO numports GENERATE
+            iSwitchPortNumber(i) <= routingSwitch(i);
+        END GENERATE srcPort;
 
-        -- Router arbiter (crossbar switch).
-        roundrobin_arbiter : spwrouterarb
+        -- Routing process: Assigns information to ports from the routing process.
+        spx : FOR i IN 0 TO numports GENERATE
+            iReadyIn(i) <= function_pkg.select7x1(iSelectDestinationPort(i), readyOut);
+            iRequestIn(i) <= function_pkg.select7x1(iSwitchPortNumber(i), requestOut);
+            --iSourcePortIn(i) <= select7x1xVector8(iSwitchPortNumber(i), sourcePortOut); -- wohl nur für RMAP nötig
+            iDataIn(i) <= function_pkg.select7x1xVector9(iSwitchPortNumber(i), dataOut);
+            iStrobeIn(i) <= function_pkg.select7x1(iSwitchPortNumber(i), strobeOut);
+        END GENERATE spx;
+        -- SpaceWirePort LinkUP Signal. (dropped)
+
+        -- Internal Configuration Port.
+        port0 : spwrouterport
         GENERIC MAP(
             numports => numports,
-            blen => blen
+            blen => blen,
+            pnum => 0,
+            sysfreq => sysfreq,
+            txclkfreq => txclkfreq,
+            rximpl => rx_impl(0),
+            tximpl => tx_impl(0)
+            -- Generics that are not listed here have default values!
         )
         PORT MAP(
             clk => clk,
+            rxclk => rxclk,
+            txclk => txclk,
             rst => rst,
-            destport => s_destination_port,
-            request => s_request_out,
-            granted => s_granted,
-            routing_matrix => s_routing_matrix
+            autostart => '1',
+            linkstart => '0',
+            linkdis => '0',
+            txdivcnt => "00000001",
+            tick_in => s_tick_from_tcc_to_ports(0),--tick_in(0),
+            time_in => s_tc_from_tcc_to_ports(0),--time_in(0),
+            txdata => iDataIn(0),
+            tick_out => s_tick_from_ports_to_tcc(0),--tick_out(0),
+            time_out => s_tc_from_ports_to_tcc(0),--time_out(0),
+            rxdata => dataOut(0),
+            started => started(0),
+            connecting => connecting(0),
+            running => s_running(0),
+            errdisc => errdisc(0),
+            errpar => errpar(0),
+            erresc => erresc(0),
+            errcred => errcred(0),
+            linkUp => iLinkUp,
+            requestOut => requestOut(0),
+            destinationPortOut => destinationPort(0),
+            sourcePortOut => sourcePortOut(0),
+            grantedIn => granted(0),
+            strobeOut => strobeOut(0),
+            readyIn => iReadyIn(0),
+            requestIn => iRequestIn(0),
+            strobeIn => iStrobeIn(0),
+            readyOut => readyOut(0),
+            busMasterAddressOut => busMasterAddressOut(0),
+            busMasterDataIn => busSlaveDataOut,
+            busMasterDataOut => busMasterDataOut(0),
+            busMasterByteEnableOut => busMasterByteEnableOut(0),
+            busMasterWriteEnableOut => busMasterWriteEnableOut(0),
+            busMasterStrobeOut => busMasterStrobeOut(0),
+            busMasterRequestOut => busMasterRequestOut(0),
+            busMasterAcknowledgeIn => busMasterAcknowledgeIn(0),
+            spw_di => spw_di(0),
+            spw_si => spw_si(0),
+            spw_do => spw_do(0),
+            spw_so => spw_so(0)
         );
 
-        -- Internal configuration port 0.
-        --        port0 : spwrouterport
-        --        GENERIC MAP(
-        --            numports => numports,
-        --            blen => blen,
-        --            --pnum => 0,
-        --            sysfreq => sysfreq,
-        --            txclkfreq => txclkfreq,
-        --            rximpl => rx_impl(0),
-        --            tximpl => tx_impl(0)
-        --            -- (Generics that are not listed here have default values !)
-        --        )
-        --        PORT MAP(
-        --            clk => clk,
-        --            rxclk => rxclk,
-        --            txclk => txclk,
-        --            rst => rst,
-        --            autostart => '1',
-        --            linkstart => '0',
-        --            linkdis => '0',
-        --            txdivcnt => "00000001", -- via register
-        --            tick_in => s_tick_from_tcc_to_ports(0), --tick_in(0),
-        --            time_in => s_tc_from_tcc_to_ports(0), --time_in(0),
-        --            txdata => s_txdata(0),
-        --            txhalff => OPEN,
-        --            tick_out => s_tick_from_ports_to_tcc(0), --tick_out(0),
-        --            time_out => s_tc_from_ports_to_tcc(0), --time_out(0),
-        --            txrdy => s_txrdy(0),
-        --            rxhalff => OPEN,
-        --            rxdata => s_rxdata(0),
-        --            started => started(0),
-        --            connecting => connecting(0),
-        --            running => s_running(0),
-        --            errdisc => errdisc(0),
-        --            errpar => errpar(0),
-        --            erresc => erresc(0),
-        --            errcred => errcred(0),
-        --            spw_di => spw_di(0),
-        --            spw_si => spw_si(0),
-        --            spw_do => spw_do(0),
-        --            spw_so => spw_so(0),
-        --            linkstatus => s_running, --iLinkUp,
-        --            request_in => s_request_in(0),
-        --            request_out => s_request_out(0),
-        --            destination_port => s_destination_port(0),
-        --            --sourcePortOut => sourcePortOut(0),
-        --            arb_granted => s_granted(0),
-        --            strobe_out => s_strobe_out(0),
-        --            strobe_in => s_strobe_in(0),
-        --            ready_in => s_ready_in(0),
-        --            --readyOut => readyOut(0),
-        --            bus_address => s_bus_m_address(0),
-        --            bus_data_in => s_bus_s_register_data_out,
-        --            --bus_data_out => s_bus_m_data(0),
-        --            bus_dByte => s_bus_m_dByte(0),
-        --            bus_readwrite => s_bus_m_readwrite(0),
-        --            bus_strobe => s_bus_m_strobe(0),
-        --            bus_request => s_bus_m_request(0),
-        --            bus_ack_in => s_bus_m_ack(0)
-        --        );
-
-        -- Remaining (normal) SpaceWire ports.
-        ports : FOR i IN 0 TO numports GENERATE
-            port_i : spwrouterport GENERIC MAP(
+        -- Other ports (numport-1)-ports.
+        spwports : FOR i IN 1 TO numports GENERATE
+            spwport : spwrouterport GENERIC MAP(
                 numports => numports,
                 blen => blen,
-                --pnum => i,
+                pnum => i,
                 sysfreq => sysfreq,
                 txclkfreq => txclkfreq,
                 rximpl => rx_impl(i),
                 tximpl => tx_impl(i)
-                -- (Generics that are not listed here have default values !)
+                -- Generics that are not listed here have default values!
             )
             PORT MAP(
-                -- SpaceWire IO:
-                clk => clk, -- I
-                rxclk => rxclk, -- I
-                txclk => txclk, -- I
-                rst => rst, -- I
-                autostart => '1', -- I -- active autostart but none linkstart! Router is waiting for incoming connection attempt.
-                linkstart => '0', -- I
-                linkdis => '0', -- I
-                txdivcnt => "00000001", -- I -- via register
-                tick_in => s_tick_from_tcc_to_ports(i), -- I --tick_in(i),
-                time_in => s_tc_from_tcc_to_ports(i), -- I --time_in(i),
-                txhalff => OPEN, -- O
-                txdata => s_txdata(i), -- I
-                tick_out => s_tick_from_ports_to_tcc(i), -- O --tick_out(i),
-                time_out => s_tc_from_ports_to_tcc(i), -- O --time_out(i),
-                txrdy => s_txrdy(i), -- O
-                rxhalff => OPEN, -- O
-                rxdata => s_rxdata(i), -- O
-                started => started(i), -- O
-                connecting => connecting(i), -- O
-                running => s_running(i), -- O
-                errdisc => errdisc(i), -- O
-                errpar => errpar(i), -- O
-                erresc => erresc(i), -- O
-                errcred => errcred(i), -- O
-                spw_di => spw_di(i), -- I
-                spw_si => spw_si(i), -- I
-                spw_do => spw_do(i), -- O
-                spw_so => spw_so(i), -- O
-                -- Router IO:
-                linkstatus => s_running, -- I --iLinkUp,
-                request_out => s_request_out(i), -- O
-                request_in => s_request_in(i), -- I
-                destination_port => s_destination_port(i),
-                --sourcePortOut => sourcePortOut(i),
-                arb_granted => s_granted(i), -- I
-                strobe_out => s_strobe_out(i), -- O
-                strobe_in => s_strobe_in(i), -- I
-                ready_in => s_ready_in(i), -- I
-                -- Internal Bus IO:
-                bus_address => s_bus_m_address(i), -- O
-                bus_data_in => s_bus_s_register_data_out, -- I
-                --bus_data_out => s_bus_m_data(i),
-                bus_dByte => s_bus_m_dByte(i), -- O
-                bus_readwrite => s_bus_m_readwrite(i), -- O
-                bus_strobe => s_bus_m_strobe(i), -- O
-                bus_request => s_bus_m_request(i), -- O
-                bus_ack_in => s_bus_m_ack(i) -- I
+                clk => clk,
+                rxclk => rxclk,
+                txclk => txclk,
+                rst => rst,
+                autostart => '1', -- active autostart but none linkstart! Router is waiting for incoming connection attempt.
+                linkstart => '0',
+                linkdis => '0',
+                txdivcnt => "00000001",
+                tick_in => s_tick_from_tcc_to_ports(i),--tick_in(i),
+                time_in => s_tc_from_tcc_to_ports(i),--time_in(i),
+                txdata => iDataIn(i),
+                tick_out => s_tick_from_ports_to_tcc(i),--tick_out(i),
+                time_out => s_tc_from_ports_to_tcc(i),--time_out(i),
+                rxdata => dataOut(i),
+                started => started(i),
+                connecting => connecting(i),
+                running => s_running(i),
+                errdisc => errdisc(i),
+                errpar => errpar(i),
+                erresc => erresc(i),
+                errcred => errcred(i),
+                linkUp => iLinkUp,
+                requestOut => requestOut(i),
+                destinationPortOut => destinationPort(i),
+                sourcePortOut => sourcePortOut(i),
+                grantedIn => granted(i),
+                strobeOut => strobeOut(i),
+                readyIn => iReadyIn(i),
+                requestIn => iRequestIn(i),
+                strobeIn => iStrobeIn(i),
+                readyOut => readyOut(i),
+                busMasterAddressOut => busMasterAddressOut(i),
+                busMasterDataIn => busSlaveDataOut,
+                busMasterDataOut => busMasterDataOut(i),
+                busMasterByteEnableOut => busMasterByteEnableOut(i),
+                busMasterWriteEnableOut => busMasterWriteEnableOut(i),
+                busMasterStrobeOut => busMasterStrobeOut(i),
+                busMasterRequestOut => busMasterRequestOut(i),
+                busMasterAcknowledgeIn => busMasterAcknowledgeIn(i),
+                spw_di => spw_di(i),
+                spw_si => spw_si(i),
+                spw_do => spw_do(i),
+                spw_so => spw_so(i)
             );
-        END GENERATE ports;
+        END GENERATE;
 
-        -- Contains router link control, port status register and routing table.
-        Reg : spwrouterregs
+        -- Router Link Control, Status Register and Routing Table
+        routerControlRegister : spwrouterregs
         GENERIC MAP(
             numports => numports
         )
         PORT MAP(
-            clk => clk, -- I
-            rst => rst, -- I
-            writeData => s_bus_s_register_data_in, -- I
-            readData => s_register_data_out_buffer, -- O
-            readwrite => s_bus_s_readwrite, -- I
-            dByte => s_bus_s_dByte, -- I
-            addr => s_bus_s_address, -- I
-            proc => s_bus_s_ack, -- O
-            strobe => s_bus_s_strobe, -- I
-            cycle => s_bus_s_request, -- I
-            portstatus => (OTHERS => (OTHERS => '0')), -- I -- TODO!
-            receiveTimeCode => s_last_tc, -- I
-            autoTimeCodeValue => s_auto_tc, -- I
-            autoTimeCodeCycleTime => s_auto_cycle -- O
-        );
-
-        -- Bus arbiter & routing table arbiter
-        internalbus_arbiter : spwrouterarb_table
-        GENERIC MAP(
-            numports => numports
-        )
-        PORT MAP(
-            clk => clk, -- I
-            rst => rst, -- I
-            request => s_bus_m_request, -- I
-            granted => s_bus_m_granted -- O
+            clk => clk,
+            rst => rst,
+            writeData => iBusSlaveDataIn,
+            readData => ibusMasterDataOut,
+            readwrite => iBusSlaveWriteEnableIn,
+            dByte => iBusSlaveByteEnableIn,
+            addr => iBusSlaveAddressIn,
+            proc => iBusSlaveAcknowledgeOut,
+            strobe => iBusSlaveStrobeIn,
+            cycle => iBusSlaveCycleIn,
+            portstatus => (OTHERS => (OTHERS => '0')), -- TODO!
+            receiveTimeCode => routerTimeCode,
+            autoTimeCodeValue => autoTimeCodeValue,
+            autoTimeCodeCycleTime => autoTimeCodeCycleTime
         );
 
-        -- Time code control.
-        timecode_control : spwroutertcc
+        -- Bus arbiter & Router table arbiter
+        arb_table : spwrouterarb_table
         GENERIC MAP(
             numports => numports
         )
         PORT MAP(
             clk => clk,
             rst => rst,
-            running => s_running, -- iLinkUp,
-            tc_enable => (OTHERS => '1'), -- Time Codes are always activated on all available ports
-            tc_last => s_last_tc,
-            tick_out => s_tick_from_tcc_to_ports, --tick_out,
-            tick_in => s_tick_from_ports_to_tcc, --tick_in,
-            tc_out => s_tc_from_tcc_to_ports, --time_out,
-            tc_in => s_tc_from_ports_to_tcc, --time_in,
-            auto_tc_out => s_auto_tc,
-            auto_interval => s_auto_cycle
+            req => busMasterRequestOut,
+            grnt => busMasterGranted
         );
 
-        -- Creates transposed matrix of s_routing_matrix: Shows for every port (row) which port (column) requests access to it.
-        routing_matrix_row : FOR i IN 0 TO numports GENERATE
-            routing_matrix_column : FOR j IN 0 TO numports GENERATE
-                s_routing_matrix_transposed(i)(j) <= s_routing_matrix(j)(i);
-            END GENERATE routing_matrix_column;
-        END GENERATE routing_matrix_row;
-
-        -- Stores every row of s_routing_matrix which maps source ports (row) to destination ports (column)
-        source_port_rows : FOR i IN 0 TO numports GENERATE
-            s_source_port_row(i) <= s_routing_matrix(i);
-        END GENERATE source_port_rows;
-
-        -- Routing process: Assigns information to ports from the routing process.
-        crossbar : FOR i IN 0 TO numports GENERATE
-            s_ready_in(i) <= spwrouterfunc.select_port(s_routing_matrix_transposed(i), s_txrdy);
-            s_request_in(i) <= spwrouterfunc.select_port(s_source_port_row(i), s_request_out);
-            --iSourcePortIn(i) <= select7x1xVector8(s_source_port_row(i), sourcePortOut); -- wohl nur für RMAP nötig
-            s_txdata(i) <= spwrouterfunc.select_nchar(s_source_port_row(i), s_rxdata);
-            s_strobe_in(i) <= spwrouterfunc.select_port(s_source_port_row(i), s_strobe_out);
-        END GENERATE crossbar;
-        -- SpaceWirePort LinkUP Signal. (dropped)
-
-        -- Controls which master gets access to bus.
-        access_control : PROCESS (clk)
+        -- Timing adjustment. BusSlaveAccessSelector
+        PROCESS (clk)
         BEGIN
             IF rising_edge(clk) THEN
-                s_bus_s_request <= OR s_bus_m_request;
-                s_bus_s_register_data_out <= s_register_data_out_buffer;
-
-                -- Caution ! Reversed priority conditioned through if-statements !
-                -- For loop first rolls out numports, last 0. Since no if..elsif statements
-                -- can be generated via GENERATE-keyword, the block hat to be translated into
-                -- independent if statements. The order is reversed because of the changed 
-                -- priority: previously, first if statement had highes priority (the first
-                -- elsif, etc.). Now hightest priority must be at the end in order to be able
-                -- to overwrite a previously made decision.
-                FOR i IN numports DOWNTO 0 LOOP
-                    IF (s_bus_m_granted(i) = '1') THEN
-                        s_bus_s_strobe <= s_bus_m_strobe(i);
-                        s_bus_s_address <= s_bus_m_address(i);
-                        s_bus_s_dByte <= s_bus_m_dByte(i);
-                        s_bus_s_readwrite <= s_bus_m_readwrite(i);
-                        --iBusSlaveOriginalPortIn <= x"ff"; -- Zeile macht aktuell noch keinen Sinn
-                        s_bus_s_register_data_in <= s_bus_m_data(i); --(OTHERS => '0');
-                        s_bus_m_ack <= (i => s_bus_s_ack, OTHERS => '0');
+
+                iBusSlaveCycleIn <= OR busMasterRequestOut;
+                -- Reversed priority conditioned through if-statements.
+                FOR i IN numports DOWNTO 1 LOOP
+                    IF (busMasterGranted(i) = '1') THEN
+                        iBusSlaveStrobeIn <= busMasterStrobeOut(i);
+                        iBusSlaveAddressIn <= busMasterAddressOut(i);
+                        iBusSlaveByteEnableIn <= busMasterByteEnableOut(i);
+                        iBusSlaveWriteEnableIn <= busMasterWriteEnableOut(i);
+                        iBusSlaveOriginalPortIn <= x"ff";
+                        iBusSlaveDataIn <= (OTHERS => '0');
+                        busMasterAcknowledgeIn <= (i => iBusSlaveAcknowledgeOut, OTHERS => '0');
                     END IF;
                 END LOOP;
 
-                -- Port0 is special case so handling outside of for-loop. -- No, it is not anymore.
-                --                IF (s_bus_m_granted(0) = '1') THEN
-                --                    s_bus_s_strobe <= s_bus_m_strobe(0);
-                --                    s_bus_s_address <= s_bus_m_address(0);
-                --                    s_bus_s_dByte <= s_bus_m_dByte(0);
-                --                    s_bus_s_readwrite <= s_bus_m_readwrite(0);
-                --                    s_bus_s_register_data_in <= s_bus_m_data(0);
-                --                    s_bus_m_ack <= (0 => s_bus_s_ack, OTHERS => '0');
-                --                END IF;
+                -- Port0 is special case so handling outside for loop
+                IF (busMasterGranted(0) = '1') THEN
+                    iBusSlaveStrobeIn <= busMasterStrobeOut(0);
+                    iBusSlaveAddressIn <= busMasterAddressOut(0);
+                    iBusSlaveByteEnableIn <= busMasterByteEnableOut(0);
+                    iBusSlaveWriteEnableIn <= busMasterWriteEnableOut(0);
+                    iBusSlaveDataIn <= busMasterDataOut(0);
+                    busMasterAcknowledgeIn <= (0 => iBusSlaveAcknowledgeOut, OTHERS => '0');
+                END IF;
+
+                busSlaveDataOut <= ibusMasterDataOut;
             END IF;
-        END PROCESS access_control;
+        END PROCESS;
+        
+        -- Time code forwarding logic.
+        timecodecontrol : spwroutertcc
+        GENERIC MAP(
+            numports => numports
+        )
+        PORT MAP(
+            clk => clk,
+            rst => rst,
+            running => iLinkUp,
+            tc_enable => (OTHERS => '1'),
+            tc_last => routerTimeCode,            
+            tick_out => s_tick_from_tcc_to_ports,--tick_out,
+            tick_in => s_tick_from_ports_to_tcc,--tick_in,
+            tc_out => s_tc_from_tcc_to_ports,--time_out,
+            tc_in => s_tc_from_ports_to_tcc,--time_in,
+            auto_tc_out => autoTimeCodeValue,
+            auto_interval => autoTimeCodeCycleTime
+        );
     END ARCHITECTURE spwrouter_arch;
\ No newline at end of file
diff --git a/trunk/rtl/vhdl/spwrouterarb.vhd b/trunk/rtl/vhdl/spwrouterarb.vhd
index 4110e18..74a8147 100644
--- a/trunk/rtl/vhdl/spwrouterarb.vhd
+++ b/trunk/rtl/vhdl/spwrouterarb.vhd
@@ -3,119 +3,115 @@
 -- Engineer: Stefan Lindoerfer
 -- 
 -- Create Date: 31.07.2021 21:26
--- Design Name: SpaceWire Router - Router Arbiter (Logic & Preperation)
+-- Design Name: SpaceWire Router Package
 -- Module Name: spwrouterarb
--- Project Name: Bachelor Thesis: Implementation of a SpaceWire Router on an FPGA
--- Target Devices: Xilinx FPGAs
--- Tool Versions: -/-
+-- Project Name: Bachelor Thesis: Implementation of a SpaceWire Router on a FPGA
+-- Target Devices: 
+-- Tool Versions: 
 -- Description: Framework of a round robin arbiter which controls access between
 -- the ports.
 --
--- Dependencies: array_t, matrix_t (spwrouterpkg)
+-- Dependencies: spwrouterpkg
 -- 
 -- Revision:
 ----------------------------------------------------------------------------------
 
-LIBRARY IEEE;
-USE IEEE.STD_LOGIC_1164.ALL;
-USE IEEE.NUMERIC_STD.ALL;
-USE IEEE.MATH_REAL.ALL;
-USE WORK.SPWROUTERPKG.ALL;
+LIBRARY ieee;
+USE ieee.std_logic_1164.ALL;
+USE ieee.numeric_std.ALL;
+USE ieee.Math_real.ALL;
+USE work.spwrouterpkg.ALL;
 
 ENTITY spwrouterarb IS
     GENERIC (
         -- Number of SpaceWire ports.
-        numports : INTEGER RANGE 0 TO 31;
-
-        -- Bit length to map number of ports (ceil(log2(numports))).
-        blen : INTEGER RANGE 0 TO 5 -- (max 5 bits for 0-31 ports)
+        numports : INTEGER RANGE 0 TO 31
     );
     PORT (
         -- System clock.
         clk : IN STD_LOGIC;
 
-        -- Synchronous reset (spwrouterarb_round).
+        -- Asynchronous reset.
         rst : IN STD_LOGIC;
 
-        -- Contains desired destination port for each port (number coded in binary !)
-        destport : IN array_t(numports DOWNTO 0)(7 DOWNTO 0); -- dest
+        -- Destination of port x (0-254 are always addressable, therefore 8 bits are necessary!)
+        dest : IN array_t(numports DOWNTO 0)(7 DOWNTO 0);
 
-        -- Shows for each port whether access to another port is required.
-        request : IN STD_LOGIC_VECTOR(numports DOWNTO 0); -- req
+        -- Request of port x.
+        req : IN STD_LOGIC_VECTOR(numports DOWNTO 0);
 
-        -- Contains ports that have granted access to the port that is specified in destport.
-        granted : OUT STD_LOGIC_VECTOR(numports DOWNTO 0); -- grnt
+        -- Granted to port x.
+        grnt : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
 
-        -- Routing switch matrix: Maps source ports (row) to target ports (column)
-        routing_matrix : OUT array_t(numports DOWNTO 0)(numports DOWNTO 0) -- rout
+        -- Routing switch matrix.
+        rout : OUT array_t(numports DOWNTO 0)(numports DOWNTO 0) -- Falls es hier probleme gibt, auf matrix wechseln!
     );
 END spwrouterarb;
 
 ARCHITECTURE spwrouterarb_arch OF spwrouterarb IS
-    -- Routing switch matrix: Containts decision ultimately made byte the arbiter as to which port is allowed to send over another port.
-    SIGNAL s_routing : array_t(numports DOWNTO 0)(numports DOWNTO 0);
+    -- Bit length to map all ports (for spwrouterarb_round).
+    CONSTANT blen : INTEGER RANGE 0 TO 5 := INTEGER(ceil(log2(real(numports))));
+
+    -- Router switch matrix.
+    SIGNAL s_routing : array_t(numports DOWNTO 0)(numports DOWNTO 0); -- hängt mit out port zusammen! siehe oben
 
-    -- Shows which ports are currently occupied.
+    -- Occupied port x.
     SIGNAL s_occupied : STD_LOGIC_VECTOR(numports DOWNTO 0);
 
-    -- Contains which ports want to access other ports.
-    SIGNAL s_request : matrix_t(numports DOWNTO 0, numports DOWNTO 0);
+    -- Requests to port x.
+    SIGNAL s_request : matrix_t(numports DOWNTO 0, numports DOWNTO 0); -- potenzielle fehlerquelle!
 
-    -- Contains ports that are allowed to send (not destination ports).
-    SIGNAL s_granted : STD_LOGIC_VECTOR(numports DOWNTO 0);
+    -- Granted to port x.
+    SIGNAL s_granted : STD_LOGIC_VECTOR(numports DOWNTO 0); -- initialisierung in ursprungscode nicht vorgehsehen! evtl fehlerquelle!
 BEGIN
     -- Drive outputs.
-    granted <= s_granted;
-    routing_matrix <= s_routing;
-
-    -- Checks for each port whether one or more ports want to access it. If so, this port is occupied.
-    Occupation : FOR i IN 0 TO numports GENERATE
-        s_occupied(i) <= OR s_routing(i); -- Operator overloading (or)
-    END GENERATE Occupation;
-
-    -- Maps which ports make requests to other ports
-    Request_Column : FOR i IN 0 TO numports GENERATE
-        Request_Row : FOR j IN 0 TO numports GENERATE
-            s_request(j, i) <= '1' WHEN request(i) = '1' AND to_integer(unsigned(destport(i))) = j ELSE
-            '0';
-        END GENERATE Request_Row;
-    END GENERATE Request_Column;
-
-    -- Generate spwrouterarb_round for every port.
-    RoundRobin_Row : FOR i IN 0 TO numports GENERATE
+    grnt <= s_granted;
+    rout <= s_routing;
+
+    -- Route occupation signal
+    occSig : FOR i IN 0 TO numports GENERATE
+        -- unten: hier inner loop nur nötig wenn mit rout(i) nicht eine ganze Zeile angesprochen werden kann!! Operatoren sind so definiert, dass sie auch eine komplete Zeile verarbeiten!
+        s_occupied(i) <= OR s_routing(i); -- hoffentlich richtig addressiert
+    END GENERATE occSig;
+
+    -- Source port number which requests port as destination port.
+    outerloop : FOR i IN 0 TO numports GENERATE
+        innerloop : FOR j IN 0 TO numports GENERATE
+            s_request(j, i) <= '1' WHEN req(i) = '1' AND to_integer(unsigned(dest(i))) = j ELSE
+            '0'; -- potenzielle fehlerquelle!
+        END GENERATE innerloop;
+    END GENERATE outerloop;
+
+    -- Generate Arbiter_Round for every port.
+    spwrouterarbiter_roundrobin : FOR i IN 0 TO numports GENERATE
         SIGNAL s_request_vec : STD_LOGIC_VECTOR(numports DOWNTO 0);
     BEGIN
 
-        -- Intermediate step: Convert matrix row into vector.
-        RoundRobin_Column : FOR j IN numports DOWNTO 0 GENERATE
+        -- Convert matrix line into vector.
+        Conv : FOR j IN numports DOWNTO 0 GENERATE
             s_request_vec(j) <= s_request(i, j);
-        END GENERATE RoundRobin_Column;
+        END GENERATE Conv;
 
-        -- Instantiate round robin for every port i.
-        RoundRobin_Inst : spwrouterarb_round
-        GENERIC MAP(
+        Roundx : spwrouterarb_round GENERIC MAP(
             numports => numports,
             blen => blen
         )
         PORT MAP(
             clk => clk,
             rst => rst,
-            occupied => s_occupied(i),
-            request => s_request_vec,
-            granted => s_routing(i)
+            occ => s_occupied(i),
+            req => s_request_vec, -- vorher: s_request(i)
+            grnt => s_routing(i) -- hier evtl. eine Fehlerquelle wegen falscher zuordnung?
         );
-    END GENERATE RoundRobin_Row;
+    END GENERATE spwrouterarbiter_roundrobin;
 
-    -- Based on routing result of all ports, creates a list of
-    -- which source ports are allowed to execute their request.
-    Granted_Row : FOR i IN 0 TO numports GENERATE
+    -- Connection enabling signal
+    rowloop : FOR i IN 0 TO numports GENERATE
         SIGNAL s_transform : STD_LOGIC_VECTOR(numports DOWNTO 0);
     BEGIN
-        -- Intermediate step: Transpose every vector in matrix (for operator overloading).
-        Granted_Column : FOR j IN numports DOWNTO 0 GENERATE
+        columnloop : FOR j IN numports DOWNTO 0 GENERATE
             s_transform(j) <= s_routing(j)(i);
-        END GENERATE Granted_Column;
-
-        s_granted(i) <= OR s_transform; -- Operator overloading (or)
-    END GENERATE Granted_Row;
+        END GENERATE columnloop;
+        s_granted(i) <= OR s_transform;
+    END GENERATE rowloop;
 END ARCHITECTURE spwrouterarb_arch;
\ No newline at end of file
diff --git a/trunk/rtl/vhdl/spwrouterarb_round.vhd b/trunk/rtl/vhdl/spwrouterarb_round.vhd
index 9d5b85c..5fce4f8 100644
--- a/trunk/rtl/vhdl/spwrouterarb_round.vhd
+++ b/trunk/rtl/vhdl/spwrouterarb_round.vhd
@@ -3,24 +3,24 @@
 -- Engineer: Stefan Lindoerfer
 -- 
 -- Create Date: 31.07.2021 22:38
--- Design Name: SpaceWire Router - Router Arbiter Round Robin
+-- Design Name: SpaceWire Router Package
 -- Module Name: spwrouterarb_round
--- Project Name: Bachelor Thesis: Implementation of a SpaceWire Router on an FPGA
--- Target Devices: Xilinx FPGAs
--- Tool Versions: -/-
--- Description: A ring is constructed that contains all (source) ports and,
--- starting from a specific port, gives next higher priority in ascending order
--- (0..numports..0). The starting point is always the last port to which 
--- access was granted.
+-- Project Name: Bachelor Thesis: Implementation of a SpaceWire Router on a FPGA
+-- Target Devices: 
+-- Tool Versions: 
+-- Description: Ein Ring wird konstruiert, der alle Ports enthält und dem numerisch
+-- darauffolgendem Port die höchste Priorität einräumt (numports..0). Ausgehend dabei ist der
+-- Port, dem zuletzt der Zugriff gewährt wurde. Bsp für 1 bei insgesamt 3 Ports: 2..0..1
 --
 -- Dependencies: none
 -- 
 -- Revision:
 ----------------------------------------------------------------------------------
 
-LIBRARY IEEE;
-USE IEEE.STD_LOGIC_1164.ALL;
-USE IEEE.NUMERIC_STD.ALL;
+LIBRARY ieee;
+USE ieee.std_logic_1164.ALL;
+USE ieee.numeric_std.ALL;
+--USE work.spwrouterpkg.ALL;
 
 ENTITY spwrouterarb_round IS
     GENERIC (
@@ -34,80 +34,76 @@ ENTITY spwrouterarb_round IS
         -- System clock.
         clk : IN STD_LOGIC;
 
-        -- Synchronous reset.
+        -- Asynchronous reset.
         rst : IN STD_LOGIC;
 
-        -- High if this port is already being occupied,
-        -- low when the port is unused.
-        occupied : IN STD_LOGIC; -- occ
+        -- High if relevant port is already being used by another
+        -- transfer process. Low when the port is unused.
+        occ : IN STD_LOGIC;
 
-        -- Shows which ports making an transfer request to this port.
-        request : IN STD_LOGIC_VECTOR(numports DOWNTO 0); -- req
+        -- Corresponding bit is high when respective port sends
+        -- a request to the port.
+        req : IN STD_LOGIC_VECTOR(numports DOWNTO 0);
 
-        -- Shows which port has been guaranteed access to this port.
-        granted : OUT STD_LOGIC_VECTOR(numports DOWNTO 0) -- grnt
+        -- Bit sequence that indicates the access of another port.
+        grnt : OUT STD_LOGIC_VECTOR(numports DOWNTO 0)
     );
 END spwrouterarb_round;
 
 ARCHITECTURE spwrouterarb_round_arch OF spwrouterarb_round IS
-    -- Output registers.
+    -- Output registers
     SIGNAL s_granted : STD_LOGIC_VECTOR(numports DOWNTO 0);
     SIGNAL s_request : STD_LOGIC_VECTOR(numports DOWNTO 0);
     SIGNAL s_occupied : STD_LOGIC;
 
-    -- Last granted port (for internal purposes).
-    SIGNAL s_last_granted : STD_LOGIC_VECTOR(blen DOWNTO 0);
+    -- Last granted port.
+    SIGNAL s_lstgrnt : STD_LOGIC_VECTOR(blen DOWNTO 0);
 BEGIN
-    -- Drive output.
-    granted <= s_granted;
+    -- Intermediate signals
+    s_request <= req;
+    s_occupied <= occ;
 
-    -- Read inputs.
-    s_request <= request;
-    s_occupied <= occupied;
+    -- Drive output.
+    grnt <= s_granted;
 
-    PROCESS (clk)
+    PROCESS (clk, rst)
     BEGIN
-        IF rising_edge(clk) THEN
-            IF rst = '1' THEN
-                -- Synchronous reset.
-                s_granted <= (OTHERS => '0');
-                s_last_granted <= STD_LOGIC_VECTOR(to_unsigned(0, s_last_granted'length));
-            ELSE
-                -- Roll-out arbitration logic for every port.
-                arbitration : FOR i IN numports DOWNTO 0 LOOP
-                    IF (s_last_granted = STD_LOGIC_VECTOR(to_unsigned(i, s_last_granted'length))) THEN
-
-                        -- The following ports in the line (0..1..numports..0) will give prefered access to current
-                        -- port. Normally in if-statements early conditions takes priority above later.
-                        -- Through rolling out for-loops, many seperate if-statements will be
-                        -- created. Therefore the highes priority must be listed in the last order to
-                        -- be able to overwrite any previous decision with lower priority.
-
-                        lowerpriority : FOR j IN i DOWNTO 0 LOOP -- [i <= j <= 0]
-                            IF (s_request(j) = '1' AND s_occupied = '0') THEN
-                                s_granted <= std_logic_vector(to_unsigned(2 ** j, s_granted'length)); -- Test, should do same
-                                --s_granted <= (j => '1', OTHERS => '0'); -- works ! Procudes warnings in ModelSim
-                                s_last_granted <= STD_LOGIC_VECTOR(to_unsigned(j, s_last_granted'length));
-                            END IF;
-                        END LOOP lowerpriority;
-                        
-                        higherpriority : FOR k IN numports DOWNTO (i + 1) LOOP -- [numports <= k <= (i+1)]
-                            IF (s_request(k) = '1' AND s_occupied = '0') THEN
-                                s_granted <= std_logic_vector(to_unsigned(2 ** k, s_granted'length)); -- look at lowerpriority !
-                                --s_granted <= (k => '1', OTHERS => '0'); -- works !
-                                s_last_granted <= STD_LOGIC_VECTOR(to_unsigned(k, s_last_granted'length));
-                            END IF;
-                        END LOOP higherpriority;
-                    END IF;
-                END LOOP arbitration;
-
-                -- Revoke previously granted access that is no longer required.
-                FOR i IN 0 TO numports LOOP
-                    IF (s_request(i) = '0' AND s_granted(i) = '1') THEN
-                        s_granted(i) <= '0';
-                    END IF;
-                END LOOP;
-            END IF;
+        IF (rst = '1') THEN -- reset
+            s_granted <= (OTHERS => '0');
+            s_lstgrnt <= STD_LOGIC_VECTOR(to_unsigned(0, s_lstgrnt'length));
+
+        ELSIF rising_edge(clk) THEN
+            -- Roll-out arbitration logic for every port.
+            arbitration : FOR i IN numports DOWNTO 0 LOOP
+                IF (s_lstgrnt = STD_LOGIC_VECTOR(to_unsigned(i, s_lstgrnt'length))) THEN
+
+                    -- The following ports in the line (0..1..numports..0) will give prefered access to current
+                    -- port. Normally in if-statements early conditions takes priority above later.
+                    -- Through rolling out for-loops, many seperate if-statements will be
+                    -- created. Therefore the highes priority must be listed in the  last order to
+                    -- be able to overwrite any previous decision with lower priority.
+
+                    lowerpriority : FOR j IN i DOWNTO 0 LOOP
+                        IF (s_request(j) = '1' AND s_occupied = '0') THEN
+                            s_granted <= (j => '1', OTHERS => '0');
+                            s_lstgrnt <= STD_LOGIC_VECTOR(to_unsigned(j, s_lstgrnt'length));
+                        END IF;
+                    END LOOP lowerpriority;
+                    higherpriority : FOR k IN numports DOWNTO (i + 1) LOOP
+                        IF (s_request(k) = '1' AND s_occupied = '0') THEN
+                            s_granted <= (k => '1', OTHERS => '0');
+                            s_lstgrnt <= STD_LOGIC_VECTOR(to_unsigned(k, s_lstgrnt'length));
+                        END IF;
+                    END LOOP higherpriority;
+                END IF;
+            END LOOP arbitration;
+
+            -- Revoke previously granted access that is no longer required.
+            FOR i IN 0 TO numports LOOP
+                IF (s_request(i) = '0' AND s_granted(i) = '1') THEN
+                    s_granted(i) <= '0';
+                END IF;
+            END LOOP;
         END IF;
     END PROCESS;
 
diff --git a/trunk/rtl/vhdl/spwrouterarb_table.vhd b/trunk/rtl/vhdl/spwrouterarb_table.vhd
index 45de41b..62c3fb2 100644
--- a/trunk/rtl/vhdl/spwrouterarb_table.vhd
+++ b/trunk/rtl/vhdl/spwrouterarb_table.vhd
@@ -5,12 +5,12 @@
 -- Create Date: 03.08.2021 20:15
 -- Design Name: SpaceWire Router Table Arbiter
 -- Module Name: spwrouterarb_table
--- Project Name: Bachelor Thesis: Implementation of a SpaceWire Router on an FPGA
--- Target Devices: Xilinx FPGAs
--- Tool Versions: -/-
+-- Project Name: Bachelor Thesis: Implementation of a SpaceWire Router on a FPGA
+-- Target Devices: 
+-- Tool Versions: 
 -- Description: Grants permission to router table and registers.
 --
--- Dependencies:
+-- Dependencies: spwrouterpkg
 -- 
 -- Revision:
 ----------------------------------------------------------------------------------
@@ -28,14 +28,14 @@ ENTITY spwrouterarb_table IS
         -- System clock.
         clk : IN STD_LOGIC;
 
-        -- Synchronous reset.
+        -- Asynchronous reset.
         rst : IN STD_LOGIC;
 
         -- Requests from all ports. (Bit corresponds to port)
-        request : IN STD_LOGIC_VECTOR(numports DOWNTO 0); -- req
+        req : IN STD_LOGIC_VECTOR(numports DOWNTO 0);
 
         -- Containts which port gets access.
-        granted : OUT STD_LOGIC_VECTOR(numports DOWNTO 0) -- grnt
+        grnt : OUT STD_LOGIC_VECTOR(numports DOWNTO 0)
     );
 END spwrouterarb_table;
 
@@ -43,43 +43,39 @@ ARCHITECTURE spwrouterarb_table_arch OF spwrouterarb_table IS
     SIGNAL s_granted : STD_LOGIC_VECTOR(numports DOWNTO 0);
 BEGIN
     -- Drive output
-    granted <= s_granted;
+    grnt <= s_granted;
 
     -- Arbitration process
-    PROCESS (clk)
+    PROCESS (clk, rst)
     BEGIN
-        IF rising_edge(clk) THEN
-            IF rst = '1' THEN
-                -- Synchronous reset.
-                s_granted <= STD_LOGIC_VECTOR(to_unsigned(2 ** 0, s_granted'length)); -- ModelSim prodces warnings with following line so try this instead
-                --s_granted <= (0 => '1', OTHERS => '0'); -- works -- Assign increased priority for port0 (internal configuration port).
-            ELSE
-                -- Check each ports (except current) wheather access is required.
-                -- Method: First subsequent ones and then previous ones.
-                -- Since individual, independent if-conditions are generated by for-loops,
-                -- that order must be reversed to keep same priority list if-elsif-conditions would have.
-                -- Example: Port4: 5..6..7..0..1..2..3 --> 1..0..7..6..5
+        IF (rst = '1') THEN
+            s_granted <= (0 => '1', OTHERS => '0'); -- Assign increased priority for port0 (internal configuration port).
 
-                -- To have the right priority the order was changed in unusual order
+        ELSIF rising_edge(clk) THEN
 
-                Arbitration_Access : FOR i IN numports DOWNTO 0 LOOP
-                    IF (s_granted(i) = '1' AND request(i) = '0') THEN
-                        pre_ports : FOR j IN (i - 1) DOWNTO 0 LOOP -- [(i-1) <= j <= 0]
-                            IF (request(j) = '1') THEN
-                                s_granted <= STD_LOGIC_VECTOR(to_unsigned(2 ** j, s_granted'length));
-                            END IF;
-                        END LOOP pre_ports;
+            -- Check each ports (except current) wheather access is required.
+            -- Method: First subsequent ones and then previous ones.
+            -- Since individual, independent if-conditions are generated by for-loops,
+            -- that order must be reversed to keep same priority list if-elsif-conditions would have.
+            -- Example: Port4: 5..6..7..0..1..2..3 --> 1..0..7..6..5
 
-                        -- (except current port i)
+            -- To have the right priority the order was changed in unusual order
 
-                        seq_ports : FOR k IN numports DOWNTO (i + 1) LOOP -- [numports <= k <= (i+1)]
-                            IF (request(k) = '1') THEN
-                                s_granted <= STD_LOGIC_VECTOR(to_unsigned(2 ** k, s_granted'length));
-                            END IF;
-                        END LOOP seq_ports;
-                    END IF;
-                END LOOP Arbitration_Access;
-            END IF;
+            arbitrationaccess : FOR i IN numports DOWNTO 0 LOOP
+                IF (s_granted(i) = '1' AND req(i) = '0') THEN
+                    preports : FOR j IN (i - 1) DOWNTO 0 LOOP
+                        IF (req(j) = '1') THEN
+                            s_granted <= STD_LOGIC_VECTOR(to_unsigned(2 ** j, s_granted'length));
+                        END IF;
+                    END LOOP preports;
+                    -- except current port i
+                    seqports : FOR k IN numports DOWNTO (i + 1) LOOP
+                        IF (req(k) = '1') THEN
+                            s_granted <= STD_LOGIC_VECTOR(to_unsigned(2 ** k, s_granted'length));
+                        END IF;
+                    END LOOP seqports;
+                END IF;
+            END LOOP arbitrationaccess;
         END IF;
     END PROCESS;
 END spwrouterarb_table_arch;
\ No newline at end of file
diff --git a/trunk/rtl/vhdl/spwrouterfunc.vhd b/trunk/rtl/vhdl/spwrouterfunc.vhd
index c0b816a..e7e7653 100644
--- a/trunk/rtl/vhdl/spwrouterfunc.vhd
+++ b/trunk/rtl/vhdl/spwrouterfunc.vhd
@@ -5,50 +5,54 @@
 -- Create Date: 26.09.2021 17:54
 -- Design Name: SpaceWire Router Function Package
 -- Module Name: spwrouterfunc
--- Project Name: Bachelor Thesis: Implementation of a SpaceWire Router on an FPGA
--- Target Devices: Xilinx FPGAs
--- Tool Versions: -/-
--- Description: Contains filtering generic functions.
+-- Project Name: Bachelor Thesis: Implementation of a SpaceWire Router on a FPGA
+-- Target Devices: 
+-- Tool Versions: 
+-- Description: 
 --
--- Dependencies: array_t (spwrouterpkg)
+-- Dependencies: spwrouterpkg
 -- 
--- Revision: 1.0
+-- Revision:
 ----------------------------------------------------------------------------------
 
 LIBRARY IEEE;
-USE IEEE.STD_LOGIC_1164.ALL;
-USE IEEE.NUMERIC_STD.ALL;
-USE WORK.SPWROUTERPKG.ALL;
+USE IEEE.std_logic_1164.ALL;
+USE IEEE.numeric_std.ALL;
+USE WORK.spwrouterpkg.ALL;
 
 PACKAGE spwrouterfunc IS
     GENERIC (
-        -- Number of SpaceWire ports.
         numports : INTEGER RANGE 0 TO 31
     );
 
-    -- Applies bit mask to an input (filtered bit sequence) and ORs it into one bit. 
-    FUNCTION select_port(selectBit : STD_LOGIC_VECTOR(numports DOWNTO 0); bits : STD_LOGIC_VECTOR(numports DOWNTO 0)) RETURN STD_LOGIC; -- select7x1
-
-    -- Selects a row (flag + data byte == 9 bits) from a matrix of data depending on the marked port in selectVector that wants to send over the port on which this function is currently being executed.
-    FUNCTION select_nchar(selectVector : STD_LOGIC_VECTOR(numports DOWNTO 0); bits : array_t(numports DOWNTO 0)(8 DOWNTO 0)) RETURN STD_LOGIC_VECTOR; -- select7x1xVector9
+    FUNCTION select7x1(selectBit : STD_LOGIC_VECTOR(numports DOWNTO 0); bits : STD_LOGIC_VECTOR(numports DOWNTO 0)) RETURN STD_LOGIC;
+    FUNCTION select7x1xVector9(selectVector : STD_LOGIC_VECTOR(numports DOWNTO 0); bits : array_t(numports DOWNTO 0)(8 DOWNTO 0)) RETURN STD_LOGIC_VECTOR;
 END PACKAGE;
 
 PACKAGE BODY spwrouterfunc IS
-    FUNCTION select_port (selectBit : STD_LOGIC_VECTOR(numports DOWNTO 0); bits : STD_LOGIC_VECTOR(numports DOWNTO 0)) RETURN STD_LOGIC IS -- select7x1
+    FUNCTION select7x1 (selectBit : STD_LOGIC_VECTOR(numports DOWNTO 0); bits : STD_LOGIC_VECTOR(numports DOWNTO 0)) RETURN STD_LOGIC IS
+        VARIABLE cond : STD_LOGIC;
     BEGIN
         RETURN OR (selectBit AND bits); -- Operator overloading (or)
-    END select_port;
+    END select7x1;
 
-    FUNCTION select_nchar(selectVector : STD_LOGIC_VECTOR(numports DOWNTO 0); bits : array_t(numports DOWNTO 0)(8 DOWNTO 0)) RETURN STD_LOGIC_VECTOR IS -- select7x1xVector9
+    FUNCTION select7x1xVector9(selectVector : STD_LOGIC_VECTOR(numports DOWNTO 0); bits : array_t(numports DOWNTO 0)(8 DOWNTO 0)) RETURN STD_LOGIC_VECTOR IS
         VARIABLE vec : STD_LOGIC_VECTOR(8 DOWNTO 0) := (OTHERS => '0');
     BEGIN
-        FOR i IN 0 TO numports LOOP
+        FOR i IN 0 TO numports LOOP -- reihenfolge vertauscht: normalerweise umgekehrt um gleiche prio zu behalten. in diesem fall geht dies aber nicht, da in jeder if abfrage ein return statement ist womit stehts nur bis zur ersten erf�llten bedingung durchlaufen wird und nicht automatisch alle
             IF (selectVector(i) = '1') THEN
                 vec := bits(i);
-                RETURN vec; -- because of this return statement it isn't necessary to reverse prioritization ! (Maybe it works the same if the return statement inside the if-statement is removed (just that towards the end of the function) and the order is reversed (numports DOWNTO 0))
+                RETURN vec;
             END IF;
         END LOOP;
 
         RETURN vec;
-    END select_nchar;
-END PACKAGE BODY;
\ No newline at end of file
+    END select7x1xVector9;
+END PACKAGE BODY;
+-- Instructions:
+
+--architecture beh of test is
+--    package test_pkg is new work.spwrouterfunc
+--        generic map (numports => numports);
+--
+-- https://stackoverflow.com/questions/43324918/vhdl-function-procedure-for-any-type-of-array
\ No newline at end of file
diff --git a/trunk/rtl/vhdl/spwrouterpkg.vhd b/trunk/rtl/vhdl/spwrouterpkg.vhd
index f953127..25da1e7 100644
--- a/trunk/rtl/vhdl/spwrouterpkg.vhd
+++ b/trunk/rtl/vhdl/spwrouterpkg.vhd
@@ -5,20 +5,20 @@
 -- Create Date: 31.07.2021 14:59
 -- Design Name: SpaceWire Router Package
 -- Module Name: spwrouterpkg
--- Project Name: Bachelor Thesis: Implementation of a SpaceWire Router on an FPGA
--- Target Devices: Xilinx FPGAs
--- Tool Versions: -/-
+-- Project Name: Bachelor Thesis: Implementation of a SpaceWire Router on a FPGA
+-- Target Devices: 
+-- Tool Versions: 
 -- Description: Contains type and component definitions of spwrouter elements.
 --
 -- Dependencies: none
 -- 
--- Revision: 1.0
+-- Revision:
 ----------------------------------------------------------------------------------
 
-LIBRARY IEEE;
-USE IEEE.STD_LOGIC_1164.ALL;
-USE IEEE.NUMERIC_STD.ALL;
-USE WORK.SPWPKG.ALL;
+LIBRARY ieee;
+USE ieee.std_logic_1164.ALL;
+USE ieee.numeric_std.ALL;
+USE work.spwpkg.ALL;
 
 PACKAGE spwrouterpkg IS
     -- Type declarations:
@@ -74,7 +74,7 @@ PACKAGE spwrouterpkg IS
     TYPE matrix_t IS ARRAY(NATURAL RANGE <>, NATURAL RANGE <>) OF STD_LOGIC;
 
     -- Component declarations:
-    -- Round Robin arbiter (spwrouterarb_table.vhd).
+    -- Round Robin Arbiter (spwrouterarb_table.vhd)
     COMPONENT spwrouterarb_round IS
         GENERIC (
             numports : INTEGER RANGE 0 TO 31;
@@ -83,29 +83,28 @@ PACKAGE spwrouterpkg IS
         PORT (
             clk : IN STD_LOGIC;
             rst : IN STD_LOGIC;
-            occupied : IN STD_LOGIC;
-            request : IN STD_LOGIC_VECTOR(numports DOWNTO 0);
-            granted : OUT STD_LOGIC_VECTOR(numports DOWNTO 0)
+            occ : IN STD_LOGIC;
+            req : IN STD_LOGIC_VECTOR(numports DOWNTO 0);
+            grnt : OUT STD_LOGIC_VECTOR(numports DOWNTO 0)
         );
     END COMPONENT;
 
-    -- Port arbiter (spwrouterarb.vhd).
+    -- (spwrouterarb.vhd)
     COMPONENT spwrouterarb IS
         GENERIC (
-            numports : INTEGER RANGE 0 TO 31;
-            blen : INTEGER RANGE 0 TO 5
+            numports : INTEGER RANGE 0 TO 31
         );
         PORT (
             clk : IN STD_LOGIC;
             rst : IN STD_LOGIC;
-            destport : IN array_t(numports DOWNTO 0)(7 DOWNTO 0);
-            request : IN STD_LOGIC_VECTOR(numports DOWNTO 0);
-            granted : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
-            routing_matrix : OUT array_t(numports DOWNTO 0)(numports DOWNTO 0)
+            dest : IN array_t(numports DOWNTO 0)(7 DOWNTO 0); -- hier ersten Index umgedreht
+            req : IN STD_LOGIC_VECTOR(numports DOWNTO 0);
+            grnt : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
+            rout : OUT array_t(numports DOWNTO 0)(numports DOWNTO 0) -- hier ersten Index umgedreht
         );
     END COMPONENT;
 
-    -- Time Code controller (spwroutertcc.vhd).
+    -- Time Code Controller (spwroutertcc.vhd)
     COMPONENT spwroutertcc IS -- geändert am 04.06.2022
         GENERIC (
             numports : INTEGER RANGE 0 TO 31
@@ -115,7 +114,7 @@ PACKAGE spwrouterpkg IS
             rst : IN STD_LOGIC;
             running : IN STD_LOGIC_VECTOR(numports DOWNTO 0);
             tc_enable : IN STD_LOGIC_VECTOR(numports DOWNTO 0);
-            tc_last : OUT STD_LOGIC_VECTOR(7 DOWNTO 0);
+            tc_last : OUT STD_LOGIC_VECTOR(7 DOWNTO 0);            
             tick_out : OUT STD_LOGIC_VECTOR(numports DOWNTO 0);
             tick_in : IN STD_LOGIC_VECTOR(numports DOWNTO 0);
             tc_out : OUT array_t(numports DOWNTO 0)(7 DOWNTO 0);
@@ -125,25 +124,25 @@ PACKAGE spwrouterpkg IS
         );
     END COMPONENT;
 
-    -- Router table (spwroutertable.vhd).
-    COMPONENT spwroutertable IS -- geändert am 07.06.2022
+    -- Router Table (spwroutertable.vhd)
+    COMPONENT spwroutertable IS
         GENERIC (
             numports : INTEGER RANGE 0 TO 31
         );
         PORT (
             clk : IN STD_LOGIC;
             rst : IN STD_LOGIC;
-            ack_in : IN STD_LOGIC;
+            act : IN STD_LOGIC;
             readwrite : IN STD_LOGIC;
             dByte : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
             addr : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
             wdata : IN STD_LOGIC_VECTOR(31 DOWNTO 0);
             rdata : OUT STD_LOGIC_VECTOR(31 DOWNTO 0);
-            ack_out : OUT STD_LOGIC
+            proc : OUT STD_LOGIC
         );
     END COMPONENT;
 
-    -- Control register (spwrouterregs.vhd).
+    -- Control Register (spwrouterregs.vhd)
     COMPONENT spwrouterregs IS
         GENERIC (
             numports : INTEGER RANGE 0 TO 31
@@ -174,17 +173,17 @@ PACKAGE spwrouterpkg IS
         PORT (
             clk : IN STD_LOGIC;
             rst : IN STD_LOGIC;
-            request : IN STD_LOGIC_VECTOR(numports DOWNTO 0);
-            granted : OUT STD_LOGIC_VECTOR(numports DOWNTO 0)
+            req : IN STD_LOGIC_VECTOR(numports DOWNTO 0);
+            grnt : OUT STD_LOGIC_VECTOR(numports DOWNTO 0)
         );
     END COMPONENT;
 
-    -- Router port (spwrouterport.vhd).
+    -- Router Port (spwrouterport.vhd)
     COMPONENT spwrouterport IS
         GENERIC (
             numports : INTEGER RANGE 0 TO 31;
             blen : INTEGER RANGE 0 TO 5;
-            --pnum : INTEGER RANGE 0 TO 31;
+            pnum : INTEGER RANGE 0 TO 31;
             sysfreq : real;
             txclkfreq : real := 0.0;
             rximpl : spw_implementation_type_rec;
@@ -206,11 +205,8 @@ PACKAGE spwrouterpkg IS
             tick_in : IN STD_LOGIC;
             time_in : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
             txdata : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
-            txrdy : OUT STD_LOGIC;
-            txhalff : OUT STD_LOGIC;
             tick_out : OUT STD_LOGIC;
             time_out : OUT STD_LOGIC_VECTOR(7 DOWNTO 0);
-            rxhalff : OUT STD_LOGIC;
             rxdata : OUT STD_LOGIC_VECTOR(8 DOWNTO 0);
             started : OUT STD_LOGIC;
             connecting : OUT STD_LOGIC;
@@ -219,28 +215,28 @@ PACKAGE spwrouterpkg IS
             errpar : OUT STD_LOGIC;
             erresc : OUT STD_LOGIC;
             errcred : OUT STD_LOGIC;
+            linkUp : IN STD_LOGIC_VECTOR(numports DOWNTO 0);
+            requestOut : OUT STD_LOGIC;
+            destinationPortOut : OUT STD_LOGIC_VECTOR(7 DOWNTO 0);
+            sourcePortOut : OUT STD_LOGIC_VECTOR(blen DOWNTO 0);
+            grantedIn : IN STD_LOGIC;
+            strobeOut : OUT STD_LOGIC;
+            readyIn : IN STD_LOGIC;
+            requestIn : IN STD_LOGIC;
+            strobeIn : IN STD_LOGIC;
+            readyOut : OUT STD_LOGIC;
+            busMasterAddressOut : OUT STD_LOGIC_VECTOR(31 DOWNTO 0);
+            busMasterDataIn : IN STD_LOGIC_VECTOR(31 DOWNTO 0);
+            busMasterDataOut : OUT STD_LOGIC_VECTOR(31 DOWNTO 0);
+            busMasterByteEnableOut : OUT STD_LOGIC_VECTOR(3 DOWNTO 0);
+            busMasterWriteEnableOut : OUT STD_LOGIC;
+            busMasterStrobeOut : OUT STD_LOGIC;
+            busMasterRequestOut : OUT STD_LOGIC;
+            busMasterAcknowledgeIn : IN STD_LOGIC;
             spw_di : IN STD_LOGIC;
             spw_si : IN STD_LOGIC;
             spw_do : OUT STD_LOGIC;
-            spw_so : OUT STD_LOGIC;
-            linkstatus : IN STD_LOGIC_VECTOR(numports DOWNTO 0);
-            request_out : OUT STD_LOGIC;
-            request_in : IN STD_LOGIC;
-            destination_port : OUT STD_LOGIC_VECTOR(7 DOWNTO 0);
-            --sourcePortOut : OUT STD_LOGIC_VECTOR(blen DOWNTO 0);
-            arb_granted : IN STD_LOGIC;
-            strobe_out : OUT STD_LOGIC;
-            strobe_in : IN STD_LOGIC;
-            ready_in : IN STD_LOGIC;
-            --readyOut : OUT STD_LOGIC;
-            bus_address : OUT STD_LOGIC_VECTOR(31 DOWNTO 0);
-            bus_data_in : IN STD_LOGIC_VECTOR(31 DOWNTO 0);
-            --busMasterDataOut : OUT STD_LOGIC_VECTOR(31 DOWNTO 0);
-            bus_dByte : OUT STD_LOGIC_VECTOR(3 DOWNTO 0);
-            bus_readwrite : OUT STD_LOGIC;
-            bus_strobe : OUT STD_LOGIC;
-            bus_request : OUT STD_LOGIC;
-            bus_ack_in : IN STD_LOGIC
+            spw_so : OUT STD_LOGIC
         );
     END COMPONENT;
 
diff --git a/trunk/rtl/vhdl/spwrouterport.vhd b/trunk/rtl/vhdl/spwrouterport.vhd
index dd823b2..e4c3934 100644
--- a/trunk/rtl/vhdl/spwrouterport.vhd
+++ b/trunk/rtl/vhdl/spwrouterport.vhd
@@ -3,35 +3,34 @@
 -- Engineer: Stefan Lindoerfer
 -- 
 -- Create Date: 11.08.2021 21:27
--- Design Name: SpaceWire Router -- SpaceWire Port (Container for spwstream)
+-- Design Name: SpaceWire Router Port
 -- Module Name: spwrouterport
--- Project Name: Bachelor Thesis: Implementation of a SpaceWire Router on an FPGA
--- Target Devices: Xilinx FPGAs
--- Tool Versions: -/-
--- Description: Container of SpaceWire IP Core Light (spwstream) for SpaceWire
--- Router Implementation.
+-- Project Name: Bachelor Thesis: Implementation of a SpaceWire Router on a FPGA
+-- Target Devices: 
+-- Tool Versions: 
+-- Description: Container of SpaceWire IP Core Light for Router Implementation.
 --
--- Dependencies: spwstream (spwpkg), spwrouterportstates (spwrouterpkg)
+-- Dependencies: none
 -- 
--- Revision: 0.9
+-- Revision:
 ----------------------------------------------------------------------------------
 
-LIBRARY IEEE;
-USE IEEE.STD_LOGIC_1164.ALL;
-USE IEEE.NUMERIC_STD.ALL;
-USE WORK.SPWROUTERPKG.ALL;
-USE WORK.SPWPKG.ALL;
+LIBRARY ieee;
+USE ieee.std_logic_1164.ALL;
+USE ieee.numeric_std.ALL;
+USE work.spwrouterpkg.ALL;
+USE work.spwpkg.ALL;
 
 ENTITY spwrouterport IS
     GENERIC (
         -- Number of SpaceWire ports.
         numports : INTEGER RANGE 0 TO 31;
 
-        -- Bit length to map number of ports (ceil(log2(numports))).
+        -- Bit length to map ports.
         blen : INTEGER RANGE 0 TO 5; -- (max 5 bits for 0-31 ports)
 
-        -- Number of this port (0 to numports).
-        --pnum : INTEGER RANGE 0 TO 31;
+        -- Port number.
+        pnum : INTEGER RANGE 0 TO 31;
 
         -- System clock frequency in Hz.
         -- This must be set to the frequency of "clk". It is used to setup
@@ -51,8 +50,7 @@ ENTITY spwrouterport IS
         -- (must be 1 in case of impl_generic).
         rxchunk : INTEGER RANGE 1 TO 4 := 1;
 
-        -- Width of shift registers in clock recovery front-end 
-        -- (only needed if impl_clkrec is used); added: SL
+        -- Width of shift registers in clock recovery front-end; added: SL
         WIDTH : INTEGER RANGE 1 TO 3 := 2;
 
         -- Selection of a transmitter implementation.
@@ -66,70 +64,56 @@ ENTITY spwrouterport IS
         txfifosize_bits : INTEGER RANGE 2 TO 14 := 11
     );
     PORT (
-        -- ====================================
-        --      SPACEWIRE PORT (spwstream)
-        -- ====================================
         -- System clock.
-        clk : IN STD_LOGIC;
+        clk : IN STD_LOGIC; -- clock
 
-        -- Receiver sample clock (only for impl_fast).
-        rxclk : IN STD_LOGIC;
+        -- Receiver sample clock (only for impl_fast)
+        rxclk : IN STD_LOGIC; -- receiveclock
 
-        -- Transmit clock (only for impl_fast).
-        txclk : IN STD_LOGIC;
+        -- Transmit clock (only for impl_fast)
+        txclk : IN STD_LOGIC; -- transmitclock
 
         -- Synchronous reset (active-high).
-        rst : IN STD_LOGIC;
+        rst : IN STD_LOGIC; -- reset
 
         -- Enables automatic link start on receipt of a NULL character.
-        autostart : IN STD_LOGIC;
+        autostart : IN STD_LOGIC; -- autoStart
 
         -- Enables link start once the Ready state is reached.
         -- Without autostart or linkstart, the link remains in state Ready.
-        linkstart : IN STD_LOGIC;
+        linkstart : IN STD_LOGIC; -- linkStart
 
         -- Do not start link (overrides linkstart and autostart) and/or
         -- disconnect a running link.
-        linkdis : IN STD_LOGIC;
+        linkdis : IN STD_LOGIC; -- linkDisable
 
         -- Scaling factor minus 1, used to scale the transmit base clock into
         -- the transmission bit rate. The system clock (for impl_generic) or
         -- the txclk (for impl_fast) is divided by (unsigned(txdivcnt) + 1).
         -- Changing this signal will immediately change the transmission rate.
         -- During link setup, the transmission rate is always 10 Mbit/s.
-        txdivcnt : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
+        txdivcnt : IN STD_LOGIC_VECTOR(7 DOWNTO 0); -- transmitClockDivide
 
         -- High for one clock cycle to request transmission of a TimeCode.
         -- The request is registered inside the entity until it can be processed.
-        tick_in : IN STD_LOGIC;
+        tick_in : IN STD_LOGIC; -- tickIn
 
-        -- Time-code (control bits and counter value) to be send. Must be valid 
-        -- when tick_in is high.
-        time_in : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
+        -- Time-code (control bits and counter value) to be send. Must be valid when tick_in is high.
+        time_in : IN STD_LOGIC_VECTOR(7 DOWNTO 0); -- enthält ctrl_in und time_in
 
-        -- Control flag and data byte so to be sent. Set control flag low to send
-        -- a data byte, or high and data to 0x00 to send EOP or 0x01 for EEP.
+        -- Control flag and data byte so to be sent. Set control flag low to send a data byte, or
+        -- high and data to 0x00 to send EOP or 0x01 for EEP. Must be valid while txwrite is high.
         txdata : IN STD_LOGIC_VECTOR(8 DOWNTO 0); -- contains txflag and txdata
 
-        -- High if port is ready to accept an N-Char for transmission FIFO.
-        txrdy : OUT STD_LOGIC;
-
-        -- High if the transmit FIFO is at least half full.
-        txhalff : OUT STD_LOGIC;
-
         -- High for one clock cycle if a time-code was just received.
-        tick_out : OUT STD_LOGIC;
+        tick_out : OUT STD_LOGIC; -- check
 
         -- Control bits and counter value of last received time-code.
-        time_out : OUT STD_LOGIC_VECTOR(7 DOWNTO 0);
+        time_out : OUT STD_LOGIC_VECTOR(7 DOWNTO 0); -- contains ctrl_out and time_out
 
-        -- High if the receive FIFO is at least half full.
-        rxhalff : OUT STD_LOGIC;
-
-        -- Received byte and control flag. Control flag is high if the received 
-        -- character is EOP (data is 0x00) or EEP (0x01); low if received character
-        -- is a data byte.
-        rxdata : OUT STD_LOGIC_VECTOR(8 DOWNTO 0);
+        -- Received byte and control flag. Control flag is high if the received character is EOP (data
+        -- is 0x00) or EEP (0x01); low if received character is a data byte. Valid if rxvalid is high. 
+        rxdata : OUT STD_LOGIC_VECTOR(8 DOWNTO 0); -- contains rxflag and rxdata
 
         -- High if the link state machine is in the started state.
         started : OUT STD_LOGIC;
@@ -137,9 +121,9 @@ ENTITY spwrouterport IS
         -- High if the link state machine is in the connecting state.
         connecting : OUT STD_LOGIC;
 
-        -- High if the link state machine is in the run state, indicating that the 
-        -- link is operational. If started, connecting and rannung are all low,
-        -- the link is in an initial state with the transmitter disabled.
+        -- High if the link state machine is in the run state, indicating that the link is operational.
+        -- If started, connecting and rannung are all low, the link is in an initial state with the
+        -- transmitter disabled.
         running : OUT STD_LOGIC;
 
         -- Disconnection detected in the run state. Triggers a link reset; auto-clearing.
@@ -154,137 +138,132 @@ ENTITY spwrouterport IS
         -- Credit error detected. Triggers a link reset; auto-clearing
         errcred : OUT STD_LOGIC;
 
-        -- SpaceWire data in.
-        spw_di : IN STD_LOGIC;
+        -- Shows which port is in the running state.
+        linkUp : IN STD_LOGIC_VECTOR(numports DOWNTO 0);
 
-        -- SpaceWire strobe in.
-        spw_si : IN STD_LOGIC;
+        -- Makes a data transfer request for a new packet.
+        requestOut : OUT STD_LOGIC; -- requestOut
 
-        -- SpaceWire data out.
-        spw_do : OUT STD_LOGIC;
+        -- Contains the binary code of the destination port of the packet.
+        -- Applies to both physical and logical addressing.
+        destinationPortOut : OUT STD_LOGIC_VECTOR(7 DOWNTO 0); -- destinationPortOut
 
-        -- SpaceWire strobe out.
-        spw_so : OUT STD_LOGIC;
+        -- The binary form (number) of the this port.
+        sourcePortOut : OUT STD_LOGIC_VECTOR(blen DOWNTO 0); -- sourcePortOut
 
-        -- ====================================
-        --           ROUTER SIGNALS
-        -- ====================================
-        -- Shows which port is in running state (is able to receive or transmit data).
-        linkstatus : IN STD_LOGIC_VECTOR(numports DOWNTO 0); -- linkUp
+        -- High if the port gets permission for data transfer.
+        grantedIn : IN STD_LOGIC; -- grantedIn
 
-        -- High as long as a packet is sent from this port via the router to another port.
-        request_out : OUT STD_LOGIC; -- requestOut
+        -- Indicates whether a data transfer is currently taking place.
+        strobeOut : OUT STD_LOGIC; -- strobeOut
 
-        -- High as long as packet ist sent via this port.
-        request_in : IN STD_LOGIC; -- requestIn
+        -- Indicates whether a data transfer is allowed to be carried out.
+        readyIn : IN STD_LOGIC; -- readyIn
 
-        -- First byte of a packet (address byte) with destination port (both physical
-        -- and logical addressing).
-        destination_port : OUT STD_LOGIC_VECTOR(7 DOWNTO 0); -- destinationPortOut
+        -- Is used to signal in port whether writing can be done in transmission memory.
+        requestIn : IN STD_LOGIC; -- requestIn
 
-        -- The binary form (number) of the this port.
-        --source_port : OUT STD_LOGIC_VECTOR(blen DOWNTO 0); -- sourcePortOut
+        -- Show when a data transfer takes place. High at the same time when dataOut
+        -- receives a new byte.
+        strobeIn : IN STD_LOGIC; -- strobeIn
 
-        -- High if the port gets permission from router arbiter for data transfer.
-        arb_granted : IN STD_LOGIC; -- grantedIn
+        -- Indicates whether the transmission fifo is ready to accept data.
+        readyOut : OUT STD_LOGIC; -- readyOut
 
-        -- High if data byte or EOP/EEP is ready to transfer to destination port.
-        strobe_out : OUT STD_LOGIC; -- strobeOut
+        -- The address to access the router control register.
+        busMasterAddressOut : OUT STD_LOGIC_VECTOR(31 DOWNTO 0); -- busMasterAddressOut
 
-        -- High if transmission via this port should be performed (new byte still on txdata).
-        strobe_in : IN STD_LOGIC; -- strobeIn
+        -- Is in this entity exclusively from the routing table and contains the 
+        -- assignment of a logical port to the physical output.
+        busMasterDataIn : IN STD_LOGIC_VECTOR(31 DOWNTO 0); -- busMasterDataIn
 
-        -- High if destination port is ready to accept next N-Char.
-        ready_in : IN STD_LOGIC; -- readyIn
+        -- Data to be written into router control register. Is always 0x0000_0000.
+        busMasterDataOut : OUT STD_LOGIC_VECTOR(31 DOWNTO 0); -- busMasterDataOut
 
-        -- ====================================
-        --            INTERNAL BUS
-        -- ====================================
-        -- The address to access the router control register.
-        bus_address : OUT STD_LOGIC_VECTOR(31 DOWNTO 0); -- busMasterAddressOut
+        -- Defines which byte (1-4) in the router control register is to be 
+        -- overwritten. Is always 1111.
+        busMasterByteEnableOut : OUT STD_LOGIC_VECTOR(3 DOWNTO 0); -- busMasterByteEnableOut
 
-        -- Routing table entry for requested logical port.
-        bus_data_in : IN STD_LOGIC_VECTOR(31 DOWNTO 0); -- busMasterDataIn
+        -- High if a write process; low is a read process is to be carried out into
+        -- router control register.
+        busMasterWriteEnableOut : OUT STD_LOGIC; -- busMasterWriteEnableOut
 
-        -- Data to be written into router control register. Is always 0x0000_0000.
-        --bus_data_out : OUT STD_LOGIC_VECTOR(31 DOWNTO 0); -- busMasterDataOut (wenn ausblenden nicht funktioniert oder undurchsichtig ist, wieder entkommentieren und einfach 'open' machen)
+        -- Shows activity / occupation of the routing table.
+        busMasterStrobeOut : OUT STD_LOGIC; -- busMasterStrobeOut
 
-        -- Defines which byte (1-4) in the router control register is to be read.
-        bus_dByte : OUT STD_LOGIC_VECTOR(3 DOWNTO 0); -- busMasterByteEnableOut
+        -- Indicates whether this port needs access to the routing table.
+        busMasterRequestOut : OUT STD_LOGIC; -- busMasterRequestOut
 
-        -- High if a write process; low is a read process shall be performed
-        -- in router registers.
-        bus_readwrite : OUT STD_LOGIC; -- busMasterWriteEnableOut
+        -- 
+        busMasterAcknowledgeIn : IN STD_LOGIC; -- busMasterAcknowledgeIn
 
-        -- Strobe signal to routing table.
-        bus_strobe : OUT STD_LOGIC; -- busMasterStrobeOut
+        -- SpaceWire data in.
+        spw_di : IN STD_LOGIC; -- check
 
-        -- In this context also strobe signal to routing table.
-        bus_request : OUT STD_LOGIC; -- busMasterRequestOut
+        -- SpaceWire strobe in.
+        spw_si : IN STD_LOGIC; -- check
 
-        -- Acknowledgment to get access to routing table.
-        bus_ack_in : IN STD_LOGIC -- busMasterAcknowledgeIn
+        -- SpaceWire data out.
+        spw_do : OUT STD_LOGIC; -- check
+
+        -- SpaceWire strobe out.
+        spw_so : OUT STD_LOGIC -- check
     );
 END spwrouterport;
 
 ARCHITECTURE spwrouterport_arch OF spwrouterport IS
-    -- Finite state machine state.
-    SIGNAL state : spwrouterportstates := S_Idle; -- check 
-
-    -- Packet cargo (excluding first byte (address byte)).
-    -- According to spwstream: flag = 0 -> data byte
-    --                         flag = 1 -> EOP / EEP
-    SIGNAL s_packet_cargo : STD_LOGIC_VECTOR(8 DOWNTO 0) := (OTHERS => '0'); -- iDataOut
-
-    -- Routing table.
-    SIGNAL s_logical_address : STD_LOGIC_VECTOR(7 DOWNTO 0) := (OTHERS => '0'); -- iRoutingTableAddress -- Contains logical port address (32-254)
-    SIGNAL s_routing_table_request : STD_LOGIC; -- iRoutingTableRequest -- High if data from router table is requested. Is maintained until routing table has confirmed via handshake that data is available
-
-    -- Xmit signals.
-    SIGNAL s_txwrite : STD_LOGIC; -- txwrite -- Set High to write a character to transmit FIFO of the port.
-    --SIGNAL s_txdata : STD_LOGIC_VECTOR(8 DOWNTO 0) := (OTHERS => '0'); -- txdata -- Contains control flag (txflag) and data byte (txdata) (for more information see spwstream). (Wird augenscheinlich nicht benötigt, direkt vom Eingangsport lesen!)
-    SIGNAL s_txrdy : STD_LOGIC; -- iTransmitFIFOReady gelöscht! -- High if spwstream is ready to accept a character for transmit FIFO.
-    SIGNAL s_txhalff : STD_LOGIC;
-
-    -- Recv signals.
-    SIGNAL s_rxread : STD_LOGIC; -- rxread -- Set High to accept a received character. A character is removed from the receive FIFO.
-    SIGNAL s_rxvalid : STD_LOGIC; -- rxvalid -- High if rxflag and rxdata contain valid data.
-    SIGNAL s_rxdata : STD_LOGIC_VECTOR(8 DOWNTO 0); -- rxdata -- Used to identify received data (single EOP/EEP, N-Char, ...)
-    SIGNAL s_rxflag_buffer : STD_LOGIC; -- Buffers flag of received N-chars
-    SIGNAL s_rxdata_buffer : STD_LOGIC_VECTOR(7 DOWNTO 0); -- Fetches received bytes from the port and buffers them
-    SIGNAL s_rxhalff : STD_LOGIC; --
-
-    -- Bus & router signals.
-    SIGNAL s_strobe_out : STD_LOGIC; -- iStrobeOut -- Strobe signal to destination port when cargo/EOP/EEP byte need to be transmitted.
-    --SIGNAL s_ready_out : STD_LOGIC; -- iReadyOut -- Scheint das gleiche wie s_txrdy zu sein. (erstmal gestrichen, wegoptimiert, mal schauen ob das ein fehler war)
-    SIGNAL s_request_out : STD_LOGIC; -- iRequestOut -- High as long as a packet is started and sent, not yet completed.
-    SIGNAL s_destination_port : STD_LOGIC_VECTOR(7 DOWNTO 0) := (OTHERS => '0'); -- iDestinationPortOut -- Contains first byte of a packet (address byte)
+    -- Finite state machine states.
+    SIGNAL state : spwrouterportstates;-- := S_Idle; -- check 
+
+    -- Contains paket cargo only (none port addresses) -- Enthält nur Datenbytes, nicht das erste Byte das die Zielportadresse darstellt
+    SIGNAL iDataOut : STD_LOGIC_VECTOR(8 DOWNTO 0);
+
+    -- Routing Tabelle
+    -- De facto logical port number (32-254).
+    SIGNAL iRoutingTableAddress : STD_LOGIC_VECTOR(7 DOWNTO 0);-- := (others => '0');
+    -- Anfrage an Routing Tabelle.
+    SIGNAL iRoutingTableRequest : STD_LOGIC;
+
+    -- Transmission-specific signals.
+    SIGNAL iTransmitFIFOWriteEnable : STD_LOGIC; -- txwrite
+    SIGNAL iTransmitFIFODataIn : STD_LOGIC_VECTOR(8 DOWNTO 0); -- txdata
+    SIGNAL iTransmitFIFOReady : STD_LOGIC; -- txrdy
+
+    -- Reception-specific signals.
+    SIGNAL iReceiveFIFOReadEnable : STD_LOGIC; -- rxread
+    SIGNAL iReceiveFIFOReady : STD_LOGIC; -- rxvalid
+    SIGNAL receiveFIFODataOut : STD_LOGIC_VECTOR(8 DOWNTO 0);-- := (others => '0'); -- rxdata -- testweise initialisiert!
+
+    -- Intermediate signals (werden nur an Ausgänge unter 'Drive outputs' drangehängt)
+    SIGNAL iStrobeOut : STD_LOGIC;
+    SIGNAL iReadyOut : STD_LOGIC;
+    SIGNAL iRequestOut : STD_LOGIC;
+    SIGNAL iDestinationPortOut : STD_LOGIC_VECTOR(7 DOWNTO 0);
+    SIGNAL s_txrdy : STD_LOGIC;
+
+    SIGNAL s_rxflag : STD_LOGIC; -- speichert das Flag eines packets zwischen
+    SIGNAL s_rxdata : STD_LOGIC_VECTOR(7 DOWNTO 0); -- dito
 BEGIN
-    -- Drive outputs.
-    -- Bus & router signals.
-    --source_port <= STD_LOGIC_VECTOR(to_unsigned(pnum, source_port'length));
-    destination_port <= s_destination_port;
-    request_out <= s_request_out;
-    strobe_out <= s_strobe_out;
-    rxdata <= s_packet_cargo; -- dataOut
-    bus_request <= s_routing_table_request;
-    bus_strobe <= s_routing_table_request;
-    bus_address <= (9 DOWNTO 2 => s_logical_address, OTHERS => '0'); -- Necessary so that the correct entry is addressed in router table
-    bus_readwrite <= '0'; -- perform read operations only
-    bus_dByte <= (OTHERS => '1'); -- always select all four bytes
-    --bus_data_out <= (OTHERS => '0'); -- Keine Ahnung wieso das nötig ist (wird mal auf null gesetzt)
-    -- Port signals.
-    rxhalff <= s_rxhalff;
-    txhalff <= s_txhalff;    
-    --txrdy <= s_txrdy;
-    
-    -- Read inputs.
-    s_txwrite <= strobe_in WHEN request_in = '1' ELSE
+    -- Drive outputs
+    sourcePortOut <= STD_LOGIC_VECTOR(to_unsigned(pnum, sourcePortOut'length));
+    destinationPortOut <= iDestinationPortOut;
+    requestOut <= iRequestOut;
+    strobeOut <= iStrobeOut;
+    rxdata <= iDataOut; -- dataOut
+    busMasterRequestOut <= iRoutingTableRequest;
+    busMasterStrobeOut <= iRoutingTableRequest;
+    busMasterAddressOut <= (9 DOWNTO 2 => iRoutingTableAddress, OTHERS => '0');
+    busMasterWriteEnableOut <= '0';
+    busMasterByteEnableOut <= (OTHERS => '1');
+    busMasterDataOut <= (OTHERS => '0');
+
+    -- Intermediate steps.
+    iTransmitFIFOWriteEnable <= strobeIn WHEN requestIn = '1' ELSE
         '0';
-    --s_txdata <= txdata; -- dataIn
-    --iTransmitFIFOReady <= s_txrdy;
-    --s_ready_out <= s_txrdy;
-
+    iTransmitFIFODataIn <= txdata; -- dataIn
+    iTransmitFIFOReady <= s_txrdy;
+    iReadyOut <= s_txrdy;
+    
     -- SpaceWire port.
     spwport : spwstream
     GENERIC MAP(
@@ -307,21 +286,21 @@ BEGIN
         linkdis => linkdis,
         txdivcnt => txdivcnt,
         tick_in => tick_in,
-        ctrl_in => time_in(7 DOWNTO 6), -- ctrl flag
-        time_in => time_in(5 DOWNTO 0), -- counter value
-        txflag => txdata(8), -- s_txdata(8) -- flag
-        txdata => txdata(7 DOWNTO 0), -- s_txdata(7 downto 0) -- data byte
-        txwrite => s_txwrite,
+        ctrl_in => time_in(7 DOWNTO 6),
+        time_in => time_in(5 DOWNTO 0),
+        txflag => iTransmitFIFODataIn(8),
+        txdata => iTransmitFIFODataIn(7 DOWNTO 0),
+        txwrite => iTransmitFIFOWriteEnable,
         txrdy => s_txrdy,
-        txhalff => s_txhalff,
+        txhalff => OPEN,
         tick_out => tick_out,
-        ctrl_out => time_out(7 DOWNTO 6), -- ctrl flag
-        time_out => time_out(5 DOWNTO 0), -- counter value
-        rxvalid => s_rxvalid,
-        rxhalff => s_rxhalff,
-        rxflag => s_rxflag_buffer,
-        rxdata => s_rxdata_buffer,
-        rxread => s_rxread,
+        ctrl_out => time_out(7 DOWNTO 6),
+        time_out => time_out(5 DOWNTO 0),
+        rxvalid => iReceiveFIFOReady,
+        rxhalff => OPEN,
+        rxflag => s_rxflag,
+        rxdata => s_rxdata,
+        rxread => iReceiveFIFOReadEnable,
         started => started,
         connecting => connecting,
         running => running,
@@ -334,215 +313,220 @@ BEGIN
         spw_do => spw_do,
         spw_so => spw_so
     );
-    
-    -- Infers a latch, but is necessary to maintain the signal so that the FSM of receiving port has enough time to react to it. TODO: Bad design, either rebuild in future or test thoroughly !
+
+    -- Synchronous update.
     PROCESS (clk)
     BEGIN
         IF rising_edge(clk) THEN
-            txrdy <= s_txrdy;--s_ready_out; -- s_ready_out
+            readyOut <= iReadyOut; -- check
         END IF;
     END PROCESS;
 
     -- Finite state machine.
-    PROCESS (clk)
+    PROCESS (clk, rst)
         VARIABLE v_validport : STD_LOGIC; -- S_Dest2; for boolean operationen
         VARIABLE v_reqports : STD_LOGIC; -- S_RT1
     BEGIN
-        IF rising_edge(clk) THEN
-            IF (rst = '1') THEN
-                -- Synchronous reset.
-                s_destination_port <= (OTHERS => '0');
-                s_packet_cargo <= (OTHERS => '0');
-                s_logical_address <= (OTHERS => '0');
-                s_rxdata <= (OTHERS => '0');
-                s_rxread <= '0';
-                s_request_out <= '0';
-                s_routing_table_request <= '0';
-                s_strobe_out <= '0';
-                state <= S_Idle;
-            ELSE
-                CASE state IS
-                    WHEN S_Idle =>
-                        -- If receive buffer is not empty, activate handshake to get packet byte by byte.
-
-                        s_strobe_out <= '0';
-
-                        IF (s_rxvalid = '1') THEN
-                            s_rxread <= '1'; -- rxread
-                            state <= S_Dest0;
-                        END IF;
+        IF (rst = '1') THEN -- reset
+            state <= S_Idle;
+            iReceiveFIFOReadEnable <= '0';
+            iRequestOut <= '0';
+            iDestinationPortOut <= (OTHERS => '0');
+            iDataOut <= (OTHERS => '0');
+            iStrobeOut <= '0';
+            iRoutingTableAddress <= (OTHERS => '0');
+            iRoutingTableRequest <= '0';
+            receiveFIFODataOut <= (OTHERS => '0');
+
+        ELSIF rising_edge(clk) THEN
+            CASE state IS
+                WHEN S_Idle =>
+                    -- If receive buffer is not empty, read data from the buffer.
+                    IF (iReceiveFIFOReady = '1') THEN
+                        iReceiveFIFOReadEnable <= '1'; -- rxread
+
+                        state <= S_Dest0;
+
+                    END IF;
+
+                    iStrobeOut <= '0';
+
+                WHEN S_Dest0 =>
+                    -- Wait to read data from buffer.
+                    receiveFIFODataOut(8) <= s_rxflag; -- per Handshake übernehmen
+                    receiveFIFODataOut(7 DOWNTO 0) <= s_rxdata;
+                    iReceiveFIFOReadEnable <= '0'; -- rxread
+                    state <= S_Dest1;
+
+                WHEN S_Dest1 =>
+                    -- Confirm first data logical address or physical port address.
+
+                    IF (receiveFIFODataOut(8) = '0') THEN -- vorher: receiveFIFODataOut(8)
+                        IF (receiveFIFODataOut(7 DOWNTO 5) = "000") THEN
+                            -- Physical port addressed.
+                            iDestinationPortOut <= receiveFIFODataOut(7 DOWNTO 0); -- enthält die Portnummer als erstes Byte eines Pakets!!
+
+                            IF (unsigned(receiveFIFODataOut(7 DOWNTO 0)) > numports) THEN
+                                -- Discard invalid addressed packet. (destination port does not exist)
+                                state <= S_Dummy0;
+
+                            ELSE
+                                state <= S_Dest2;
 
-                    WHEN S_Dest0 =>
-                        -- Wait to read first data byte from buffer.
-
-                        s_rxdata(8) <= s_rxflag_buffer;
-                        s_rxdata(7 DOWNTO 0) <= s_rxdata_buffer;
-                        s_rxread <= '0'; -- rxread -- take over via handshake
-                        state <= S_Dest1;
-
-                    WHEN S_Dest1 =>
-                        -- Look at first byte of a packet.
-
-                        IF (s_rxdata(8) = '0') THEN -- vorher: receiveFIFODataOut(8) -- Data byte
-                            IF (s_rxdata(7 DOWNTO 5) = "000") THEN -- DestPort <= 31 (physical port)
-                                -- Physical port addressed.
-                                s_destination_port <= s_rxdata(7 DOWNTO 0); -- Destination port number (first byte of packet)
-
-                                IF (unsigned(s_rxdata(7 DOWNTO 0)) > numports) THEN
-                                    -- Discard invalid addressed packet (destination port does not exist).
-                                    state <= S_Dummy0;
-                                ELSE
-                                    -- Destination port exists, packet can be delivered.
-                                    state <= S_Dest2;
-                                END IF;
-                            ELSE -- DestPort > 31 (logical port)
-                                -- Logical port is addressed: Send request to routing table to get port assignment.
-                                s_logical_address <= s_rxdata(7 DOWNTO 0);
-                                s_routing_table_request <= '1';
-                                state <= S_RT0;
                             END IF;
                         ELSE
-                            -- Single EOP / EEP.
-                            state <= S_Idle;
+                            -- Logical port is addressed. Send request to routing table to get port assignment.
+                            iRoutingTableAddress <= receiveFIFODataOut(7 DOWNTO 0);
+                            iRoutingTableRequest <= '1';
+                            state <= S_RT0;
+
                         END IF;
+                    ELSE
+                        -- Single EOP / EEP.
+                        state <= S_Idle;
 
-                    WHEN S_Dest2 =>
-                        -- (Reset variable for new iteration.)
-                        v_validport := '0';
+                    END IF;
 
-                        -- Transmit request to destination port.
-                        FOR i IN 1 TO numports LOOP -- Auf Port0 kann hiernach nicht gesendet werden, bitte überprüfen!
-                            IF (linkstatus(i) = '1' AND s_destination_port(blen DOWNTO 0) = STD_LOGIC_VECTOR(to_unsigned(i, blen + 1))) THEN
-                                v_validport := '1'; -- potenzielle Fehlerquelle mit blen+1 !! Im Original Code werden hier 5 Bits (4 downto 0) abgefragt. falls blen == 4 ist, muss folglich blen+1 für 5 gelten!
-                            END IF;
-                        END LOOP;
+                WHEN S_Dest2 =>
+                    -- Reset variable for new iteration.
+                    v_validport := '0';
 
-                        IF ((s_destination_port(blen DOWNTO 0) = STD_LOGIC_VECTOR(to_unsigned(0, blen + 1))) OR (v_validport = '1')) THEN
-                            -- Packet address matches available physical ports, packet can be sent through router.
-                            s_request_out <= '1';
-                            state <= S_Data0;
-                        ELSE
-                            -- Discard invalid addressed packet.
-                            state <= S_Dummy0;
+                    -- Transmit request to destination port.
+                    FOR i IN 1 TO numports LOOP
+                        IF (linkUp(i) = '1' AND iDestinationPortOut(blen DOWNTO 0) = STD_LOGIC_VECTOR(to_unsigned(i, blen + 1))) THEN
+                            v_validport := '1'; -- potenzielle Fehlerquelle mit blen+1 !! Im Original Code werden hier 5 Bits (4 downto 0) abgefragt. falls blen == 4 ist, muss folglich blen+1 für 5 gelten!
                         END IF;
+                    END LOOP;
 
-                    WHEN S_RT0 =>
-                        -- Wait acknowledge. (Hat wohl was damit zu tun, dass die gewünschte Information von der RT eingetroffen ist)
+                    IF ((iDestinationPortOut(blen DOWNTO 0) = STD_LOGIC_VECTOR(to_unsigned(0, blen + 1))) OR (v_validport = '1')) THEN
+                        iRequestOut <= '1';
+                        state <= S_Data0;
 
-                        IF (bus_ack_in = '1') THEN
-                            state <= S_RT1; -- RT == Routing table
-                        END IF;
+                    ELSE
+                        -- Discard invalid addressed packet.
+                        state <= S_Dummy0;
 
-                    WHEN S_RT1 =>
-                        -- (Reset variable for new iteration.)
-                        v_reqports := '0';
+                    END IF;
 
-                        -- Logical addressing: Request to data which is read from routing table.
+                WHEN S_RT0 =>
+                    -- Wait acknowledge. (Hat wohl was damit zu tun, dass die gewünschte Information von der RT eingetroffen ist)
+                    IF (busMasterAcknowledgeIn = '1') THEN
+                        state <= S_RT1; -- RT == Routing table
 
-                        s_routing_table_request <= '0';
+                    END IF;
 
-                        -- Changed priority! Normal order with If...Elsif would be from zero ascending.
-                        -- Since only single unconnected if queries can be generated, the order must be
-                        -- reversed (descending), since the last if query has the highes priority. (Can
-                        -- overwrite result again.)
-                        FOR i IN numports DOWNTO 0 LOOP
-                            IF (linkstatus(i) = '1' AND bus_data_in(i) = '1') THEN
-                                s_destination_port <= STD_LOGIC_VECTOR(to_unsigned(i, s_destination_port'length));
-                                s_request_out <= '1';
-                                state <= S_RT2;
+                WHEN S_RT1 =>
+                    -- Logical addressing: Request to data which is read from routing table.
+                    iRoutingTableRequest <= '0';
 
-                                -- Variable to compare in same cycle whether a port can be selected at all.
-                                v_reqports := '1';
-                            END IF;
-                        END LOOP;
+                    -- Reset variable for new iteration.
+                    v_reqports := '0';
 
-                        IF (v_reqports = '0') THEN -- discard invalid addressed packet if none 'if-statement' before was executed.
-                            state <= S_Dummy0;
-                        END IF;
+                    -- Changed priority!
+                    FOR i IN numports DOWNTO 0 LOOP
+                        IF (linkUp(i) = '1' AND busMasterDataIn(i) = '1') THEN
+                            iDestinationPortOut <= STD_LOGIC_VECTOR(to_unsigned(i, iDestinationPortOut'length));
+                            iRequestOut <= '1';
+                            state <= S_RT2;
 
-                    WHEN S_RT2 =>
-                        -- Wait for permission from arbiter (logical addresses access only).
+                            -- Variable to compare in same cycle whether a port can be selected at all.
+                            v_reqports := '1';
 
-                        IF (arb_granted = '1') THEN
-                            state <= S_Data2;
                         END IF;
+                    END LOOP;
 
-                    WHEN S_Data0 =>
-                        -- Wait for permission from arbiter and/or for new received N-chars of current packet (physical addresses only).
+                    IF (v_reqports = '0') THEN -- discard invalid addressed packet if none 'if-statement' before was executed.
+                        state <= S_Dummy0;
 
-                        s_strobe_out <= '0';
+                    END IF;
 
-                        IF (arb_granted = '1' AND s_rxvalid = '1') THEN
-                            s_rxread <= '1';
-                            state <= S_Data1;
-                        END IF;
-
-                    WHEN S_Data1 =>
-                        -- Wait to read from data receive buffer.
-                        s_strobe_out <= '0';
-                        s_rxdata(8) <= s_rxflag_buffer; -- take over N-char via handshake
-                        s_rxdata(7 DOWNTO 0) <= s_rxdata_buffer;
-                        s_rxread <= '0';
+                WHEN S_RT2 =>
+                    -- Wait to permit (grnt) from arbiter (logical address access).
+                    IF (grantedIn = '1') THEN
                         state <= S_Data2;
 
-                    WHEN S_Data2 =>
-                        -- Send data which is read from rx buffer to destination port.
-
-                        IF (ready_in = '1') THEN
-                            s_strobe_out <= '1';
-                            s_packet_cargo <= s_rxdata;
-                            IF (s_rxdata(8) = '1') THEN
-                                -- EOP/EEP, means packet is complete.
-                                state <= S_Data3;
-                            ELSIF (arb_granted = '1' AND s_rxvalid = '1') THEN
-                                -- Continue reading bytes according to this packet.
-                                s_rxread <= '1';
-                                state <= S_Data1;
-                            ELSE
-                                -- None further byte available yet, wait for next data byte or an EOP/EEP.
-                                state <= S_Data0;
-                            END IF;
-                        END IF;
+                    END IF;
 
-                    WHEN S_Data3 =>
-                        -- Complete sending to destination port.
+                WHEN S_Data0 =>
+                    -- Wait to permit (grnt) from arbiter (physical address access).
+                    iStrobeOut <= '0';
 
-                        s_strobe_out <= '0';
-                        s_request_out <= '0';
-                        state <= S_Idle;
+                    IF (grantedIn = '1' AND iReceiveFIFOReady = '1') THEN
+                        iReceiveFIFOReadEnable <= '1';
+                        state <= S_Data1;
 
-                    WHEN S_Dummy0 =>
-                        -- Dummie states are there to throw away a packet that cannot be delivered.
-                        -- dummy read (may block forever) (Wie kann hier ein Deadlock konstruiert werden?)
+                    END IF;
 
-                        s_request_out <= '0';
+                WHEN S_Data1 =>
+                    -- Wait to read from data receive buffer.
+                    iStrobeOut <= '0';
 
-                        IF (s_rxvalid = '1') THEN
-                            s_rxread <= '1';
-                            state <= S_Dummy1;
-                        END IF;
+                    receiveFIFODataOut(8) <= s_rxflag; -- per Handshake übernehmen
+                    receiveFIFODataOut(7 DOWNTO 0) <= s_rxdata;
 
-                    WHEN S_Dummy1 =>
-                        -- Wait to read data from receive buffer.
+                    iReceiveFIFOReadEnable <= '0';
+                    state <= S_Data2;
 
-                        s_rxdata(8) <= s_rxflag_buffer; -- take over by handshake mechanism
-                        s_rxdata(7 DOWNTO 0) <= s_rxdata_buffer;
-                        s_rxread <= '0';
-                        state <= S_Dummy2;
+                WHEN S_Data2 =>
+                    -- Send data which is read from rx buffer to destination port.
+                    IF (readyIn = '1') THEN
+                        iStrobeOut <= '1';
+                        iDataOut <= receiveFIFODataOut;
+                        IF (receiveFIFODataOut(8) = '1') THEN
+                            -- EOP/EEP, packet is finished.
+                            state <= S_Data3;
 
-                    WHEN S_Dummy2 =>
-                        -- Read data from receive buffer until the control flag is '1' (means EOP/EEP).
+                        ELSIF (grantedIn = '1' AND iReceiveFIFOReady = '1') THEN
+                            -- Continue reading bytes according to this packet.
+                            iReceiveFIFOReadEnable <= '1';
+                            state <= S_Data1;
 
-                        IF (s_rxdata(8) = '1') THEN -- vorher: receiveFIFODataOut(8)
-                            state <= S_Idle;
                         ELSE
-                            state <= S_Dummy0;
+                            -- None further byte available yet, wait for it or an EOP/EEP.
+                            state <= S_Data0;
+
                         END IF;
+                    END IF;
+
+                WHEN S_Data3 =>
+                    -- Complete sending to destination port.
+                    iStrobeOut <= '0';
+                    iRequestOut <= '0';
+                    state <= S_Idle;
+
+                WHEN S_Dummy0 =>
+                    -- Dummie-states are there to throw away packets that cannot be delivered.
+                    -- dummy read (may block forever)
+                    iRequestOut <= '0';
+
+                    IF (iReceiveFIFOReady = '1') THEN
+                        iReceiveFIFOReadEnable <= '1';
+                        state <= S_Dummy1;
 
-                    WHEN OTHERS => -- Because of unused state problem.
+                    END IF;
+
+                WHEN S_Dummy1 =>
+                    -- Wait to read data from receive buffer.
+
+                    receiveFIFODataOut(8) <= s_rxflag; -- take over by handshake mechanism
+                    receiveFIFODataOut(7 DOWNTO 0) <= s_rxdata;
+
+                    iReceiveFIFOReadEnable <= '0';
+                    state <= S_Dummy2;
+
+                WHEN S_Dummy2 =>
+                    -- Read data from receive buffer until the control flag.
+                    IF (receiveFIFODataOut(8) = '1') THEN -- vorher: receiveFIFODataOut(8)
                         state <= S_Idle;
-                END CASE;
-            END IF;
+
+                    ELSE
+                        state <= S_Dummy0;
+
+                    END IF;
+
+                WHEN OTHERS => -- Because of unused state problem.
+                    state <= S_Idle;
+            END CASE;
         END IF;
     END PROCESS;
 END spwrouterport_arch;
\ No newline at end of file
diff --git a/trunk/rtl/vhdl/spwrouterregs.vhd b/trunk/rtl/vhdl/spwrouterregs.vhd
index 6a77378..d09ccad 100644
--- a/trunk/rtl/vhdl/spwrouterregs.vhd
+++ b/trunk/rtl/vhdl/spwrouterregs.vhd
@@ -16,11 +16,11 @@
 -- Revision:
 ----------------------------------------------------------------------------------
 
-LIBRARY IEEE;
-USE IEEE.STD_LOGIC_1164.ALL;
-USE IEEE.NUMERIC_STD.ALL;
-USE WORK.SPWROUTERPKG.ALL;
-USE WORK.SPWPKG.ALL;
+LIBRARY ieee;
+USE ieee.std_logic_1164.ALL;
+USE ieee.numeric_std.ALL;
+USE work.spwrouterpkg.ALL;
+USE work.spwpkg.ALL;
 
 ENTITY spwrouterregs IS
     GENERIC (
@@ -257,6 +257,583 @@ BEGIN
     s_addr_7C <= '1' WHEN addr (7 DOWNTO 2) = "011111" ELSE
         '0'; -- 7C (31)
 
+    -- FSM. Controls read/write access to registers.
+    PROCESS (clk, rst)
+    BEGIN
+        IF (rst = '1') THEN -- reset.
+            state <= S_Idle;
+            s_proc_out <= '0';
+            s_DataOutBuffer <= (OTHERS => '0');
+            s_DataInBuffer <= (OTHERS => '0');
+
+            --                         x"0BEBC200" (alle 2 sec wird ein neues automatisches Time Code generiert)
+            s_autoTimeCodeCycleTime <= x"00000000"; -- ACHTUNG ! WERT HIER UNBEDINGT WIEDER AUF x"00000000" ABÄNDERN! NUR ZU TESTZWECKEN SO IMPLEMENTIERT !
+            s_autoTimeCodeValue <= (OTHERS => '0');
+            -- TODO: Built-in async reset for spwrams!
+
+        ELSIF rising_edge(clk) THEN
+            CASE state IS
+                WHEN S_Idle =>
+                    IF ((s_selectRoutingTable = '0') AND (cycle = '1') AND (strobe = '1')) THEN
+                        IF (readwrite = '1') THEN -- TODO: FALLS das Beschreiben der Register schief geht, weil readwrite im nächsten Takt nicht mehr HIGH ist, dann 'wen' bei allen Registern auf '1' setzen und prüfen ob das funktioniert. (Könnte eventuell auch kollidieren, weil dann ja beides gleichzeitig möglich wäre: schreiben und lesen)
+                            s_DataInBuffer <= writeData;
+                            state <= S_Write0;
+                        ELSE
+                            state <= S_Read0;
+                        END IF;
+                    END IF;
+
+                WHEN S_Read0 =>
+                    -- Read 
+                    -- Register select. (Tables are in ascending order.)
+                    -- Routing table is handled separately.
+                    IF (s_table_4 = '1' AND s_addr_00 = '1') THEN -- Status register (0x0000_0400)
+                        -- Status Port 0
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(0, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_04 = '1') THEN
+                        -- Status Port 1
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(1, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_08 = '1') THEN
+                        -- Status Port 2
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(2, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_0C = '1') THEN
+                        -- Status Port 3
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(3, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_10 = '1') THEN
+                        -- Status Port 4
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(4, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_14 = '1') THEN
+                        -- Status Port 5
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(5, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_18 = '1') THEN
+                        -- Status Port 6
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(6, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_1C = '1') THEN
+                        -- Status Port 7
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(7, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_20 = '1') THEN
+                        -- Status Port 8
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(8, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_24 = '1') THEN
+                        -- Status Port 9
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(9, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_28 = '1') THEN
+                        -- Status Port 10
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(10, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_2C = '1') THEN
+                        -- Status Port 11
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(11, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_30 = '1') THEN
+                        -- Status Port 12
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(12, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_34 = '1') THEN
+                        -- Status Port 13
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(13, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_38 = '1') THEN
+                        -- Status Port 14
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(14, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_3C = '1') THEN
+                        -- Status Port 15
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(15, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_40 = '1') THEN
+                        -- Status Port 16
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(16, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_44 = '1') THEN
+                        -- Status Port 17
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(17, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_48 = '1') THEN
+                        -- Status Port 18
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(18, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_4C = '1') THEN
+                        -- Status Port 19
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(19, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_50 = '1') THEN
+                        -- Status Port 20
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(20, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_54 = '1') THEN
+                        -- Status Port 21
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(21, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_58 = '1') THEN
+                        -- Status Port 22
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(22, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_5C = '1') THEN
+                        -- Status Port 23
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(23, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_60 = '1') THEN
+                        -- Status Port 24
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(24, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_64 = '1') THEN
+                        -- Status Port 25
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(25, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_68 = '1') THEN
+                        -- Status Port 26
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(26, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_6C = '1') THEN
+                        -- Status Port 27
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(27, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_70 = '1') THEN
+                        -- Status Port 28
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(28, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_74 = '1') THEN
+                        -- Status Port 29
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(29, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_78 = '1') THEN
+                        -- Status Port 30
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(30, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_4 = '1' AND s_addr_7C = '1') THEN
+                        -- Status Port 31
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(31, s_addr_table4'length));
+                        s_DataOutBuffer <= s_read_table4;
+                    ELSIF (s_table_5 = '1' AND s_addr_00 = '1') THEN -- TimeCode register (0x0000_5000)
+                        -- TimeCode receive register
+                        s_addr_table5 <= STD_LOGIC_VECTOR(to_unsigned(0, s_addr_table5'length));
+                        s_DataOutBuffer <= s_read_table5;
+                        -- (1) N/A
+                    ELSIF (s_table_5 = '1' AND s_addr_08 = '1') THEN
+                        -- Automatic TimeCode value
+                        s_addr_table5 <= STD_LOGIC_VECTOR(to_unsigned(2, s_addr_table5'length));
+                        s_autoTimeCodeValue <= s_read_table5(7 DOWNTO 0);
+                    ELSIF (s_table_5 = '1' AND s_addr_0C = '1') THEN
+                        -- Automatic TimeCode Cycle Register
+                        s_addr_table5 <= STD_LOGIC_VECTOR(to_unsigned(3, s_addr_table5'length));
+                        s_autoTimeCodeCycleTime <= s_read_table5;
+                    ELSIF (s_table_6 = '1' AND s_addr_00 = '1') THEN -- Info register (0x0000_0600)
+                        -- Info
+                        s_addr_table6 <= STD_LOGIC_VECTOR(to_unsigned(0, s_addr_table6'length));
+                        s_DataOutBuffer <= s_read_table5;
+                    ELSE
+                        s_DataOutBuffer <= (OTHERS => '0');
+                    END IF; -- add here more tables and registers...
+
+                    s_proc_out <= '1';
+                    state <= S_Read1;
+
+                WHEN S_Read1 => -- Read register end.
+                    s_proc_out <= '0';
+                    state <= S_Wait0;
+
+                WHEN S_Write0 =>
+                    -- Write Register Select.
+                    IF (s_table_4 = '1' AND s_addr_00 = '1') THEN -- Status register (0x0000_0400)
+                        -- Status Port 0
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(0, s_addr_table4'length));
+
+                        -- Loop is rolled out...                        
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(0)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+
+                        -- to... (example)
+                        --                        IF (dByte(0) = '1') THEN
+                        --                            s_write_table4(7 DOWNTO 0) <= portstatus(0)(7 DOWNTO 0);
+                        --                        END IF;
+                        --                        IF (dByte(1) = '1') THEN
+                        --                            s_write_table4(15 DOWNTO 8) <= portstatus(0)(15 DOWNTO 8);
+                        --                        END IF;
+                        --                        IF (dByte(2) = '1') THEN
+                        --                            s_write_table4(23 DOWNTO 16) <= portstatus(0)(23 DOWNTO 16);
+                        --                        END IF;
+                        --                        IF (dByte(3) = '1') THEN
+                        --                            s_write_table4(31 DOWNTO 24) <= portstatus(0)(31 DOWNTO 24);
+                        --                        END IF;
+
+                    ELSIF (s_table_4 = '1' AND s_addr_04 = '1') THEN
+                        -- Status Port 1
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(1, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(1)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_08 = '1') THEN
+                        -- Status Port 2
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(2, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied 
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(2)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_0C = '1') THEN
+                        -- Status Port 3
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(3, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(3)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_10 = '1') THEN
+                        -- Status Port 4
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(4, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(4)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_14 = '1') THEN
+                        -- Status Port 5
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(5, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(5)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_18 = '1') THEN
+                        -- Status Port 6
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(6, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(6)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_1C = '1') THEN
+                        -- Status Port 7
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(7, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(7)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_20 = '1') THEN
+                        -- Status Port 8
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(8, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(8)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_24 = '1') THEN
+                        -- Status Port 9
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(9, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(9)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_28 = '1') THEN
+                        -- Status Port 10
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(10, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(10)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_2C = '1') THEN
+                        -- Status Port 11
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(11, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(11)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_30 = '1') THEN
+                        -- Status Port 12
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(12, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(12)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_34 = '1') THEN
+                        -- Status Port 13
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(13, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(13)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_38 = '1') THEN
+                        -- Status Port 14
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(14, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(14)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_3C = '1') THEN
+                        -- Status Port 15
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(15, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(15)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_40 = '1') THEN
+                        -- Status Port 16
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(16, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(16)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_44 = '1') THEN
+                        -- Status Port 17
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(17, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(17)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_48 = '1') THEN
+                        -- Status Port 18
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(18, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(18)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_4C = '1') THEN
+                        -- Status Port 19
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(19, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(19)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_50 = '1') THEN
+                        -- Status Port 20
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(20, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(20)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_54 = '1') THEN
+                        -- Status Port 21
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(21, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(21)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_58 = '1') THEN
+                        -- Status Port 22
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(22, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(22)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_5C = '1') THEN
+                        -- Status Port 23
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(23, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(23)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_60 = '1') THEN
+                        -- Status Port 24
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(24, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(24)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_64 = '1') THEN
+                        -- Status Port 25
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(25, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(25)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_68 = '1') THEN
+                        -- Status Port 26
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(26, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(26)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_6C = '1') THEN
+                        -- Status Port 27
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(27, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(27)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_70 = '1') THEN
+                        -- Status Port 28
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(28, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(28)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_74 = '1') THEN
+                        -- Status Port 29
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(29, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(29)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_78 = '1') THEN
+                        -- Status Port 30
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(30, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(30)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_4 = '1' AND s_addr_7C = '1') THEN
+                        -- Status Port 31
+                        s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(31, s_addr_table4'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(31)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_5 = '1' AND s_addr_00 = '1') THEN -- TimeCode register (0x0000_5000)
+                        -- TimeCode receive register
+                        s_addr_table5 <= STD_LOGIC_VECTOR(to_unsigned(0, s_addr_table5'length));
+
+                        s_write_table5 <= x"000000" & receiveTimeCode;
+
+                    ELSIF (s_table_5 = '1' AND s_addr_08 = '1') THEN
+                        -- AutoTimeCode value register
+                        s_addr_table5 <= STD_LOGIC_VECTOR(to_unsigned(2, s_addr_table5'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table5(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= s_DataInBuffer(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_5 = '1' AND s_addr_0C = '1') THEN
+                        -- AutoTimeCodeCycleTimeRegister
+                        s_addr_table5 <= STD_LOGIC_VECTOR(to_unsigned(3, s_addr_table5'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table5(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= s_DataInBuffer(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    ELSIF (s_table_6 = '1' AND s_addr_00 = '1') THEN -- Info register (0x0000_0600)
+                        s_addr_table6 <= STD_LOGIC_VECTOR(to_unsigned(0, s_addr_table6'length));
+
+                        -- Check byte by byte whether data should be copied
+                        FOR i IN 1 TO 4 LOOP
+                            IF (dByte(i - 1) = '1') THEN
+                                s_write_table6(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= s_DataInBuffer(((8 * i) - 1) DOWNTO (8 * (i - 1)));
+                            END IF;
+                        END LOOP;
+                    END IF; -- add here more tables and registers...
+
+                    s_proc_out <= '1';
+                    state <= S_Write1;
+
+                WHEN S_Write1 => -- Write Register END.
+                    -- iSoftwareLinkResetx <= '0'; x == PortNr.
+                    s_proc_out <= '0';
+                    state <= S_Wait0;
+
+                WHEN S_Wait0 => -- Write register wait.
+                    state <= S_Wait1;
+
+                WHEN S_Wait1 =>
+                    state <= S_Idle;
+
+            END CASE;
+        END IF;
+    END PROCESS;
 
     -- Routing table (0x0000_0080 - 0x0000_03F8)
     RoutingTable : spwroutertable
@@ -266,14 +843,14 @@ BEGIN
     PORT MAP(
         clk => clk,
         rst => rst,
-        ack_in => s_strobeRoutingTable,
+        act => s_strobeRoutingTable,
         readwrite => readwrite,
         dByte => dByte,
-        addr => addr(9 DOWNTO 2), -- maps hexadecimal numbers to decimals beginning with 0 step 1.
+        addr => addr(9 DOWNTO 2), -- mapps hexadecimal numbers to decimals beginning with 0 step 1.
         wdata => writeData,
         rdata => s_dataRoutingTable,
-        ack_out => s_procRoutingTable
-    );
+        proc => s_procRoutingTable
+    ); -- Check, genauso wie im original
 
     -- Port status register (0x0000_0400 - 0x0000_0480)
     -- Even if fewer that maximum possible 31 ports are created (numports), 
@@ -327,586 +904,4 @@ BEGIN
         waddr => s_addr_table6,
         wdata => s_write_table6
     );
-
-
-    -- FSM. Controls read/write access to registers.
-    PROCESS (clk)
-    BEGIN
-        IF rising_edge(clk) THEN
-            IF rst = '1' THEN
-                -- Synchronous reset.
-                state <= S_Idle;
-                s_proc_out <= '0';
-                s_DataOutBuffer <= (OTHERS => '0');
-                s_DataInBuffer <= (OTHERS => '0');
-
-                --                         x"0BEBC200" (alle 2 sec wird ein neues automatisches Time Code generiert)
-                s_autoTimeCodeCycleTime <= x"00000000"; -- ACHTUNG ! WERT HIER UNBEDINGT WIEDER AUF x"00000000" ABÄNDERN! NUR ZU TESTZWECKEN SO IMPLEMENTIERT !
-                s_autoTimeCodeValue <= (OTHERS => '0');
-                -- TODO: Built-in async reset for spwrams!
-            ELSE
-
-                CASE state IS
-                    WHEN S_Idle =>
-                        IF ((s_selectRoutingTable = '0') AND (cycle = '1') AND (strobe = '1')) THEN
-                            IF (readwrite = '1') THEN -- TODO: FALLS das Beschreiben der Register schief geht, weil readwrite im nächsten Takt nicht mehr HIGH ist, dann 'wen' bei allen Registern auf '1' setzen und prüfen ob das funktioniert. (Könnte eventuell auch kollidieren, weil dann ja beides gleichzeitig möglich wäre: schreiben und lesen)
-                                s_DataInBuffer <= writeData;
-                                state <= S_Write0;
-                            ELSE
-                                state <= S_Read0;
-                            END IF;
-                        END IF;
-
-                    WHEN S_Read0 =>
-                        -- Read 
-                        -- Register select. (Tables are in ascending order.)
-                        -- Routing table is handled separately.
-                        IF (s_table_4 = '1' AND s_addr_00 = '1') THEN -- Status register (0x0000_0400)
-                            -- Status Port 0
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(0, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_04 = '1') THEN
-                            -- Status Port 1
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(1, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_08 = '1') THEN
-                            -- Status Port 2
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(2, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_0C = '1') THEN
-                            -- Status Port 3
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(3, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_10 = '1') THEN
-                            -- Status Port 4
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(4, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_14 = '1') THEN
-                            -- Status Port 5
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(5, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_18 = '1') THEN
-                            -- Status Port 6
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(6, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_1C = '1') THEN
-                            -- Status Port 7
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(7, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_20 = '1') THEN
-                            -- Status Port 8
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(8, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_24 = '1') THEN
-                            -- Status Port 9
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(9, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_28 = '1') THEN
-                            -- Status Port 10
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(10, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_2C = '1') THEN
-                            -- Status Port 11
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(11, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_30 = '1') THEN
-                            -- Status Port 12
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(12, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_34 = '1') THEN
-                            -- Status Port 13
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(13, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_38 = '1') THEN
-                            -- Status Port 14
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(14, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_3C = '1') THEN
-                            -- Status Port 15
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(15, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_40 = '1') THEN
-                            -- Status Port 16
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(16, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_44 = '1') THEN
-                            -- Status Port 17
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(17, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_48 = '1') THEN
-                            -- Status Port 18
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(18, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_4C = '1') THEN
-                            -- Status Port 19
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(19, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_50 = '1') THEN
-                            -- Status Port 20
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(20, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_54 = '1') THEN
-                            -- Status Port 21
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(21, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_58 = '1') THEN
-                            -- Status Port 22
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(22, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_5C = '1') THEN
-                            -- Status Port 23
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(23, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_60 = '1') THEN
-                            -- Status Port 24
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(24, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_64 = '1') THEN
-                            -- Status Port 25
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(25, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_68 = '1') THEN
-                            -- Status Port 26
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(26, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_6C = '1') THEN
-                            -- Status Port 27
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(27, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_70 = '1') THEN
-                            -- Status Port 28
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(28, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_74 = '1') THEN
-                            -- Status Port 29
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(29, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_78 = '1') THEN
-                            -- Status Port 30
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(30, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_4 = '1' AND s_addr_7C = '1') THEN
-                            -- Status Port 31
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(31, s_addr_table4'length));
-                            s_DataOutBuffer <= s_read_table4;
-                        ELSIF (s_table_5 = '1' AND s_addr_00 = '1') THEN -- TimeCode register (0x0000_5000)
-                            -- TimeCode receive register
-                            s_addr_table5 <= STD_LOGIC_VECTOR(to_unsigned(0, s_addr_table5'length));
-                            s_DataOutBuffer <= s_read_table5;
-                            -- (1) N/A
-                        ELSIF (s_table_5 = '1' AND s_addr_08 = '1') THEN
-                            -- Automatic TimeCode value
-                            s_addr_table5 <= STD_LOGIC_VECTOR(to_unsigned(2, s_addr_table5'length));
-                            s_autoTimeCodeValue <= s_read_table5(7 DOWNTO 0);
-                        ELSIF (s_table_5 = '1' AND s_addr_0C = '1') THEN
-                            -- Automatic TimeCode Cycle Register
-                            s_addr_table5 <= STD_LOGIC_VECTOR(to_unsigned(3, s_addr_table5'length));
-                            s_autoTimeCodeCycleTime <= s_read_table5;
-                        ELSIF (s_table_6 = '1' AND s_addr_00 = '1') THEN -- Info register (0x0000_0600)
-                            -- Info
-                            s_addr_table6 <= STD_LOGIC_VECTOR(to_unsigned(0, s_addr_table6'length));
-                            s_DataOutBuffer <= s_read_table5;
-                        ELSE
-                            s_DataOutBuffer <= (OTHERS => '0');
-                        END IF; -- add here more tables and registers...
-
-                        s_proc_out <= '1';
-                        state <= S_Read1;
-
-                    WHEN S_Read1 => -- Read register end.
-                        s_proc_out <= '0';
-                        state <= S_Wait0;
-
-                    WHEN S_Write0 =>
-                        -- Write Register Select.
-                        IF (s_table_4 = '1' AND s_addr_00 = '1') THEN -- Status register (0x0000_0400)
-                            -- Status Port 0
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(0, s_addr_table4'length));
-
-                            -- Loop is rolled out...                        
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(0)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-
-                            -- to... (example)
-                            --                        IF (dByte(0) = '1') THEN
-                            --                            s_write_table4(7 DOWNTO 0) <= portstatus(0)(7 DOWNTO 0);
-                            --                        END IF;
-                            --                        IF (dByte(1) = '1') THEN
-                            --                            s_write_table4(15 DOWNTO 8) <= portstatus(0)(15 DOWNTO 8);
-                            --                        END IF;
-                            --                        IF (dByte(2) = '1') THEN
-                            --                            s_write_table4(23 DOWNTO 16) <= portstatus(0)(23 DOWNTO 16);
-                            --                        END IF;
-                            --                        IF (dByte(3) = '1') THEN
-                            --                            s_write_table4(31 DOWNTO 24) <= portstatus(0)(31 DOWNTO 24);
-                            --                        END IF;
-
-                        ELSIF (s_table_4 = '1' AND s_addr_04 = '1') THEN
-                            -- Status Port 1
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(1, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(1)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_08 = '1') THEN
-                            -- Status Port 2
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(2, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied 
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(2)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_0C = '1') THEN
-                            -- Status Port 3
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(3, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(3)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_10 = '1') THEN
-                            -- Status Port 4
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(4, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(4)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_14 = '1') THEN
-                            -- Status Port 5
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(5, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(5)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_18 = '1') THEN
-                            -- Status Port 6
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(6, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(6)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_1C = '1') THEN
-                            -- Status Port 7
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(7, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(7)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_20 = '1') THEN
-                            -- Status Port 8
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(8, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(8)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_24 = '1') THEN
-                            -- Status Port 9
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(9, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(9)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_28 = '1') THEN
-                            -- Status Port 10
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(10, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(10)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_2C = '1') THEN
-                            -- Status Port 11
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(11, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(11)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_30 = '1') THEN
-                            -- Status Port 12
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(12, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(12)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_34 = '1') THEN
-                            -- Status Port 13
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(13, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(13)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_38 = '1') THEN
-                            -- Status Port 14
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(14, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(14)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_3C = '1') THEN
-                            -- Status Port 15
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(15, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(15)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_40 = '1') THEN
-                            -- Status Port 16
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(16, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(16)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_44 = '1') THEN
-                            -- Status Port 17
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(17, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(17)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_48 = '1') THEN
-                            -- Status Port 18
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(18, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(18)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_4C = '1') THEN
-                            -- Status Port 19
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(19, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(19)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_50 = '1') THEN
-                            -- Status Port 20
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(20, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(20)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_54 = '1') THEN
-                            -- Status Port 21
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(21, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(21)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_58 = '1') THEN
-                            -- Status Port 22
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(22, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(22)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_5C = '1') THEN
-                            -- Status Port 23
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(23, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(23)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_60 = '1') THEN
-                            -- Status Port 24
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(24, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(24)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_64 = '1') THEN
-                            -- Status Port 25
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(25, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(25)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_68 = '1') THEN
-                            -- Status Port 26
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(26, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(26)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_6C = '1') THEN
-                            -- Status Port 27
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(27, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(27)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_70 = '1') THEN
-                            -- Status Port 28
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(28, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(28)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_74 = '1') THEN
-                            -- Status Port 29
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(29, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(29)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_78 = '1') THEN
-                            -- Status Port 30
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(30, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(30)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_4 = '1' AND s_addr_7C = '1') THEN
-                            -- Status Port 31
-                            s_addr_table4 <= STD_LOGIC_VECTOR(to_unsigned(31, s_addr_table4'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table4(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= portstatus(31)(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_5 = '1' AND s_addr_00 = '1') THEN -- TimeCode register (0x0000_5000)
-                            -- TimeCode receive register
-                            s_addr_table5 <= STD_LOGIC_VECTOR(to_unsigned(0, s_addr_table5'length));
-
-                            s_write_table5 <= x"000000" & receiveTimeCode;
-
-                        ELSIF (s_table_5 = '1' AND s_addr_08 = '1') THEN
-                            -- AutoTimeCode value register
-                            s_addr_table5 <= STD_LOGIC_VECTOR(to_unsigned(2, s_addr_table5'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table5(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= s_DataInBuffer(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_5 = '1' AND s_addr_0C = '1') THEN
-                            -- AutoTimeCodeCycleTimeRegister
-                            s_addr_table5 <= STD_LOGIC_VECTOR(to_unsigned(3, s_addr_table5'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table5(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= s_DataInBuffer(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        ELSIF (s_table_6 = '1' AND s_addr_00 = '1') THEN -- Info register (0x0000_0600)
-                            s_addr_table6 <= STD_LOGIC_VECTOR(to_unsigned(0, s_addr_table6'length));
-
-                            -- Check byte by byte whether data should be copied
-                            FOR i IN 1 TO 4 LOOP
-                                IF (dByte(i - 1) = '1') THEN
-                                    s_write_table6(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= s_DataInBuffer(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                                END IF;
-                            END LOOP;
-                        END IF; -- add here more tables and registers...
-
-                        s_proc_out <= '1';
-                        state <= S_Write1;
-
-                    WHEN S_Write1 => -- Write Register END.
-                        -- iSoftwareLinkResetx <= '0'; x == PortNr.
-                        s_proc_out <= '0';
-                        state <= S_Wait0;
-
-                    WHEN S_Wait0 => -- Write register wait.
-                        state <= S_Wait1;
-
-                    WHEN S_Wait1 =>
-                        state <= S_Idle;
-
-                END CASE;
-            END IF;
-        END IF;
-    END PROCESS;
 END spwrouterregs_arch;
\ No newline at end of file
diff --git a/trunk/rtl/vhdl/spwroutertable.vhd b/trunk/rtl/vhdl/spwroutertable.vhd
index 10d84c7..01c0961 100644
--- a/trunk/rtl/vhdl/spwroutertable.vhd
+++ b/trunk/rtl/vhdl/spwroutertable.vhd
@@ -3,22 +3,22 @@
 -- Engineer: Stefan Lindoerfer
 -- 
 -- Create Date: 01.08.2021 21:13
--- Design Name: SpaceWire Router -- Router Table
+-- Design Name: SpaceWire Router Table
 -- Module Name: spwroutertable
--- Project Name: Bachelor Thesis: Implementation of a SpaceWire Router on an FPGA
--- Target Devices: Xilinx FPGAs
--- Tool Versions: -/-
--- Description: Contains memory (BRAM) to store the router table according to 
--- SpaceWire specification and fsm to control access to it.
+-- Project Name: Bachelor Thesis: Implementation of a SpaceWire Router on a FPGA
+-- Target Devices: 
+-- Tool Versions: 
+-- Description: Contains a FSM that controls access to routing table in ROM.
 --
--- Dependencies: spwram (spwpkg), spwroutertablestates (spwrouterpkg)
+-- Dependencies: spwram (defined in spwpkg),
+-- spwroutertablestates (defined in spwrouterpkg)
 -- 
--- Revision: 0.9 - Simulation and hardware test were sucessful.
+-- Revision:
 ----------------------------------------------------------------------------------
 
 LIBRARY IEEE;
 USE IEEE.STD_LOGIC_1164.ALL;
-USE WORK.SPWPKG.ALL;
+USE WORK.SPWPKG.ALL; -- Xilinx Spartan3 RAM
 USE WORK.SPWROUTERPKG.ALL;
 
 ENTITY spwroutertable IS
@@ -30,160 +30,148 @@ ENTITY spwroutertable IS
         -- System clock.
         clk : IN STD_LOGIC;
 
-        -- Synchronous reset.
+        -- Asynchronous reset.
         rst : IN STD_LOGIC;
 
-        -- High to begin register operation in idle state.
-        ack_in : IN STD_LOGIC; -- strobe -- act
+        -- High if read/write operation is to be carried out. (Only recognized in idle state;  
+        -- doesn't have to be High all operation time!) Low when nothing should be done.
+        act : IN STD_LOGIC; -- strobe
 
-        -- High if a write operation; Low when a read operation should be performed.
-        -- Valid only if ack_in is High and fsm in idle state.
+        -- Type of operation: High if a write process and Low if a read process should be executed.
+        -- (Works only if act is High and FSM is in idle state.)
         readwrite : IN STD_LOGIC; -- writeEnable
 
-        -- Specifies the byte (1-4) which should be overwritten during a write operation in the register.
-        -- (0xf (1111_2) for every byte)
+        -- Specifies bytes which should be overwritten during a write operation in the register. (Word width 32 bits == 4 Bytes)
+        -- (Only applies to write operations!)
         dByte : IN STD_LOGIC_VECTOR(3 DOWNTO 0); -- dataByteEnable
 
-        -- Memory address (0-255).
+        -- Memory address at which the operation is to be executed.
         addr : IN STD_LOGIC_VECTOR(7 DOWNTO 0); -- address
 
-        -- Word to write into register.
+        -- Word to be written in register.
         wdata : IN STD_LOGIC_VECTOR(31 DOWNTO 0); -- writeData
 
-        -- Contains word from register.
+        -- Word to be read from a register.
         rdata : OUT STD_LOGIC_VECTOR(31 DOWNTO 0); -- readData
 
-        -- High if a read or write operation has finished (acknowledgment).
-        ack_out : OUT STD_LOGIC -- acknowledge -- proc
+        -- High if a read or write operation is in progress.
+        proc : OUT STD_LOGIC -- acknowledge
+
+        -- Debug: Output state
+        --instate : OUT spwroutertablestates
     );
 END spwroutertable;
 
 ARCHITECTURE spwroutertable_arch OF spwroutertable IS
-    -- FSM state.
+    -- FSM state. (Initial value: S_Idle)
     SIGNAL state : spwroutertablestates := S_Idle;
 
-    -- Buffer for output signals.
-    SIGNAL s_ack_out : STD_LOGIC; -- iAcknowledge
+    -- Intermediate signals.
+    SIGNAL s_proc : STD_LOGIC; -- iAcknowledge
+    SIGNAL s_rdata : STD_LOGIC_VECTOR(31 DOWNTO 0); -- iReadData
 
-    -- Grants writing access into register.
-    SIGNAL s_write_enable : STD_LOGIC; -- iWriteEnableRegister
+    -- Enables writing process in register.
+    SIGNAL s_write_en : STD_LOGIC; -- iWriteEnableRegister
 
-    -- Data buffer du read data from register.
-    SIGNAL s_mem_data : STD_LOGIC_VECTOR(31 DOWNTO 0); -- ramDataOut
+    -- Reades data from register.
+    SIGNAL s_ramdata : STD_LOGIC_VECTOR(31 DOWNTO 0); -- ramDataOut
 
-    -- Buffer to write into register.
+    -- Writes data to register.
     SIGNAL s_wdata : STD_LOGIC_VECTOR(31 DOWNTO 0); -- iWriteData
-
-    -- Output buffer to read from register buffer (s_mem_data).
-    SIGNAL s_rdata : STD_LOGIC_VECTOR(31 DOWNTO 0); -- iReadData
 BEGIN
     -- Drive outputs
-    ack_out <= s_ack_out;
+    proc <= s_proc;
     rdata <= s_rdata;
 
-    -- Creates 32x256 routing table in BRAM. (Xilinx synthesizer infers to use RAM Block)
+    -- Creates 32x256 routing table in ROM.
+    -- (Synthesizer for Spartan3 infers to use ROM Block)
     ramXilinx : spwram
     GENERIC MAP(
-        abits => 8, -- ((2**8) - 1) rows
-        dbits => 32 -- 32 bit size
+        abits => 8,
+        dbits => 32
     )
     PORT MAP(
         rclk => clk,
         wclk => clk,
         ren => '1',
         raddr => addr,
-        rdata => s_mem_data,
-        wen => s_write_enable,
+        rdata => s_ramdata,
+        wen => s_write_en,
         waddr => addr,
         wdata => s_wdata
     );
 
-    -- Finite state machine.
-    fsm : PROCESS (clk)
+    -- Finite state machine of router table.
+    PROCESS (clk, rst)
     BEGIN
-        IF rising_edge(clk) THEN
-            IF rst = '1' THEN
-                -- Synchronous reset.
-                s_ack_out <= '0';
-                s_rdata <= (OTHERS => '0');
-                s_wdata <= (OTHERS => '0');
-                s_write_enable <= '0';
-                state <= S_Idle;
-            ELSE
-                CASE state IS
-                    WHEN S_Idle =>
-                        -- Wait until access to router table is required.
-                        -- s_ack_out <= '0'; -- Potenzieller Fehler! Müsste aber meiner Ansicht nacht hier nicht noch auf Null gesetzt werden, da das in den vorherigen States passiert
-                        IF (ack_in = '1') THEN
-                            IF (readwrite = '1') THEN
-                                s_wdata <= wdata;
-                                state <= S_Write0;
-                            ELSE
-                                state <= S_Read0;
-                            END IF;
-                        END IF;
-
-                    WHEN S_Write0 =>
-                        -- Additional status to keep write and read-cycles the same number.
-                        state <= S_Write1;
+        IF (rst = '1') THEN -- reset.
+            state <= S_Idle;
+            s_proc <= '0';
+            s_rdata <= (OTHERS => '0');
+            s_wdata <= (OTHERS => '0');
+            s_write_en <= '0';
+
+        ELSIF rising_edge(clk) THEN
+            CASE state IS
+                WHEN S_Idle =>
+                    s_proc <= '0';
+                    IF (act = '1') THEN
+                        IF (readwrite = '1') THEN
+                            s_wdata <= wdata;
+                            state <= S_Write0;
+
+                        ELSE
+                            state <= S_Read0;
 
-                    WHEN S_Write1 =>
-                        -- If dByte is 0xf then write wdata byte by byte into RAM, depending on flag marking in dByte.
-                        FOR i IN 1 TO 4 LOOP
-                            IF (dByte(i - 1) = '1') THEN
-                                -- Overwrite
-                                s_wdata(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= wdata(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                            ELSE
-                                -- Keep unchanged
-                                s_wdata(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= s_mem_data(((8 * i) - 1) DOWNTO (8 * (i - 1)));
-                            END IF;
-                        END LOOP;
-
-                        -- Set write signal.
-                        s_write_enable <= '1';
-
-                        -- Set output signal to show operation.
-                        s_ack_out <= '1';
-                        state <= S_Write2;
-
-                    WHEN S_Write2 =>
-                        -- Reset signals.
-                        s_write_enable <= '0';
-                        s_ack_out <= '0';
+                        END IF;
+                    END IF;
+                WHEN S_Write0 =>
+                    -- Additional status to keep write and read cycles the same.
+                    state <= S_Write1;
 
-                        state <= S_Wait1;
+                WHEN S_Write1 =>
+                    -- If dByte is '1' then write wdata byte by byte into
+                    -- RAM, depending on flag marking in dByte.
+                    FOR i IN 1 TO 4 LOOP
+                        IF (dByte(i - 1) = '1') THEN
+                            s_wdata(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= wdata(((8 * i) - 1) DOWNTO (8 * (i - 1)));
 
-                    WHEN S_Read0 =>
-                        state <= S_Read1;
+                        ELSE
+                            s_wdata(((8 * i) - 1) DOWNTO (8 * (i - 1))) <= s_ramdata(((8 * i) - 1) DOWNTO (8 * (i - 1)));
 
-                    WHEN S_Read1 =>
-                        -- Write register data into output buffer.
-                        s_rdata <= s_mem_data;
+                        END IF;
+                    END LOOP;
 
-                        -- Set output signal to show operation.
-                        s_ack_out <= '1';
+                    s_write_en <= '1';
+                    s_proc <= '1';
+                    state <= S_Write2;
 
-                        state <= S_Wait0;
+                WHEN S_Write2 =>
+                    s_write_en <= '0';
+                    s_proc <= '0';
+                    state <= S_Wait1;
 
-                    WHEN S_Wait0 => -- Wait time for master change a signal to Low. (Nochmal nachvollziehen ob das gebraucht wird!) Eventuell nur dafür da, ein paar Takte zu verzögern
-                        -- Reset signal.
-                        s_ack_out <= '0';
+                WHEN S_Read0 =>
+                    state <= S_Read1;
 
-                        state <= S_Wait1;
+                WHEN S_Read1 =>
+                    s_rdata <= s_ramdata;
+                    s_proc <= '1';
+                    state <= S_Wait0;
 
-                    WHEN S_Wait1 =>
-                        state <= S_Wait2;
+                WHEN S_Wait0 => -- several waiting states give time to change external signals.
+                    s_proc <= '0';
+                    state <= S_Wait1;
 
-                    WHEN S_Wait2 =>
-                        state <= S_Wait3;
+                WHEN S_Wait1 =>
+                    state <= S_Wait2;
 
-                    WHEN S_Wait3 =>
-                        state <= S_Idle;
+                WHEN S_Wait2 =>
+                    state <= S_Wait3;
 
-                    WHEN OTHERS => -- (Necessary for problem of unused states)
-                        state <= S_Idle;
-                END CASE;
-            END IF;
+                WHEN S_Wait3 =>
+                    state <= S_Idle;
+            END CASE;
         END IF;
-    END PROCESS fsm;
+    END PROCESS;
 END spwroutertable_arch;
\ No newline at end of file
diff --git a/trunk/rtl/vhdl/spwroutertcc.vhd b/trunk/rtl/vhdl/spwroutertcc.vhd
index 4866c14..e9c560d 100644
--- a/trunk/rtl/vhdl/spwroutertcc.vhd
+++ b/trunk/rtl/vhdl/spwroutertcc.vhd
@@ -3,24 +3,29 @@
 -- Engineer: Stefan Lindoerfer
 -- 
 -- Create Date: 02.08.2021 21:06
--- Design Name: SpaceWire Router -- Time Code Control
+-- Design Name: SpaceWire Router Time Code Control
 -- Module Name: spwrouterttc
 -- Project Name: Bachelor Thesis: Implementation of a SpaceWire Router on an FPGA
--- Target Devices: Xilinx FPGAs
--- Tool Versions: -/-
--- Description: Central management of Time Codes in the router. Conformance to
--- SpaceWire specification. Also offers option of sending Time Codes periodically,
--- but then no longer reacts to incoming Time Codes.
+-- Target Devices: -/-
+-- Tool Versions: 1.0
+-- Description: Central management of Time Codes whithin the router.
 --
--- Dependencies: array_t (spwrouterpkg)
+-- CAUTION! The assignment is shifted for every std_logic_vector-port that 
+-- excludes port0 (internal port): Port1 has index 0, Port2 -> 1, etc.
+--
+-- Each bit of std_logic_vector(numports downto 0) represents the corresponding
+-- SpW port.
+--
+-- Dependencies: spwrouterpkg
 -- 
--- Revision: 0.9 - Simulation and hardware test were sucessful.
+-- Revision:
 ----------------------------------------------------------------------------------
 
-LIBRARY IEEE;
-USE IEEE.STD_LOGIC_1164.ALL;
-USE IEEE.NUMERIC_STD.ALL;
-USE WORK.SPWROUTERPKG.ALL;
+LIBRARY ieee;
+USE ieee.std_logic_1164.ALL;
+use ieee.numeric_std.all;
+--USE IEEE.STD_LOGIC_UNSIGNED.ALL;
+USE work.spwrouterpkg.ALL;
 
 ENTITY spwroutertcc IS
     GENERIC (
@@ -34,19 +39,19 @@ ENTITY spwroutertcc IS
         -- Synchronous reset.
         rst : IN STD_LOGIC;
 
-        -- High if SpaceWire port is in running state or low when its in another state.
+        -- HIGH if SpaceWire port is in running state or LOW when its in another state.
         running : IN STD_LOGIC_VECTOR(numports DOWNTO 0); -- linkUp
 
-        -- High if port provides Time Code support. 
+        -- HIGH if port provides Time Code support. 
         tc_enable : IN STD_LOGIC_VECTOR(numports DOWNTO 0); -- portTimeCodeEnable -- tc_en
 
         -- Last Time Code that was received (to store in register).
         tc_last : OUT STD_LOGIC_VECTOR(7 DOWNTO 0); -- receiveTimeCode -- lst_time
 
-        -- High if SpaceWire port requests a Time Code transmission.
+        -- HIGH if SpaceWire port requests a Time Code transmission.
         tick_out : OUT STD_LOGIC_VECTOR(numports DOWNTO 0); -- portTickIn
 
-        -- High if SpaceWire port received a Time Code.
+        -- HIGH if SpaceWire port received a Time Code.
         tick_in : IN STD_LOGIC_VECTOR(numports DOWNTO 0); -- portTickOut        
 
         -- Containts Time Code to be sent for each SpaceWire port.
@@ -60,16 +65,17 @@ ENTITY spwroutertcc IS
 
         -- Time interval (auto_interval * clk_period) in which an automatically generated
         -- Time Code should be sent.
-        -- Max. time interval 2**32 * clk_period; 0x00000000 disables this process.
+        -- Max. time interval 2**32 * clk_period. 0x00000000 disables this process.
         auto_interval : IN STD_LOGIC_VECTOR(31 DOWNTO 0) -- autoTimeCodeCycleTime -- auto_cycle
     );
 END spwroutertcc;
 
 ARCHITECTURE spwroutertcc_arch OF spwroutertcc IS
-    -- Initial Time Code values.
+    -- Initial values for Time Codes.
     CONSTANT c_init_CounterValue : unsigned(5 DOWNTO 0) := "000000";
     CONSTANT c_init_CtrlFlag : STD_LOGIC_VECTOR(1 DOWNTO 0) := "00";
 
+
     -- Time Code components.  
     SIGNAL s_current_ctrl_flag : STD_LOGIC_VECTOR(1 DOWNTO 0); -- Time Code control flag.
     SIGNAL s_current_counter_value : unsigned(5 DOWNTO 0); -- Time Code counter value.
@@ -77,17 +83,21 @@ ARCHITECTURE spwroutertcc_arch OF spwroutertcc IS
 
     SIGNAL s_current_tc_out : STD_LOGIC_VECTOR(7 DOWNTO 0); -- Composite new Time Code (ctrl flag & counter value).
     SIGNAL s_current_auto_tc_out : STD_LOGIC_VECTOR(7 DOWNTO 0); -- Composite new auto generated Time Code (ctrl flag & counter value).
-
+    
+    
     -- Time Code port selection.
     SIGNAL s_tc_ports : STD_LOGIC_VECTOR(numports DOWNTO 0); -- All ports except the port that currently received Time Code and should not send any.
     SIGNAL s_tick_out : STD_LOGIC_VECTOR(numports DOWNTO 0); -- All ports that are technically running and selected for sending Time Codes.
-
+    
+    
     -- Contains requested or automatically generated Time Code for each port.
     SIGNAL s_tc_out : array_t(numports DOWNTO 0)(7 DOWNTO 0);
-
+   
+   
     -- Automatic Time Code generation.
-    SIGNAL s_auto_counter : unsigned(31 DOWNTO 0); -- std_logic_vector(31 downto 0) -- -- Counter for automatic Time Code generation.
-    SIGNAL s_auto_enable : STD_LOGIC; -- High if new automatically generated Time Code is to be sent.
+    -- Counter for automatic Time Code generation. (das noch dahinter)
+    SIGNAL s_auto_counter : unsigned(31 DOWNTO 0); -- std_logic_vector(31 downto 0) -- Hier könnte es ein Problem mit den 32 Bits (unsigned) des In-Ports "auto_interval" geben!    
+    SIGNAL s_auto_enable : STD_LOGIC; -- HIGH if new automatically generated Time Code is to be sent.
 BEGIN
     -- Drive outputs.
     tc_last <= s_current_tc_out;
@@ -96,8 +106,8 @@ BEGIN
     auto_tc_out <= s_current_auto_tc_out;
 
     -- Concatenation of control flag and counter value to Time Code.
-    s_current_auto_tc_out <= "00" & STD_LOGIC_VECTOR(s_auto_tc_counter_value);
-    s_current_tc_out <= s_current_ctrl_flag & STD_LOGIC_VECTOR(s_current_counter_value);
+    s_current_auto_tc_out <= "00" & std_logic_vector(s_auto_tc_counter_value); -- warum hier immer 00?
+    s_current_tc_out <= s_current_ctrl_flag & std_logic_vector(s_current_counter_value);
 
     -- Time Code output.
     PortSelection : FOR i IN 0 TO numports GENERATE
@@ -111,7 +121,7 @@ BEGIN
         s_current_auto_tc_out;
     END GENERATE PortSelection;
 
-    -- Generates both requested and automatically generated Time Codes and controls which port must send it.
+    -- Generates both requested and automatically generated Time Codes and controls which port must it.
     CreateTimeCodes : PROCESS (clk)
     BEGIN
         IF rising_edge(clk) THEN
@@ -127,15 +137,17 @@ BEGIN
 
                     IF (s_auto_enable = '1') THEN
                         s_tc_ports <= (OTHERS => '1'); -- All ports must send automatically generated Time Codes.
+
                     ELSE
                         -- Counter has not reached yet interval limit in auto_interval.
                         s_tc_ports <= (OTHERS => '0');
+
                     END IF;
                 ELSE
-                    -- (Automatically Time Code generation is disabled.)
+                    -- Automatically Time Code generation is disabled.
 
                     -- Reset Time Code port selection.
-                    s_tc_ports <= (OTHERS => '0'); -- Testen ob das nötig ist! Könnte sonst sein, dass in jeder Runde ein neuer Time Code verschickt wird!
+                    s_tc_ports <= (others => '0'); -- Testen ob das nötig ist! Könnte sonst sein, dass in jeder Runde ein neuer Time Code verschickt wird!
 
                     -- Time Code target
                     FOR i IN numports DOWNTO 0 LOOP
@@ -144,11 +156,12 @@ BEGIN
                             IF (unsigned(tc_in(i)(5 DOWNTO 0)) = (s_current_counter_value + 1)) THEN
                                 -- Time Code is not emitted by the link/port that first received the Time Code but from everyone else only.
                                 s_tc_ports <= (i => '0', OTHERS => '1');
+
                             END IF;
 
-                            -- Update Time Code.
-                            s_current_counter_value <= unsigned(tc_in(i)(5 DOWNTO 0));
-                            s_current_ctrl_flag <= tc_in(i)(7 DOWNTO 6);
+                        -- Update Time Code.
+                        s_current_counter_value <= unsigned(tc_in(i)(5 DOWNTO 0));
+                        s_current_ctrl_flag <= tc_in(i)(7 DOWNTO 6);
                         END IF;
                     END LOOP;
                 END IF;
@@ -163,7 +176,7 @@ BEGIN
             IF (rst = '1') THEN
                 -- Synchronous reset.
                 s_auto_tc_counter_value <= c_init_CounterValue;
-                s_auto_counter <= (OTHERS => '0');
+                s_auto_counter <= x"00000000"; -- (Others => '0')
                 s_auto_enable <= '0';
             ELSE
                 -- Sends Time Codes periodically only if register is unequal to zero.
@@ -174,16 +187,19 @@ BEGIN
                         -- Reset counter and send automatically generated Time Code.
                         s_auto_counter <= x"00000000"; -- (OTHERS => '0')
                         s_auto_enable <= '1';
-                        s_auto_tc_counter_value <= (s_auto_tc_counter_value + 1);
+                        s_auto_tc_counter_value <= s_auto_tc_counter_value + 1;
+
                     ELSE
                         -- Increment s_auto_counter every rising_edge(clk).
                         s_auto_counter <= (s_auto_counter + 1); -- (s_auto_counter + 1)
                         s_auto_enable <= '0';
+
                     END IF;
                 ELSE
                     -- (Send no automatically generated Time Codes.)
                     s_auto_enable <= '0';
                     s_auto_counter <= x"00000000"; -- (OTHERS => '0')
+
                 END IF;
             END IF;
         END IF;
